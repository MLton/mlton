(* Heavily modified from SML/NJ sources. *)

(* ml.grm
 *
 * Copyright 1989,1992 by AT&T Bell Laboratories
 *
 * SML/NJ is released under a HPND-style license.
 * See the file NJ-LICENSE for details.
 *)

(* Copyright (C) 2008,2009,2014-2017 Matthew Fluet.
 * Copyright (C) 1999-2006 Henry Cejtin, Matthew Fluet, Suresh
 *    Jagannathan, and Stephen Weeks.
 * Copyright (C) 1997-2000 NEC Research Institute.
 *
 * MLton is released under a HPND-style license.
 * See the file MLton-LICENSE for details.
 *)

fun reg (left, right) = Region.make {left = left, right = right}
fun error (reg, msg) = Control.error (reg, Layout.str msg, Layout.empty)

local
   open Control.Elaborate
in
   val allowOptBar = fn () => current allowOptBar
   val allowOptSemicolon = fn () => current allowOptSemicolon
   val allowRecordPunExps = fn () => current allowRecordPunExps
end

open Ast
structure Field = Record.Field
structure Srecord = SortedRecord

structure Type =
   struct
      open Type

      fun tuple ts =
         Record (Record.tuple (Vector.map (ts, fn t => (Region.bogus, t))))

      val unit = tuple (Vector.new0 ())

      fun arrow (t1, t2) = Con (Longtycon.arrow, Vector.new2 (t1, t2))
   end

structure DatBind =
   struct
      open DatBind

      fun make (dbs, withtypes, left, right) =
         makeRegion' (T {datatypes = dbs, withtypes = withtypes},
                      left, right)
   end

structure Pat =
   struct
      open Pat

      fun tuple ps =
         if 1 = Vector.length ps
            then Paren (Vector.sub (ps, 0))
         else Tuple ps

      val unit = tuple (Vector.new0 ())

      val bogus = unit

      fun makeAs (p1: t, p2: t): node =
         let
            fun err () =
               error (Pat.region p1, "must have variable to left in as pattern")
            fun fixopVar (p : t) =
               case node p of
                  FlatApp ps =>
                     if 1 = Vector.length ps
                        then (case node (Vector.sub (ps, 0)) of
                                 Var {fixop,name} =>
                                    (case Longvid.split name of
                                        ([], vid) =>
                                           SOME (fixop, Vid.toVar vid)
                                      | _ =>
                                           let
                                              val () = err ()
                                           in
                                              SOME (Fixop.None, Var.bogus)
                                           end)
                               | _ => NONE)
                     else NONE
                | _ => NONE
         in
            case fixopVar p1 of
               SOME (fixop, var) =>
                  Layered {fixop = fixop, var = var,
                           constraint = NONE,
                           pat = p2}
             | NONE =>
                  case node p1 of
                     Pat.Constraint (p, t) =>
                        (case fixopVar p of
                            SOME (fixop, var) =>
                               Layered {fixop = fixop, var = var,
                                        constraint = SOME t,
                                        pat = p2}
                          | _ => (err (); bogus))
                   | _ => (err (); bogus)
         end
   end

structure Exp =
   struct
      open Exp

      fun tuple es =
         if 1 = Vector.length es
            then Paren (Vector.sub (es, 0))
         else Record (Record.tuple (Vector.map (es, fn e => (Region.bogus, e))))

      val unit = tuple (Vector.new0 ())
   end

structure Dec =
   struct
      open Dec

      fun sequence (d1: t, d2: t): t =
         makeRegion (case (node d1, node d2) of
                        (SeqDec d1, SeqDec d2) => SeqDec (Vector.concat [d1, d2])
                      | (SeqDec d1, _) =>
                           SeqDec (Vector.concat [d1, Vector.new1 d2])
                      | (_, SeqDec d2) =>
                           SeqDec (Vector.concat [Vector.new1 d1, d2])
                      | _ => SeqDec (Vector.new2 (d1, d2)),
                     Region.append (region d1, region d2))
   end

structure Spec =
   struct
      open Spec

      (* Some of this mess is so that a sharing equation captures as
       * many specs as possible in its scope.
       *)
      fun seq (s: t, s': t): t =
         let
            fun reg s'' = makeRegion (s'', Region.append (region s, region s'))
         in
            case (node s, node s') of
               (Empty, _) => s'
             | (_, Empty) => s
             | (_, Seq (s1, s2)) => reg (Seq (seq (s, s1), s2))
             | (_, Sharing {spec, equation}) =>
                  reg (Sharing {spec = seq (s, spec), equation = equation})
             | _ => reg (Seq (s, s'))
         end
   end

fun consTopdec (d, dss) =
   case dss of
      [] => [[d]]
    | ds :: dss => (d :: ds) :: dss

type rule = Pat.t * Exp.t
type clause = {pats : Pat.t vector,
               resultType : Type.t option,
               body : Exp.t}
type clauses = clause vector
type eb = Con.t * EbRhs.t
type db = {tyvars: Tyvar.t vector,
           tycon: Tycon.t,
           cons: (Con.t * Type.t option) vector}
type tb = {def: Type.t,
           tycon: Tycon.t,
           tyvars: Tyvar.t vector}

type strdesc = Strid.t * Sigexp.t

type typdesc =  {tyvars: Tyvar.t vector,
                 tycon: Tycon.t}

type valdesc = Var.t * Type.t

type exndesc = Con.t * Type.t option

type strbind = {name: Strid.t,
                def: Strexp.t,
                constraint: SigConst.t}

type sigbind = Sigid.t * Sigexp.t

type funbind = {name : Fctid.t,
                arg : FctArg.t,
                result : SigConst.t,
                body : Strexp.t}

type vb = {pat: Pat.t,
           exp: Exp.t}

type rvb = {pat: Pat.t,
            match: Match.t}

fun longIdFromTok (s, left, right) =
   let
      val syms = List.map (String.split (s, #"."), Symbol.fromString)
   in
      (syms, reg (left, right))
   end

fun shortIdFromTok (s, left, right) =
   (Symbol.fromString s, reg (left, right))

fun longIdFromShortId (sym, reg) = ([sym], reg)

fun cons1 (x, (l, y)) = (x :: l, y)

fun augment (id, sigexp, (whereeqns, binds)) =
   (id, Sigexp.wheree (sigexp, Vector.fromList whereeqns))
   :: binds

fun 'a augment1 ((strexp: Strexp.t,
                  sigconst: Sigexp.t -> SigConst.t,
                  sigexp: Sigexp.t),
                 (whereeqns: WhereEquation.t list,
                  z: 'a)): Strexp.t * 'a =
   let
      val sigexp = Sigexp.wheree (sigexp, Vector.fromList whereeqns)
   in
      (Strexp.makeRegion
       (Strexp.Constrained (strexp, sigconst sigexp),
        Region.append (Strexp.region strexp, Sigexp.region sigexp)),
       z)
   end

type 'a whereAndEqns = WhereEquation.t list * 'a list

  %%
  %term
      CHAR of IntInf.t
    | INT of {digits: string,
              extended: bool,
              negate: bool,
              radix: StringCvt.radix}
    | SHORTALPHANUMID of string
    | SHORTSYMID of string
    | LONGALPHANUMID of string
    | LONGSYMID of string
    | REAL of string
    | STRING of IntInf.t vector
    | TYVAR of string
    | WORD of {digits: string,
               radix: StringCvt.radix}
    | ABSTYPE | AND | ANDALSO | ARROW | AS | ASTERISK | BAR | CASE | COLON
    | COLONGT | COMMA | DATATYPE | DOTDOTDOT | ELSE | END | EOF | EQUALOP
    | EQTYPE | EXCEPTION | DO | DARROW | FN | FUN | FUNCTOR | HANDLE | HASH
    | HASHLBRACKET | IF | IN | INCLUDE | INFIX | INFIXR | LBRACE | LBRACKET | LET
    | LOCAL | LPAREN | NONFIX | ORELSE | OF | OP | OPEN | OVERLOAD | RAISE
    | RBRACE | RBRACKET | REC | RPAREN | SEMICOLON | SHARING | SIG | SIGNATURE
    | STRUCT | STRUCTURE | THEN | TYPE | VAL | WHERE | WHILE | WILD | WITH
    | WITHTYPE
      (* Extensions *)
    | BUILD_CONST | COMMAND_LINE_CONST | CONST 
    | ADDRESS | EXPORT | IMPORT | SYMBOL 
    | PRIM
    | SHOW_BASIS of File.t

%nonterm
         aexp of Exp.node
       | apat of Pat.t
       | apatnode of Pat.node
       | apats of Pat.t list
       | app_exp of Exp.t list
       | arg_fct of Strexp.t
       | ieattributes of PrimKind.ImportExportAttribute.t list
       | barcpats of Pat.t list
       | clause of clause
       | clauses of clause list
       | clausesTop of clauses
       | commapats of Pat.t list
       | con of Con.t
       | const of Const.t
       | const' of Const.node
       | constr of Con.t * Type.t option
       | constraint of Type.t option
       | constrs of (Con.t * Type.t option) list
       | constOrBool of Const.t
       | cpat of Pat.t
       | cpatnode of Pat.node
       | datBind of DatBind.t
       | datatypeRhs of DatatypeRhs.t
       | datatypeRhsnode of DatatypeRhs.node
       | db of db
       | dbs of db vector
       | dbs' of db list
       | dec of Dec.t
       | decnode of Dec.node
       | decnolocal of Dec.node
       | decs of Dec.t
       | decsnode of Dec.node
       | digit of int
       | eb of eb
       | ebrhs of EbRhs.t
       | ebrhsnode of EbRhs.node
       | ebs of eb list
       | elabel of (Field.t * (Region.t * Exp.t))
       | elabels of (Field.t * (Region.t * Exp.t)) list
       | exndesc of exndesc
       | exndescs of exndesc list
       | exp of Exp.t
       | exp_2c of Exp.t list
       | exp_list of Exp.t list
       | exp_ps of Exp.t list
       | expnode of Exp.node
       | expsAndTopdecs of Topdec.t list list
       | fctarg of FctArg.node
       | fctid of Fctid.t
       | field of Field.t
       | fixity of Fixity.t
       | funbinds of funbind list
       | funbinds' of Strexp.t * funbind list
       | funbinds'1 of funbind whereAndEqns
       | funbinds'1' of funbind whereAndEqns
       | funbinds'2 of funbind list
       | funs of clauses list
       | idField of Symbol.t * Region.t
       | int of IntInf.t
       | longcon of Longcon.t
       | longAlphanumId of Symbol.t list * Region.t
       | longSymId of Symbol.t list * Region.t
       | longstrid of Longstrid.t
       | longstrideqns of Longstrid.t list
       | longstrids of Longstrid.t list
       | longtycon of Longtycon.t
       | longtyconeqns of Longtycon.t list
       | longvid of Longvid.t
       | longvidEqual of Longvid.t
       | longvidNoEqual of Longvid.t
       | longvidands of Longvid.t list
       | match of Match.t
       | numericField of int
       | opaspat of Pat.t option
       | opcon of Con.t
       | optbar of unit
       | optbar' of unit
       | optsemicolon of unit
       | pat of Pat.t
       | patitem of (Field.t * Region.t * Pat.Item.t)
       | patitems of ((Field.t * Region.t * Pat.Item.t) list * bool)
       | pats of Pat.t list
       | priority of Priority.t
       | program of Program.t
       | repl of DatatypeRhs.node
       | rule of rule
       | rules of rule list
       | rvalbind of rvb list
       | sdec of Dec.t
       | sdecs of Dec.t
       | sdecsPlus of Dec.t
       | sharespec of SharingEquation.node
       | shortAlphanumId of Symbol.t * Region.t
       | shortSymId of Symbol.t * Region.t
       | sigbinds of sigbind list
       | sigbinds' of sigbind whereAndEqns
       | sigbinds'' of sigbind whereAndEqns
       | sigconst of SigConst.t
       | sigexp of Sigexp.t
       | sigexp' of Sigexp.t
       | sigexp'node of Sigexp.node
       | sigexpnode of Sigexp.node
       | sigid of Sigid.t
       | sigids of Sigid.t list
       | spec of Spec.t
       | specnode of Spec.node
       | specs of Spec.t
       | strbinds of strbind list
       | strbinds' of Strexp.t * strbind list
       | strbinds'1 of strbind whereAndEqns
       | strbinds'1' of strbind whereAndEqns
       | strbinds'2 of strbind list
       | strdec of Strdec.t
       | strdecnode of Strdec.node
       | strdecs of Strdec.t
       | strdecsnode of Strdec.node
       | strdescs of strdesc list
       | strdescs' of strdesc whereAndEqns
       | strdescs'' of strdesc whereAndEqns
       | strexp of Strexp.t
       | strexp1 of Strexp.t * (Sigexp.t -> SigConst.t) * Sigexp.t
       | strexp2 of Strexp.t
       | strexp2node of Strexp.node
       | strexpnode of Strexp.node
       | strid of Strid.t
       | string of string
       | symattributes of PrimKind.SymbolAttribute.t list
       | tb of tb
       | tbs of tb vector
       | tbs' of tb list
       | tlabel of (Field.t * (Region.t * Type.t))
       | tlabels  of (Field.t * (Region.t * Type.t)) list
       | topdec of Topdec.t
       | topdecnode of Topdec.node
       | topdecs of Topdec.t list list
       | tuple_ty of Type.t list
       | ty of Type.t
       | ty' of Type.t
       | ty'node of Type.node
       | ty0_pc of Type.t list
       | tyOpt of Type.t option
       | tycon of Tycon.t
       | tynode of Type.node
       | typBind of TypBind.t
       | typdesc of typdesc
       | typdescs of typdesc list
       | tyvar of Tyvar.t
       | tyvar_pc of Tyvar.t list
       | tyvars of Tyvar.t vector
       | tyvarseq of Tyvar.t vector
       | valbind of vb list * rvb list
       | valbindTop of vb vector * rvb vector
       | valdesc of valdesc
       | valdescs of valdesc list
       | vid of Vid.t
       | vidEqual of Vid.t
       | vidNoEqual of Vid.t
       | vids of Vid.t list
       | whereandeqns of WhereEquation.t list
       | whereeqn of (SourcePos.t -> WhereEquation.t)
       | whereeqns of WhereEquation.t vector
       | whereeqns' of WhereEquation.t list
       | withtypes of TypBind.t
       | word of IntInf.t

%verbose
%pos SourcePos.t
%eop EOF
%noshift EOF

%header (functor MLLrValsFun (structure Token: TOKEN
                              structure Ast: AST))

%nonassoc WITHTYPE
%right AND
%right ARROW
%right DARROW 
%left DO
%left ELSE
%left RAISE
%right HANDLE
%left ORELSE
%left ANDALSO
%right AS
%left COLON

%name ML

%keyword ABSTYPE AND AS CASE DATATYPE DOTDOTDOT ELSE END 
  EQTYPE EXCEPTION  DO  DARROW  FN  FUN  FUNCTOR  HANDLE
  IF IN INCLUDE  INFIX  INFIXR  LET  LOCAL  NONFIX  OF  OP
  OPEN OVERLOAD  RAISE  REC  SHARING  SIG  SIGNATURE  STRUCT
  STRUCTURE THEN TYPE VAL WHILE WHERE WITH WITHTYPE
  ORELSE ANDALSO

%change -> VAL | -> THEN | -> ELSE | -> LPAREN | -> SEMICOLON | 
        DARROW -> EQUALOP | EQUALOP -> DARROW | AND -> ANDALSO | COLON -> OF |
        SEMICOLON -> COMMA | COMMA -> SEMICOLON |
        -> IN SHORTALPHANUMID END | -> ELSE SHORTALPHANUMID

%value CHAR (IntInf.fromInt (Char.ord #"a"))
%value INT ({digits = "0", extended = false, negate = false, radix = StringCvt.DEC})
%value SHORTALPHANUMID ("bogus")
%value REAL ("13.0")
%value STRING (Vector.fromList [])
%value TYVAR ("'a")
%value WORD ({digits = "0", radix = StringCvt.DEC})

%%

program: expsAndTopdecs (Program.T expsAndTopdecs)

expsAndTopdecs:
    exp SEMICOLON expsAndTopdecs ([Topdec.fromExp exp] :: expsAndTopdecs)
  | topdecs (topdecs)

topdecs:
      ([])
  | topdec topdecs (consTopdec (topdec, topdecs))
  | SEMICOLON expsAndTopdecs ([] :: expsAndTopdecs)

topdec : topdecnode (Topdec.makeRegion' (topdecnode,
                                         topdecnodeleft,
                                         topdecnoderight))

topdecnode
   : strdec
     (Topdec.Strdec strdec)
   | SIGNATURE sigbinds
     (let
         val sigbinds = Vector.fromList sigbinds
         val d = Topdec.Signature sigbinds
      in
         d
      end)
   | FUNCTOR funbinds
     (Topdec.Functor (Vector.fromList funbinds))

(*---------------------------------------------------*)
(*                    Structures                     *)
(*---------------------------------------------------*)

strdecs : strdecsnode (Strdec.makeRegion'
                       (strdecsnode, strdecsnodeleft, strdecsnoderight))

strdecsnode :                    (Strdec.Seq [])
            | SEMICOLON strdecs  (Strdec.Seq [strdecs])
            | strdec strdecs     (Strdec.Seq [strdec, strdecs])

strdec : strdecnode (Strdec.makeRegion' (strdecnode,
                                         strdecnodeleft, strdecnoderight))

strdecnode
   : STRUCTURE strbinds
     (let
         val strbinds = Vector.fromList strbinds
         val d = Strdec.Structure strbinds
      in
         d
      end)
   | LOCAL strdecs IN strdecs END  (Strdec.Local (strdecs1, strdecs2))
   | decnolocal
     (Strdec.Core (Dec.makeRegion' (decnolocal,
                                    decnolocalleft, decnolocalright)))
   | SHOW_BASIS                    (Strdec.ShowBasis SHOW_BASIS)


strbinds : strid sigconst EQUALOP strbinds'
           (let val (def,strbinds) = strbinds'
            in {name = strid, def = def, constraint = sigconst}
               :: strbinds
            end)

strbinds' : strexp1 strbinds'1    (augment1 (strexp1, strbinds'1))
          | strexp2 strbinds'2    ((strexp2,strbinds'2))

strbinds'1 : strbinds'2                  (([], strbinds'2))
           | WHERE whereeqn strbinds'1'  (cons1 (whereeqn WHEREleft, strbinds'1'))

strbinds'1' : strbinds'1                (strbinds'1)
            | AND whereeqn strbinds'1'  (cons1 (whereeqn ANDleft, strbinds'1'))

strbinds'2 :               ([])
           | AND strbinds  (strbinds)

strexp : strexpnode (Strexp.makeRegion' (strexpnode,
                                         strexpnodeleft, strexpnoderight))

strexpnode
  : strexp1
    (let
        val (strexp, sigconst, sigexp) = strexp1
     in
        Strexp.Constrained (strexp, sigconst sigexp)
     end)
  | strexp1 whereeqns
    (let
        val (strexp,sigconst,sigexp) = strexp1
        val sigexp = Sigexp.wheree (sigexp, whereeqns)
     in
        Strexp.Constrained
        (strexp, sigconst sigexp)
     end)
  | strexp2node
    (strexp2node)

strexp1 : strexp COLON sigexp'    ((strexp,SigConst.Transparent,sigexp'))
        | strexp COLONGT sigexp'  ((strexp,SigConst.Opaque,sigexp'))

strexp2 : strexp2node (Strexp.makeRegion'
                       (strexp2node, strexp2nodeleft, strexp2noderight))

strexp2node
        : longstrid                  (Strexp.Var longstrid)
        | STRUCT strdecs END         (Strexp.Struct strdecs)
        | fctid arg_fct              (Strexp.App (fctid, arg_fct))
        | LET strdecs IN strexp END  (Strexp.Let (strdecs, strexp))

arg_fct : LPAREN strexp RPAREN   (Strexp.makeRegion'
                                  (Strexp.node strexp,
                                   LPARENleft, RPARENright))
        | LPAREN strdecs RPAREN  (Strexp.makeRegion'
                                  (Strexp.Struct strdecs,
                                   LPARENleft, RPARENright))

(*---------------------------------------------------*)
(*                    Signatures                     *)
(*---------------------------------------------------*)

sigexp
  : sigexp'            (sigexp')
  | sigexp' whereeqns  (Sigexp.wheree (sigexp', whereeqns))

whereeqns : whereeqns' (Vector.fromList whereeqns')

whereeqns'
  : WHERE whereeqn               ([whereeqn WHEREleft])
  | WHERE whereeqn whereeqns'    (whereeqn WHEREleft :: whereeqns')
  | WHERE whereeqn whereandeqns  (whereeqn WHEREleft :: whereandeqns)

whereandeqns
  : AND whereeqn               ([whereeqn ANDleft])
  | AND whereeqn whereandeqns  (whereeqn ANDleft :: whereandeqns)
  | AND whereeqn whereeqns'    (whereeqn ANDleft :: whereeqns')

sigbinds: sigid EQUALOP sigexp' sigbinds'  (augment (sigid, sigexp', sigbinds'))

sigexp' : sigexp'node (Sigexp.makeRegion' (sigexp'node,
                                           sigexp'nodeleft,
                                           sigexp'noderight))

sigexp'node : sigid                      (Sigexp.Var sigid)
            | SIG specs END              (Sigexp.Spec specs)

sigbinds':                            (([], []))
         | AND sigbinds               (([], sigbinds))
         | WHERE whereeqn sigbinds''  (cons1 (whereeqn WHEREleft, sigbinds''))

sigbinds'' : sigbinds'                (sigbinds')
           | AND whereeqn sigbinds''  (cons1 (whereeqn ANDleft, sigbinds''))

whereeqn  : TYPE tyvars longtycon EQUALOP ty  (fn eqnleft =>
                                               WhereEquation.makeRegion'
                                               (WhereEquation.Type {tyvars = tyvars,
                                                                    longtycon = longtycon,
                                                                    ty = ty},
                                                eqnleft,
                                                tyright))

sigconst :                 (SigConst.None)
         | COLON sigexp    (SigConst.Transparent sigexp)
         | COLONGT sigexp  (SigConst.Opaque sigexp)

specs  :                   (Spec.makeRegion (Spec.Empty, Region.bogus))
       | SEMICOLON specs   (specs)
       | spec specs        (Spec.seq (spec, specs))

spec : specnode (Spec.makeRegion' (specnode, specnodeleft, specnoderight))

specnode : VAL valdescs         (Spec.Val (Vector.fromList valdescs))
         | TYPE typdescs        (Spec.Type (Vector.fromList typdescs))
         | TYPE typBind         (Spec.TypeDefs typBind)
         | EQTYPE typdescs      (Spec.Eqtype (Vector.fromList typdescs))
         | DATATYPE datatypeRhs (Spec.Datatype datatypeRhs)
         | EXCEPTION exndescs   (Spec.Exception (Vector.fromList exndescs))
         | STRUCTURE strdescs   (Spec.Structure (Vector.fromList strdescs))
         | INCLUDE sigexp       (Spec.IncludeSigexp sigexp)
         | INCLUDE sigid sigids (* p. 59 *)
           (Spec.IncludeSigids (Vector.fromList (sigid :: sigids)) )
         | sharespec
           (Spec.Sharing {spec = Spec.makeRegion' (Spec.Empty,
                                                   sharespecleft,
                                                   sharespecright),
                          equation = (SharingEquation.makeRegion'
                                      (sharespec,
                                       sharespecleft,
                                       sharespecright))})

sharespec : SHARING TYPE longtyconeqns (SharingEquation.Type longtyconeqns)
          | SHARING longstrideqns      (SharingEquation.Structure longstrideqns)

longstrideqns : longstrid EQUALOP longstrid ([longstrid1,longstrid2])
              | longstrid EQUALOP longstrideqns (longstrid :: longstrideqns)

longtyconeqns : longtycon EQUALOP longtycon ([longtycon1,longtycon2])
              | longtycon EQUALOP longtyconeqns (longtycon :: longtyconeqns)

strdescs : strid COLON sigexp' strdescs'  (augment (strid, sigexp', strdescs'))

strdescs' :                            (([], []))
          | AND strdescs               (([], strdescs))
          | WHERE whereeqn strdescs''  (cons1 (whereeqn WHEREleft, strdescs''))

strdescs'' : strdescs'                (strdescs')
           | AND whereeqn strdescs''  (cons1 (whereeqn ANDleft, strdescs''))

typdescs : typdesc               ([typdesc])
         | typdesc AND typdescs  (typdesc :: typdescs)

typdesc : tyvars tycon ({tyvars = tyvars,
                         tycon = tycon})

valdescs : valdesc                ([valdesc])
         | valdesc AND valdescs   (valdesc :: valdescs)

valdesc : vid COLON ty  (Vid.toVar vid, ty)

exndescs : exndesc                ([exndesc])
         | exndesc AND exndescs   (exndesc :: exndescs)

exndesc : con tyOpt  (con, tyOpt)

tyOpt :         (NONE)
      | OF ty   (SOME ty)

(*---------------------------------------------------*)
(*                     Functors                      *)
(*---------------------------------------------------*)

funbinds : fctid LPAREN fctarg RPAREN sigconst EQUALOP funbinds'
           (let val (strexp,funbinds) = funbinds'
            in {name = fctid,
                arg = FctArg.makeRegion' (fctarg, fctargleft, fctargright),
                result = sigconst,
                body = strexp}
               :: funbinds
            end)

funbinds' : strexp1 funbinds'1  (augment1 (strexp1, funbinds'1))
          | strexp2 funbinds'2  ((strexp2, funbinds'2))

funbinds'1 : funbinds'2                  ([], funbinds'2)
           | WHERE whereeqn funbinds'1'  (cons1 (whereeqn WHEREleft, funbinds'1'))

funbinds'2 :               ([])
           | AND funbinds  (funbinds)

funbinds'1' : funbinds'1                (funbinds'1)
            | AND whereeqn funbinds'1'  (cons1 (whereeqn ANDleft, funbinds'1'))

fctarg : strid COLON sigexp  (FctArg.Structure (strid, sigexp))
       | specs               (FctArg.Spec specs)

(*---------------------------------------------------*)
(*                   Declarations                    *)
(*---------------------------------------------------*)

decs :                  (Dec.makeRegion' (Dec.SeqDec (Vector.new0 ()),
                                          defaultPos, defaultPos))
     | dec decs         (Dec.sequence (dec,decs))
     | SEMICOLON decs   (decs)

dec : decnode (Dec.makeRegion' (decnode, decnodeleft, decnoderight))

decnode : decnolocal              (decnolocal) 
        | LOCAL decs IN decs END  (Dec.Local (decs1,decs2))

decnolocal
        : VAL valbindTop          (Dec.Val {tyvars = Vector.new0 (),
                                            vbs = #1 valbindTop,
                                            rvbs = #2 valbindTop})
        | VAL tyvarseq valbindTop  (Dec.Val {tyvars = tyvarseq,
                                             vbs = #1 valbindTop,
                                             rvbs = #2 valbindTop})
        | DO exp                (Dec.DoDec exp)
        | FUN funs              (Dec.Fun {tyvars = Vector.new0 (), fbs = Vector.fromList funs})
        | FUN tyvarseq funs     (Dec.Fun {tyvars = tyvarseq, fbs = Vector.fromList funs})
        | TYPE typBind          (Dec.Type typBind)
        | DATATYPE datatypeRhs  (Dec.Datatype datatypeRhs)
        | ABSTYPE datBind WITH decs END   (Dec.Abstype {datBind = datBind,
                                                        body = decs})
        | EXCEPTION ebs         (Dec.Exception (Vector.fromList ebs))
        | OPEN longstrids       (Dec.Open (Vector.fromList longstrids))
        | fixity vids           (Dec.Fix {fixity = fixity,
                                          ops = Vector.fromList vids})
        | OVERLOAD priority vid COLON ty AS longvidands
                                (Dec.Overload (priority, 
                                               Vid.toVar vid,
                                               Vector.new0 (),
                                               ty,
                                               Vector.fromList longvidands))

valbindTop : valbind (let
                         val (vbs, rvbs) = valbind
                      in
                         (Vector.fromList vbs,
                          Vector.fromList rvbs)
                      end)

valbind : pat EQUALOP exp
             (([{pat = pat, exp = exp}], []))
        | pat EQUALOP exp AND valbind
             (let
                 val (vbs, rvbs) = valbind
              in
                 ({pat = pat, exp = exp} :: vbs,
                  rvbs)
              end)
        | REC rvalbind                 (([], rvalbind))

rvalbind : REC rvalbind                (rvalbind)
         | pat EQUALOP FN match
             ([{pat = pat, match = match}])
         | pat EQUALOP FN match AND rvalbind
             ({pat = pat, match = match} :: rvalbind)

constraint :                    (NONE)
           | COLON ty           (SOME ty)

funs    : clausesTop               ([clausesTop])
        | clausesTop AND funs      (clausesTop :: funs)

clausesTop: clauses (Vector.fromList clauses)
          | optbar' clauses (Vector.fromList clauses)

clauses : clause                ([clause])
        | clause BAR clauses    (clause :: clauses)

clause  : apats constraint EQUALOP exp  ({pats = Vector.fromList apats,
                                          resultType = constraint,
                                          body = exp})

typBind : tbs
          (TypBind.makeRegion' (TypBind.T tbs, tbsleft, tbsright))

tbs : tbs'  (Vector.fromList tbs')

tbs' : tb           ([tb])
     | tb AND tbs'  (tb :: tbs')

tb : tyvars tycon EQUALOP ty
     ({def = ty,
       tycon = tycon,
       tyvars = tyvars})

tyvars  : tyvarseq (tyvarseq)
        |          (Vector.new0 ())

tyvarseq: tyvar                   (Vector.new1 tyvar)
        | LPAREN tyvar_pc RPAREN  (Vector.fromList tyvar_pc)

tyvar_pc: tyvar                ([tyvar])
        | tyvar COMMA tyvar_pc (tyvar :: tyvar_pc)

constrs : constr                ([constr])
        | constr BAR constrs    (constr :: constrs)

constr  : opcon         (opcon, NONE)
        | opcon OF ty   (opcon, SOME ty)

opcon   : con           (con)
        | OP con        (con)

ebs     : eb              ([eb])
        | eb AND ebs      (eb::ebs)

eb      : opcon ebrhs     (opcon, ebrhs)

ebrhs : ebrhsnode (EbRhs.makeRegion' (ebrhsnode,
                                     ebrhsnodeleft, ebrhsnoderight))

ebrhsnode   :                    (EbRhs.Gen NONE)
            | OF ty              (EbRhs.Gen (SOME ty))
            | EQUALOP longcon    (EbRhs.Def longcon)
            | EQUALOP OP longcon (EbRhs.Def longcon)

fixity  : INFIX                 (Fixity.Infix NONE)
        | INFIX digit           (Fixity.Infix (SOME digit))
        | INFIXR                (Fixity.Infixr NONE)
        | INFIXR digit          (Fixity.Infixr (SOME digit))
        | NONFIX                (Fixity.Nonfix)

priority :                      (Priority.T NONE)
         | digit                (Priority.T (SOME digit))

int : INT
   (let
       val {digits, negate, radix, ...} = INT
    in
       case StringCvt.scanString (fn r => IntInf.scan (radix, r)) digits of
          NONE => Error.bug "parser saw invalid int"
        | SOME i => if negate then ~ i else i
    end)

word : WORD
   (let
       val {digits, radix} = WORD
    in
       case StringCvt.scanString (fn r => IntInf.scan (radix, r)) digits of
          NONE => Error.bug "parser saw invalid word"
        | SOME i => i
    end)

digit : INT
   (let
       val {digits, extended, negate, radix} = INT
    in
       if 1 = String.size digits andalso not extended andalso not negate andalso radix = StringCvt.DEC
          then valOf (Int.fromString digits)
       else let
               open Layout
               val _ = 
                  Control.error (reg (INTleft, INTright),
                                 str "invalid digit in infix declaration",
                                 empty)
            in
               0
            end
    end)

numericField : INT
   (let
       val {digits, extended, negate, radix} = INT
       fun err () =
          let
             open Layout
             val _ =
                Control.error (reg (INTleft, INTright),
                               str "invalid numeric label",
                               empty)
          in
             1
          end
    in
       if String.sub (digits, 0) <> #"0" andalso not extended andalso not negate andalso radix = StringCvt.DEC
          then case StringCvt.scanString (fn r => IntInf.scan (radix, r)) digits of
                  NONE => Error.bug "parser saw invalid int"
                | SOME i => (IntInf.toInt (if negate then ~ i else i)
                             handle Exn.Overflow => err ())
       else err ()
    end)

datatypeRhs
   : datatypeRhsnode
     (DatatypeRhs.makeRegion' (datatypeRhsnode,
                               datatypeRhsnodeleft, datatypeRhsnoderight))

datatypeRhsnode
   : repl              (repl)
   | datBind           (DatatypeRhs.DatBind datBind)

repl : tyvars tycon EQUALOP DATATYPE longtycon
       (if Vector.isEmpty tyvars
           then ()
        else error (reg (tyvarsleft, tyvarsright),
                    "nonempty tyvars in datatype repl")
        ; DatatypeRhs.Repl {lhs = tycon, rhs = longtycon})

datBind
   : dbs
     (DatBind.make (dbs, TypBind.empty, dbsleft, dbsright))
   | dbs withtypes
     (DatBind.make (dbs, withtypes, dbsleft, withtypesright))

dbs : dbs' (Vector.fromList dbs')

dbs' : db           ([db])
     | db AND dbs'  (db :: dbs')

db : tyvars tycon EQUALOP optbar constrs
     ({cons = Vector.fromList constrs,
       tycon = tycon,
       tyvars = tyvars})

withtypes : WITHTYPE typBind  (typBind)

longvidands : longvid  ([longvid])
            | longvid AND longvidands (longvid :: longvidands)

match : optbar rules    (Match.makeRegion' (Match.T (Vector.fromList rules),
                                            rulesleft, rulesright))

rules : rule            ([rule])
      | rule BAR rules  (rule :: rules)

rule    : pat DARROW exp        ((pat,exp))

elabel  : field EQUALOP exp     (field, (reg (fieldleft, fieldright), exp))
        | idField constraint    (if allowRecordPunExps ()
                                    then ()
                                    else error (reg (idFieldleft, idFieldright), "Record punning expressions disallowed, compile with -default-ann 'allowRecordPunExps true'")
                                 ; (Field.Symbol (#1 idField),
                                    (reg (idFieldleft, idFieldright),
                                     let
                                        val exp =
                                           Exp.makeRegion'
                                           (Exp.FlatApp
                                            (Vector.new1
                                             (Exp.makeRegion'
                                              (Exp.Var {name = Longvid.short (Vid.fromSymbol idField),
                                                        fixop = Fixop.None},
                                               idFieldleft, idFieldright))),
                                            idFieldleft, idFieldright)
                                        val exp =
                                           case constraint of
                                              NONE => exp
                                            | SOME ty =>
                                                 Exp.makeRegion'
                                                 (Exp.Constraint (exp, ty),
                                                  idFieldleft, constraintright)
                                     in
                                        exp
                                     end)))

elabels : elabel COMMA elabels  (elabel :: elabels)
        | elabel                ([elabel])

exp_ps  : exp optsemicolon      ([exp])
        | exp SEMICOLON exp_ps  (exp :: exp_ps)

exp : expnode (Exp.makeRegion' (expnode, expnodeleft, expnoderight))

expnode : exp HANDLE match      (Exp.Handle (exp, match))
        | exp ORELSE exp        (Exp.Orelse (exp1, exp2))
        | exp ANDALSO exp       (Exp.Andalso (exp1, exp2))
        | exp COLON ty          (Exp.Constraint (exp, ty))
        | app_exp               (Exp.FlatApp (Vector.fromList app_exp))
        | FN match              (Exp.Fn match)
        | CASE exp OF match     (Exp.Case (exp, match))
        | WHILE exp DO exp      (Exp.While {test = exp1, expr = exp2})
        | IF exp THEN exp ELSE exp (Exp.If (exp1, exp2, exp3))
        | RAISE exp             (Exp.Raise exp)

app_exp : aexp             ([Exp.makeRegion' (aexp, aexpleft, aexpright)])
        | aexp app_exp     (Exp.makeRegion' (aexp, aexpleft, aexpright)
                            :: app_exp)
        | longvid          ([Exp.makeRegion' (Exp.Var {name = longvid,
                                                       fixop = Fixop.None},
                                              longvidleft, longvidright)])
        | longvid app_exp  (Exp.makeRegion' (Exp.Var {name = longvid,
                                                      fixop = Fixop.None},
                                             longvidleft, longvidright)
                            :: app_exp)

aexp    : OP longvid            (Exp.Var {name = longvid,
                                          fixop = Fixop.Op})
        | const                 (Exp.Const const)
        | HASH field            (Exp.Selector field)
        | HASHLBRACKET exp_list RBRACKET (Exp.Vector (Vector.fromList exp_list))
        | HASHLBRACKET RBRACKET          (Exp.Vector (Vector.new0 ()))
        | LBRACE elabels RBRACE
          (Exp.Record (Record.fromVector (Vector.fromList elabels)))
        | LBRACE RBRACE         (Exp.unit)
        | LPAREN RPAREN         (Exp.unit)
        | LPAREN exp_ps RPAREN
            (case exp_ps of
                [exp] => Exp.Paren exp
              | _ => Exp.Seq (Vector.fromList exp_ps))
        | LPAREN exp_2c RPAREN  (Exp.tuple (Vector.fromList exp_2c))
        | LBRACKET exp_list RBRACKET  (Exp.List (Vector.fromList exp_list))
        | LBRACKET RBRACKET           (Exp.List (Vector.new0 ()))
        | LET decs IN exp_ps END
            (Exp.Let (decs,
                      case exp_ps of
                         [exp] => exp
                       | _ => Exp.makeRegion' (Exp.Seq (Vector.fromList exp_ps),
                                               exp_psleft, exp_psright)))
        | ADDRESS string symattributes COLON ty SEMICOLON
          (Exp.Prim (PrimKind.Address {attributes = symattributes,
                                       name = string,
                                       ty = ty}))
        | BUILD_CONST string COLON ty SEMICOLON
          (Exp.Prim (PrimKind.BuildConst {name = string, ty = ty}))
        | COMMAND_LINE_CONST string COLON ty EQUALOP constOrBool SEMICOLON
          (Exp.Prim (PrimKind.CommandLineConst {name = string,
                                                ty = ty,
                                                value = constOrBool}))
        | CONST string COLON ty SEMICOLON
          (Exp.Prim (PrimKind.Const {name = string, ty = ty}))
        | EXPORT string ieattributes COLON ty SEMICOLON
          (Exp.Prim (PrimKind.Export {attributes = ieattributes,
                                      name = string,
                                      ty = ty}))
        | IMPORT string ieattributes COLON ty SEMICOLON
          (Exp.Prim (PrimKind.Import {attributes = ieattributes,
                                      name = string,
                                      ty = ty}))
        | IMPORT ASTERISK ieattributes COLON ty SEMICOLON
          (Exp.Prim (PrimKind.IImport {attributes = ieattributes,
                                       ty = ty}))
        | PRIM string COLON ty SEMICOLON
          (Exp.Prim (PrimKind.Prim {name = string,
                                    ty = ty}))
        | SYMBOL string symattributes COLON ty SEMICOLON
          (Exp.Prim (PrimKind.Symbol {attributes = symattributes,
                                      name = string,
                                      ty = ty}))
        | SYMBOL ASTERISK COLON ty SEMICOLON
          (Exp.Prim (PrimKind.ISymbol {ty = ty}))

ieattributes
   :
     ([])
   | shortAlphanumId ieattributes
     (let
         val (id, reg) = shortAlphanumId
      in
         case Symbol.toString id of
            "cdecl" => PrimKind.ImportExportAttribute.Cdecl :: ieattributes
          | "external" => PrimKind.ImportExportAttribute.External :: ieattributes
          | "impure" => PrimKind.ImportExportAttribute.Impure :: ieattributes
          | "private" => PrimKind.ImportExportAttribute.Private :: ieattributes
          | "public" => PrimKind.ImportExportAttribute.Public :: ieattributes
          | "pure" => PrimKind.ImportExportAttribute.Pure :: ieattributes
          | "reentrant" => PrimKind.ImportExportAttribute.Reentrant :: ieattributes
          | "runtime" => PrimKind.ImportExportAttribute.Runtime :: ieattributes
          | "stdcall" => PrimKind.ImportExportAttribute.Stdcall :: ieattributes
          | id => (error (reg, concat ["invalid attribute: ", id])
                   ; ieattributes)
      end)

symattributes
   :
     ([])
   | shortAlphanumId symattributes
     (let
         val (id, reg) = shortAlphanumId
      in
         case Symbol.toString id of
            "alloc" => PrimKind.SymbolAttribute.Alloc :: symattributes
          | "external" => PrimKind.SymbolAttribute.External :: symattributes
          | "private" => PrimKind.SymbolAttribute.Private :: symattributes
          | "public" => PrimKind.SymbolAttribute.Public :: symattributes
          | id => (error (reg, concat ["invalid attribute: ", id])
                   ; symattributes)
      end)

exp_2c  : exp COMMA exp_2c      (exp :: exp_2c)
        | exp COMMA exp         ([exp1, exp2])

exp_list : exp                  ([exp])
         | exp COMMA exp_list   (exp :: exp_list)

(*---------------------------------------------------*)
(*                     Patterns                      *)
(*---------------------------------------------------*)

pat : cpat BAR barcpats  (Pat.makeRegion' (Pat.Or (Vector.fromList (cpat::barcpats)),
                                           cpatleft, barcpatsright))
    | cpat               (cpat)

cpat : cpatnode (Pat.makeRegion' (cpatnode, cpatnodeleft, cpatnoderight))

cpatnode : cpat AS cpat   (Pat.makeAs (cpat1, cpat2))
         | cpat COLON ty  (Pat.Constraint (cpat, ty))
         | apats          (Pat.FlatApp (Vector.fromList apats))

apats : apat        ([apat])
      | apat apats  (apat :: apats)

apat
  : apatnode (Pat.makeRegion' (apatnode,
                               apatnodeleft,
                               apatnoderight))

apatnode
  : longvidNoEqual              (Pat.Var {name = longvidNoEqual,
                                          fixop = Fixop.None})
  | OP longvid                  (Pat.Var {name = longvid,
                                          fixop = Fixop.Op})
  | const
      (let
          val _ =
             case Const.node const of
                Const.Real r =>
                   let
                      open Layout
                   in
                      Control.error
                      (Const.region const,
                       seq [str "real constants not allowed in patterns: ",
                            Const.layout const],
                       empty)
                   end
              | _ => ()
       in
          Pat.Const const
       end)
  | WILD                        (Pat.Wild)
  | LPAREN pats RPAREN          (Pat.tuple (Vector.fromList pats))
  | LBRACKET pats RBRACKET      (Pat.List (Vector.fromList pats))
  | HASHLBRACKET pats RBRACKET  (Pat.Vector (Vector.fromList pats))
  | LBRACE RBRACE               (Pat.unit)
  | LBRACE patitems RBRACE
      (let
          val (items, flexible) = patitems
       in
          Pat.Record {flexible = flexible,
                      items = Vector.fromList items}
       end)

pats : ([])
     | pat commapats (pat :: commapats)

barcpats : cpat ([cpat])
         | cpat BAR barcpats (cpat :: barcpats)

commapats : ([])
          | COMMA pat commapats (pat :: commapats)

patitems : patitem COMMA patitems  (let val (items, f) = patitems
                                    in (patitem :: items, f)
                                    end)
         | patitem              ([patitem], false)
         | DOTDOTDOT            ([], true)

patitem
   : field EQUALOP pat
     ((field, reg (fieldleft, fieldright), Pat.Item.Field pat))
   | vid constraint opaspat
     (Field.Symbol (Vid.toSymbol vid),
      reg (vidleft, vidright),
      Pat.Item.Vid (vid, constraint, opaspat))

opaspat :         (NONE)
        | AS pat  (SOME pat)

(*---------------------------------------------------*)
(*                       Types                       *)
(*---------------------------------------------------*)

ty : tynode (Type.makeRegion' (tynode, tynodeleft, tynoderight))

tynode  : tuple_ty      (Type.tuple (Vector.fromList tuple_ty))
        | ty ARROW ty   (Type.arrow (ty1, ty2))
        | ty'node       (ty'node)

ty' : ty'node (Type.makeRegion' (ty'node, ty'nodeleft, ty'noderight))

ty'node : tyvar                           (Type.Var tyvar)
        | LBRACE tlabels RBRACE
          (Type.Record (Record.fromVector (Vector.fromList tlabels)))
        | LBRACE RBRACE                   (Type.unit)
        | LPAREN ty0_pc RPAREN longtycon  (Type.Con (longtycon,
                                                     Vector.fromList ty0_pc))
        | LPAREN ty RPAREN                (Type.Paren ty)
        | ty' longtycon                   (Type.Con (longtycon,
                                                     Vector.new1 ty'))
        | longtycon                       (Type.Con (longtycon,
                                                     Vector.new0 ()))

tlabel  : field COLON ty        (field, (reg (fieldleft, fieldright), ty))

tlabels : tlabel COMMA tlabels  (tlabel :: tlabels)
        | tlabel                ([tlabel])

tuple_ty : ty' ASTERISK tuple_ty        (ty' :: tuple_ty)
         | ty' ASTERISK ty'             ([ty'1, ty'2])

ty0_pc  : ty COMMA ty           ([ty1, ty2])
        | ty COMMA ty0_pc       (ty :: ty0_pc)

(*---------------------------------------------------*)
(*                       Atoms                       *)
(*---------------------------------------------------*)

optbar
   : (* empty *) ()
   | optbar'     ()

optbar'
   : BAR         (if allowOptBar ()
                    then ()
                    else error (reg (BARleft, BARright), "Optional bar disallowed, compile with -default-ann 'allowOptBar true'"))

optsemicolon
   : (* empty *) ()
   | SEMICOLON   (if allowOptSemicolon ()
                    then ()
                    else error (reg (SEMICOLONleft, SEMICOLONright), "Optional semicolon disallowed, compile with -default-ann 'allowOptSemicolon true'"))

constOrBool
   : const (const)
   | shortAlphanumId
        (let
            fun ok b = Const.makeRegion (Const.Bool b, #2 shortAlphanumId)
         in            
            case Symbol.toString (#1 shortAlphanumId) of
               "false" => ok false
             | "true" => ok true
             | s => (error (#2 shortAlphanumId, concat ["unknown boolean constant: ", s])
                     ; ok false)
         end)

const   : const'                (Const.makeRegion
                                 (const', reg (const'left, const'right)))

const'  : int                   (Const.Int int)
        | word                  (Const.Word word)
        | REAL                  (Const.Real REAL)
        | STRING                (Const.String STRING)
        | CHAR                  (Const.Char CHAR)

string : STRING  (CharVector.tabulate
                  (Vector.length STRING, fn i =>
                   Char.fromInt (Int.fromIntInf (Vector.sub (STRING, i)))))


shortAlphanumId
  : SHORTALPHANUMID
    (shortIdFromTok (SHORTALPHANUMID, SHORTALPHANUMIDleft, SHORTALPHANUMIDright))
shortSymId
  : SHORTSYMID
    (shortIdFromTok (SHORTSYMID, SHORTSYMIDleft, SHORTSYMIDright))
longAlphanumId
  : LONGALPHANUMID
    (longIdFromTok (LONGALPHANUMID, LONGALPHANUMIDleft, LONGALPHANUMIDright))
longSymId
  : LONGSYMID
    (longIdFromTok (LONGSYMID, LONGSYMIDleft, LONGSYMIDright))

vidNoEqual : shortAlphanumId  (Vid.fromSymbol shortAlphanumId)
           | shortSymId       (Vid.fromSymbol shortSymId)
           | ASTERISK         (Vid.fromSymbol (Symbol.asterisk,
                                               reg (ASTERISKleft, ASTERISKright)))
vidEqual : EQUALOP            (Vid.fromSymbol (Symbol.equal,
                                               reg (EQUALOPleft, EQUALOPright)))
vid : vidNoEqual  (vidNoEqual)
    | vidEqual    (vidEqual)
longvidNoEqual : vidNoEqual      (Longvid.short vidNoEqual)
               | longAlphanumId  (Longvid.fromSymbols longAlphanumId)
               | longSymId       (Longvid.fromSymbols longSymId)
longvidEqual : vidEqual        (Longvid.short vidEqual)
longvid : longvidNoEqual  (longvidNoEqual)
        | longvidEqual    (longvidEqual)

con : vid  (Vid.toCon vid)
longcon : longvid  (Longvid.toLongcon longvid)

tyvar : TYVAR  (Tyvar.fromSymbol (Symbol.fromString TYVAR, reg (TYVARleft, TYVARright)))

tycon : shortAlphanumId  (Tycon.fromSymbol shortAlphanumId)
      | shortSymId       (Tycon.fromSymbol shortSymId)
longtycon : tycon           (Longtycon.short tycon)
          | longAlphanumId  (Longtycon.fromSymbols longAlphanumId)

idField : shortAlphanumId  (shortAlphanumId)
        | shortSymId       (shortSymId)
        | ASTERISK         ((Symbol.asterisk,
                             reg (ASTERISKleft, ASTERISKright)))
field : idField            (Field.Symbol (#1 idField))
      | numericField       (Field.Int (numericField - 1))

strid : shortAlphanumId  (Strid.fromSymbol shortAlphanumId)
longstrid : strid           (Longstrid.short strid)
          | longAlphanumId  (Longstrid.fromSymbols longAlphanumId)

sigid : shortAlphanumId  (Sigid.fromSymbol shortAlphanumId)
fctid : shortAlphanumId  (Fctid.fromSymbol shortAlphanumId)

vids : vid                     ([vid])
     | vid vids                (vid::vids)

sigids : sigid                 ([sigid])
       | sigid sigids          (sigid :: sigids)

longstrids : longstrid             ([longstrid])
           | longstrid longstrids  (longstrid :: longstrids)
