diff --git a/Doc/html/mltex2html b/Doc/html/mltex2html
index 24d393f..6e58ea0 100755
--- a/Doc/html/mltex2html
+++ b/Doc/html/mltex2html
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl
+#!/usr/bin/perl
 #
 # This tool generates HTML pages in my own format given a stylized Latex file.
 #
diff --git a/README.mlton b/README.mlton
new file mode 100644
index 0000000..2aae5cb
--- /dev/null
+++ b/README.mlton
@@ -0,0 +1,9 @@
+The following changes were made to the MLRISC Library, in addition to
+deriving the `.mlb` files from the `.cm` files:
+
+* eliminate _or-patterns_: Duplicate the whole match (`p => e`) at each of the patterns.
+* eliminate vector constants: Change `#[` to `Vector.fromList [`.
+* eliminate `withtype` in signatures.
+* eliminate sequential `withtype` expansions: Most could be rewritten as a sequence of type definitions and datatype definitions.
+* eliminate higher-order functors: Every higher-order functor definition and application could be uncurried in the obvious way.
+* eliminate `where <str> = <str>`: Quite painful to expand out all the flexible types in the respective structures.  Furthermore, many of the implied type equalities aren't needed, but it's too hard to pick out the right ones.
diff --git a/aliasing/pointsTo.sig b/aliasing/pointsTo.sig
index 9abcd4b..35655ef 100644
--- a/aliasing/pointsTo.sig
+++ b/aliasing/pointsTo.sig
@@ -7,18 +7,27 @@ signature POINTS_TO =
 sig
 
    eqtype edgekind 
-   structure C : CELLS_BASIS = CellsBasis
+   structure C : CELLS_BASIS (* = CellsBasis *)
+                 where type CellSet.cellset = CellsBasis.CellSet.cellset
+                   and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                   and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                   and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                   and type cell = CellsBasis.cell
+                   and type cellColor = CellsBasis.cellColor
+                   and type cellkind = CellsBasis.cellkind
+                   and type cellkindDesc = CellsBasis.cellkindDesc
+                   and type cellkindInfo = CellsBasis.cellkindInfo
 
    datatype cell = 
-     LINK  of region                             
-   | SREF  of C.cell * edges ref
-   | WREF  of C.cell * edges ref
-   | SCELL of C.cell * edges ref
-   | WCELL of C.cell * edges ref
+     LINK  of cell ref
+   | SREF  of C.cell * (edgekind * int * cell ref) list ref
+   | WREF  of C.cell * (edgekind * int * cell ref) list ref
+   | SCELL of C.cell * (edgekind * int * cell ref) list ref
+   | WCELL of C.cell * (edgekind * int * cell ref) list ref
    | TOP   of {mutable:bool, id:C.cell, name:string}
       (* a collapsed node *)
-   withtype region = cell ref
-   and      edges  = (edgekind * int * region) list
+   type region = cell ref
+   type edges  = (edgekind * int * region) list
 
    val reset    : (unit -> C.cell) -> unit
 
diff --git a/aliasing/pointsTo.sml b/aliasing/pointsTo.sml
index 5e6c79f..8442b91 100644
--- a/aliasing/pointsTo.sml
+++ b/aliasing/pointsTo.sml
@@ -10,25 +10,30 @@ struct
    structure C = CellsBasis
 
    datatype cell = 
-     LINK  of region
-   | SREF  of C.cell * edges ref
-   | WREF  of C.cell * edges ref
-   | SCELL of C.cell * edges ref
-   | WCELL of C.cell * edges ref
+     LINK  of cell ref
+   | SREF  of C.cell * (edgekind * int * cell ref) list ref
+   | WREF  of C.cell * (edgekind * int * cell ref) list ref
+   | SCELL of C.cell * (edgekind * int * cell ref) list ref
+   | WCELL of C.cell * (edgekind * int * cell ref) list ref
    | TOP   of {mutable:bool, id:C.cell, name:string}
       (* a collapsed node *)
-
-   withtype region = cell ref
-   and      edges  = (edgekind * int * region) list
+   type region = cell ref
+   type edges  = (edgekind * int * region) list
 
    fun error msg = MLRiscErrorMsg.error("PointsTo",msg)
 
    (* PI > DOM > RAN > RECORD *)
    fun greaterKind(PI,_) = false   
      | greaterKind(DOM,PI) = false
-     | greaterKind(RAN,(PI | DOM)) = false
-     | greaterKind(RECORD,(PI | DOM | RAN)) = false
-     | greaterKind(MARK,(PI | DOM | RAN | RECORD)) = false
+     | greaterKind(RAN,PI) = false
+     | greaterKind(RAN,DOM) = false
+     | greaterKind(RECORD,PI) = false
+     | greaterKind(RECORD,DOM) = false
+     | greaterKind(RECORD,RAN) = false
+     | greaterKind(MARK,PI) = false
+     | greaterKind(MARK,DOM) = false
+     | greaterKind(MARK,RAN) = false
+     | greaterKind(MARK,RECORD) = false
      | greaterKind _ = true
 
    fun less(k,i,k',i') = k=k' andalso i > i' orelse greaterKind(k,k')
diff --git a/alpha/backpatch/alphaJumps.sml b/alpha/backpatch/alphaJumps.sml
index df1d5ff..5636e24 100644
--- a/alpha/backpatch/alphaJumps.sml
+++ b/alpha/backpatch/alphaJumps.sml
@@ -5,10 +5,67 @@
  *)
 functor AlphaJumps
   (structure Instr : ALPHAINSTR
-   structure Shuffle : ALPHASHUFFLE 
-			   where I = Instr
-   structure MLTreeEval : MLTREE_EVAL 
-			   where T = Instr.T
+   structure Shuffle : ALPHASHUFFLE (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         and type I.branch = Instr.branch
+                         and type I.cmove = Instr.cmove
+                         and type I.ea = Instr.ea
+                         and type I.fbranch = Instr.fbranch
+                         and type I.fcmove = Instr.fcmove
+                         and type I.fload = Instr.fload
+                         and type I.foperate = Instr.foperate
+                         and type I.foperateV = Instr.foperateV
+                         and type I.fstore = Instr.fstore
+                         and type I.funary = Instr.funary
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.load = Instr.load
+                         and type I.operand = Instr.operand
+                         and type I.operate = Instr.operate
+                         and type I.operateV = Instr.operateV
+                         and type I.osf_user_palcode = Instr.osf_user_palcode
+                         and type I.pseudo_op = Instr.pseudo_op
+                         and type I.store = Instr.store
+   structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
   ) : SDI_JUMPS = 
 struct
   structure I = Instr
diff --git a/alpha/emit/alphaAsm.sml b/alpha/emit/alphaAsm.sml
index 293fe84..0cd9fca 100644
--- a/alpha/emit/alphaAsm.sml
+++ b/alpha/emit/alphaAsm.sml
@@ -6,12 +6,88 @@
 
 
 functor AlphaAsmEmitter(structure S : INSTRUCTION_STREAM
-                        structure Instr : ALPHAINSTR
-                           where T = S.P.T
-                        structure Shuffle : ALPHASHUFFLE
-                           where I = Instr
-                        structure MLTreeEval : MLTREE_EVAL
-                           where T = Instr.T
+                        structure Instr : ALPHAINSTR (* where T = S.P.T *)
+                                          where type T.Basis.cond = S.P.T.Basis.cond
+                                            and type T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+                                            and type T.Basis.ext = S.P.T.Basis.ext
+                                            and type T.Basis.fcond = S.P.T.Basis.fcond
+                                            and type T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+                                            and type T.Constant.const = S.P.T.Constant.const
+                                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+                                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+                                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+                                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+                                            and type T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+                                            and type T.Region.region = S.P.T.Region.region
+                                            and type T.ccexp = S.P.T.ccexp
+                                            and type T.fexp = S.P.T.fexp
+                                            (* and type T.labexp = S.P.T.labexp *)
+                                            and type T.mlrisc = S.P.T.mlrisc
+                                            and type T.oper = S.P.T.oper
+                                            and type T.rep = S.P.T.rep
+                                            and type T.rexp = S.P.T.rexp
+                                            and type T.stm = S.P.T.stm
+                        structure Shuffle : ALPHASHUFFLE (* where I = Instr *)
+                                            where type I.Constant.const = Instr.Constant.const
+                                              and type I.Region.region = Instr.Region.region
+                                              and type I.T.Basis.cond = Instr.T.Basis.cond
+                                              and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                              and type I.T.Basis.ext = Instr.T.Basis.ext
+                                              and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                              and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                              and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                              and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                              and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                              and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                              and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                              and type I.T.ccexp = Instr.T.ccexp
+                                              and type I.T.fexp = Instr.T.fexp
+                                              (* and type I.T.labexp = Instr.T.labexp *)
+                                              and type I.T.mlrisc = Instr.T.mlrisc
+                                              and type I.T.oper = Instr.T.oper
+                                              and type I.T.rep = Instr.T.rep
+                                              and type I.T.rexp = Instr.T.rexp
+                                              and type I.T.stm = Instr.T.stm
+                                              and type I.branch = Instr.branch
+                                              and type I.cmove = Instr.cmove
+                                              and type I.ea = Instr.ea
+                                              and type I.fbranch = Instr.fbranch
+                                              and type I.fcmove = Instr.fcmove
+                                              and type I.fload = Instr.fload
+                                              and type I.foperate = Instr.foperate
+                                              and type I.foperateV = Instr.foperateV
+                                              and type I.fstore = Instr.fstore
+                                              and type I.funary = Instr.funary
+                                              and type I.instr = Instr.instr
+                                              and type I.instruction = Instr.instruction
+                                              and type I.load = Instr.load
+                                              and type I.operand = Instr.operand
+                                              and type I.operate = Instr.operate
+                                              and type I.operateV = Instr.operateV
+                                              and type I.osf_user_palcode = Instr.osf_user_palcode
+                                              and type I.pseudo_op = Instr.pseudo_op
+                                              and type I.store = Instr.store
+                        structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                               where type T.Basis.cond = Instr.T.Basis.cond
+                                                 and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                                 and type T.Basis.ext = Instr.T.Basis.ext
+                                                 and type T.Basis.fcond = Instr.T.Basis.fcond
+                                                 and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                                 and type T.Constant.const = Instr.T.Constant.const
+                                                 and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                                 and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                                 and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                                 and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                                 and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                                 and type T.Region.region = Instr.T.Region.region
+                                                 and type T.ccexp = Instr.T.ccexp
+                                                 and type T.fexp = Instr.T.fexp
+                                                 (* and type T.labexp = Instr.T.labexp *)
+                                                 and type T.mlrisc = Instr.T.mlrisc
+                                                 and type T.oper = Instr.T.oper
+                                                 and type T.rep = Instr.T.rep
+                                                 and type T.rexp = Instr.T.rexp
+                                                 and type T.stm = Instr.T.stm
                        ) : INSTRUCTION_EMITTER =
 struct
    structure I  = Instr
diff --git a/alpha/emit/alphaMC.sml b/alpha/emit/alphaMC.sml
index 8548877..be61bb7 100644
--- a/alpha/emit/alphaMC.sml
+++ b/alpha/emit/alphaMC.sml
@@ -6,7 +6,27 @@
 
 
 functor AlphaMCEmitter(structure Instr : ALPHAINSTR
-                       structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+                       structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                              where type T.Basis.cond = Instr.T.Basis.cond
+                                                and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                                and type T.Basis.ext = Instr.T.Basis.ext
+                                                and type T.Basis.fcond = Instr.T.Basis.fcond
+                                                and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                                and type T.Constant.const = Instr.T.Constant.const
+                                                and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                                and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                                and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                                and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                                and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                                and type T.Region.region = Instr.T.Region.region
+                                                and type T.ccexp = Instr.T.ccexp
+                                                and type T.fexp = Instr.T.fexp
+                                                (* and type T.labexp = Instr.T.labexp *)
+                                                and type T.mlrisc = Instr.T.mlrisc
+                                                and type T.oper = Instr.T.oper
+                                                and type T.rep = Instr.T.rep
+                                                and type T.rexp = Instr.T.rexp
+                                                and type T.stm = Instr.T.stm
                        structure Stream : INSTRUCTION_STREAM 
                        structure CodeString : CODE_STRING
                       ) : INSTRUCTION_EMITTER =
@@ -47,6 +67,7 @@ struct
        (* note: fromLargeWord strips the high order bits! *)
        fun eByteW w =
        let val i = !loc
+           val w = W.toLargeWord w
        in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
    
        fun doNothing _ = ()
diff --git a/alpha/flowgraph/alphaGasPseudoOps.sml b/alpha/flowgraph/alphaGasPseudoOps.sml
index 5f6a34c..d715a2b 100644
--- a/alpha/flowgraph/alphaGasPseudoOps.sml
+++ b/alpha/flowgraph/alphaGasPseudoOps.sml
@@ -1,6 +1,26 @@
 functor AlphaGasPseudoOps 
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL  where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
     ) : PSEUDO_OPS_BASIS = 
 
 struct
diff --git a/alpha/instructions/alphaInstr.sml b/alpha/instructions/alphaInstr.sml
index e1ceb2b..216c8ae 100644
--- a/alpha/instructions/alphaInstr.sml
+++ b/alpha/instructions/alphaInstr.sml
@@ -8,7 +8,16 @@
 signature ALPHAINSTR =
 sig
    structure C : ALPHACELLS
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    structure T : MLTREE
    structure Constant: CONSTANT
    structure Region : REGION
diff --git a/alpha/instructions/alphaProps.sml b/alpha/instructions/alphaProps.sml
index 8b6771e..6c39fa7 100644
--- a/alpha/instructions/alphaProps.sml
+++ b/alpha/instructions/alphaProps.sml
@@ -6,8 +6,48 @@
 
 functor AlphaProps
    (structure Instr : ALPHAINSTR
-    structure MLTreeHash :  MLTREE_HASH where T = Instr.T
-    structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+    structure MLTreeHash : MLTREE_HASH (* where T = Instr.T *)
+                           where type T.Basis.cond = Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = Instr.T.Basis.ext
+                             and type T.Basis.fcond = Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                             and type T.Region.region = Instr.T.Region.region
+                             and type T.ccexp = Instr.T.ccexp
+                             and type T.fexp = Instr.T.fexp
+                             (* and type T.labexp = Instr.T.labexp *)
+                             and type T.mlrisc = Instr.T.mlrisc
+                             and type T.oper = Instr.T.oper
+                             and type T.rep = Instr.T.rep
+                             and type T.rexp = Instr.T.rexp
+                             and type T.stm = Instr.T.stm
+    structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                           where type T.Basis.cond = Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = Instr.T.Basis.ext
+                             and type T.Basis.fcond = Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                             and type T.Region.region = Instr.T.Region.region
+                             and type T.ccexp = Instr.T.ccexp
+                             and type T.fexp = Instr.T.fexp
+                             (* and type T.labexp = Instr.T.labexp *)
+                             and type T.mlrisc = Instr.T.mlrisc
+                             and type T.oper = Instr.T.oper
+                             and type T.rep = Instr.T.rep
+                             and type T.rexp = Instr.T.rexp
+                             and type T.stm = Instr.T.stm
     ):INSN_PROPERTIES =
 struct
     structure I = Instr
diff --git a/alpha/mltree/alpha.sml b/alpha/mltree/alpha.sml
index c7b22a3..6ffe6e8 100644
--- a/alpha/mltree/alpha.sml
+++ b/alpha/mltree/alpha.sml
@@ -11,11 +11,72 @@
 
 functor Alpha
    (structure AlphaInstr : ALPHAINSTR 
-    structure PseudoInstrs : ALPHA_PSEUDO_INSTR
-    			where I = AlphaInstr
-    structure ExtensionComp : MLTREE_EXTENSION_COMP
-    			where I = AlphaInstr
-			  and T = AlphaInstr.T
+    structure PseudoInstrs : ALPHA_PSEUDO_INSTR (* where I = AlphaInstr *)
+                             where type I.Constant.const = AlphaInstr.Constant.const
+                               and type I.Region.region = AlphaInstr.Region.region
+                               and type I.T.Basis.cond = AlphaInstr.T.Basis.cond
+                               and type I.T.Basis.div_rounding_mode = AlphaInstr.T.Basis.div_rounding_mode
+                               and type I.T.Basis.ext = AlphaInstr.T.Basis.ext
+                               and type I.T.Basis.fcond = AlphaInstr.T.Basis.fcond
+                               and type I.T.Basis.rounding_mode = AlphaInstr.T.Basis.rounding_mode
+                               and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) AlphaInstr.T.Extension.ccx
+                               and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) AlphaInstr.T.Extension.fx
+                               and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) AlphaInstr.T.Extension.rx
+                               and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) AlphaInstr.T.Extension.sx
+                               and type I.T.I.div_rounding_mode = AlphaInstr.T.I.div_rounding_mode
+                               and type I.T.ccexp = AlphaInstr.T.ccexp
+                               and type I.T.fexp = AlphaInstr.T.fexp
+                               (* and type I.T.labexp = AlphaInstr.T.labexp *)
+                               and type I.T.mlrisc = AlphaInstr.T.mlrisc
+                               and type I.T.oper = AlphaInstr.T.oper
+                               and type I.T.rep = AlphaInstr.T.rep
+                               and type I.T.rexp = AlphaInstr.T.rexp
+                               and type I.T.stm = AlphaInstr.T.stm
+                               and type I.branch = AlphaInstr.branch
+                               and type I.cmove = AlphaInstr.cmove
+                               and type I.ea = AlphaInstr.ea
+                               and type I.fbranch = AlphaInstr.fbranch
+                               and type I.fcmove = AlphaInstr.fcmove
+                               and type I.fload = AlphaInstr.fload
+                               and type I.foperate = AlphaInstr.foperate
+                               and type I.foperateV = AlphaInstr.foperateV
+                               and type I.fstore = AlphaInstr.fstore
+                               and type I.funary = AlphaInstr.funary
+                               and type I.instr = AlphaInstr.instr
+                               and type I.instruction = AlphaInstr.instruction
+                               and type I.load = AlphaInstr.load
+                               and type I.operand = AlphaInstr.operand
+                               and type I.operate = AlphaInstr.operate
+                               and type I.operateV = AlphaInstr.operateV
+                               and type I.osf_user_palcode = AlphaInstr.osf_user_palcode
+                               and type I.pseudo_op = AlphaInstr.pseudo_op
+                               and type I.store = AlphaInstr.store
+    structure ExtensionComp : MLTREE_EXTENSION_COMP (* where I = AlphaInstr and T = AlphaInstr.T *)
+                              where type I.addressing_mode = AlphaInstr.addressing_mode
+                                and type I.ea = AlphaInstr.ea
+                                and type I.instr = AlphaInstr.instr
+                                and type I.instruction = AlphaInstr.instruction
+                                and type I.operand = AlphaInstr.operand
+                              where type T.Basis.cond = AlphaInstr.T.Basis.cond
+                                and type T.Basis.div_rounding_mode = AlphaInstr.T.Basis.div_rounding_mode
+                                and type T.Basis.ext = AlphaInstr.T.Basis.ext
+                                and type T.Basis.fcond = AlphaInstr.T.Basis.fcond
+                                and type T.Basis.rounding_mode = AlphaInstr.T.Basis.rounding_mode
+                                and type T.Constant.const = AlphaInstr.T.Constant.const
+                                and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) AlphaInstr.T.Extension.ccx
+                                and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) AlphaInstr.T.Extension.fx
+                                and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) AlphaInstr.T.Extension.rx
+                                and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) AlphaInstr.T.Extension.sx
+                                and type T.I.div_rounding_mode = AlphaInstr.T.I.div_rounding_mode
+                                and type T.Region.region = AlphaInstr.T.Region.region
+                                and type T.ccexp = AlphaInstr.T.ccexp
+                                and type T.fexp = AlphaInstr.T.fexp
+                                (* and type T.labexp = AlphaInstr.T.labexp *)
+                                and type T.mlrisc = AlphaInstr.T.mlrisc
+                                and type T.oper = AlphaInstr.T.oper
+                                and type T.rep = AlphaInstr.T.rep
+                                and type T.rexp = AlphaInstr.T.rexp
+                                and type T.stm = AlphaInstr.T.stm
 
       (* Cost of multiplication in cycles *)
     val multCost : int ref
@@ -215,7 +276,9 @@ struct
    * Specialize the modules for multiplication/division 
    * by constant optimizations.
    *)
-  functor Multiply32 = MLTreeMult
+
+  (* signed, trapping version of multiply and divide *)
+  structure Mult32 = MLTreeMult
     (structure I = I
      structure T = T
      structure CB = CellsBasis
@@ -256,40 +319,115 @@ struct
          in  [I.operate{oper=I.ADDL,ra=r,rb=zeroOpn,rc=tmp},
               I.operate{oper=I.SRA,ra=tmp,rb=I.IMMop i,rc=d}]
          end 
-    )
 
-  functor Multiply64 = MLTreeMult
-    (structure I = I
-     structure T = T
-     structure CB = CellsBasis
-   
-     val intTy = 64
-
-     type arg  = {r1:CB.cell, r2:CB.cell, d:CB.cell}
-     type argi = {r:CB.cell, i:int, d:CB.cell}
-
-     fun mov{r,d}    = I.COPY{k=CB.GP, sz=intTy, dst=[d],src=[r],tmp=NONE}
-     fun add{r1,r2,d}= I.operate{oper=I.ADDQ,ra=r1,rb=I.REGop r2,rc=d}
-     fun slli{r,i,d} = [I.operate{oper=I.SLL,ra=r,rb=I.IMMop i,rc=d}]
-     fun srli{r,i,d} = [I.operate{oper=I.SRL,ra=r,rb=I.IMMop i,rc=d}]
-     fun srai{r,i,d} = [I.operate{oper=I.SRA,ra=r,rb=I.IMMop i,rc=d}]
-    )
-
-  (* signed, trapping version of multiply and divide *)
-  structure Mult32 = Multiply32
-    (val trapping = true
+     val trapping = true
      val multCost = multCost
      fun addv{r1,r2,d} = [I.operatev{oper=I.ADDLV,ra=r1,rb=I.REGop r2,rc=d}]
      fun subv{r1,r2,d} = [I.operatev{oper=I.SUBLV,ra=r1,rb=I.REGop r2,rc=d}]
      val sh1addv = NONE
      val sh2addv = NONE
      val sh3addv = NONE
-    )
-    (val signed = true)
 
-  (* non-trapping version of multiply and divide *)
-  functor Mul32 = Multiply32
-    (val trapping = false
+     val signed = true)
+
+  (* unsigned, non-trapping version of multiply and divide *)
+  structure Mulu32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+   
+     val intTy = 32
+
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d}    = I.COPY{k=CB.GP, sz=intTy, dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.operate{oper=I.ADDL,ra=r1,rb=I.REGop r2,rc=d}
+     (*
+      * How to left shift by a constant (32bits)
+      *)
+     fun slli{r,i=1,d} = [I.operate{oper=I.ADDL,ra=r,rb=I.REGop r,rc=d}]
+       | slli{r,i=2,d} = [I.operate{oper=I.S4ADDL,ra=r,rb=zeroOpn,rc=d}]
+       | slli{r,i=3,d} = [I.operate{oper=I.S8ADDL,ra=r,rb=zeroOpn,rc=d}]
+       | slli{r,i,d}   =
+          let val tmp = C.newReg()
+          in  [I.operate{oper=I.SLL,ra=r,rb=I.IMMop i,rc=tmp},
+               I.operate{oper=I.ADDL,ra=tmp,rb=zeroOpn,rc=d}]
+          end
+
+     (*
+      * How to right shift (unsigned) by a constant (32bits)
+      *)
+     fun srli{r,i,d} =
+         let val tmp = C.newReg()
+         in  [I.operate{oper=I.ZAP,ra=r,rb=I.IMMop 0xf0,rc=tmp},
+              I.operate{oper=I.SRL,ra=tmp,rb=I.IMMop i,rc=d}]
+         end
+
+     (*
+      * How to right shift (signed) by a constant (32bits)
+      *)
+     fun srai{r,i,d} =
+         let val tmp = C.newReg()
+         in  [I.operate{oper=I.ADDL,ra=r,rb=zeroOpn,rc=tmp},
+              I.operate{oper=I.SRA,ra=tmp,rb=I.IMMop i,rc=d}]
+         end
+
+     val trapping = false
+     val multCost = multCost
+     fun addv{r1,r2,d} = [I.operate{oper=I.ADDL,ra=r1,rb=I.REGop r2,rc=d}]
+     fun subv{r1,r2,d} = [I.operate{oper=I.SUBL,ra=r1,rb=I.REGop r2,rc=d}]
+     val sh1addv = NONE
+     val sh2addv = SOME(fn {r1,r2,d} =>
+                    [I.operate{oper=I.S4ADDL,ra=r1,rb=I.REGop r2,rc=d}])
+     val sh3addv = SOME(fn {r1,r2,d} =>
+                    [I.operate{oper=I.S8ADDL,ra=r1,rb=I.REGop r2,rc=d}])
+
+     val signed = false)
+  (* signed, non-trapping version of multiply and divide *)
+  structure Muls32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+
+     val intTy = 32
+
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d}    = I.COPY{k=CB.GP, sz=intTy, dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.operate{oper=I.ADDL,ra=r1,rb=I.REGop r2,rc=d}
+     (*
+      * How to left shift by a constant (32bits)
+      *)
+     fun slli{r,i=1,d} = [I.operate{oper=I.ADDL,ra=r,rb=I.REGop r,rc=d}]
+       | slli{r,i=2,d} = [I.operate{oper=I.S4ADDL,ra=r,rb=zeroOpn,rc=d}]
+       | slli{r,i=3,d} = [I.operate{oper=I.S8ADDL,ra=r,rb=zeroOpn,rc=d}]
+       | slli{r,i,d}   =
+          let val tmp = C.newReg()
+          in  [I.operate{oper=I.SLL,ra=r,rb=I.IMMop i,rc=tmp},
+               I.operate{oper=I.ADDL,ra=tmp,rb=zeroOpn,rc=d}]
+          end
+
+     (*
+      * How to right shift (unsigned) by a constant (32bits)
+      *)
+     fun srli{r,i,d} =
+         let val tmp = C.newReg()
+         in  [I.operate{oper=I.ZAP,ra=r,rb=I.IMMop 0xf0,rc=tmp},
+              I.operate{oper=I.SRL,ra=tmp,rb=I.IMMop i,rc=d}]
+         end
+
+     (*
+      * How to right shift (signed) by a constant (32bits)
+      *)
+     fun srai{r,i,d} =
+         let val tmp = C.newReg()
+         in  [I.operate{oper=I.ADDL,ra=r,rb=zeroOpn,rc=tmp},
+              I.operate{oper=I.SRA,ra=tmp,rb=I.IMMop i,rc=d}]
+         end
+
+     val trapping = false
      val multCost = multCost
      fun addv{r1,r2,d} = [I.operate{oper=I.ADDL,ra=r1,rb=I.REGop r2,rc=d}]
      fun subv{r1,r2,d} = [I.operate{oper=I.SUBL,ra=r1,rb=I.REGop r2,rc=d}]
@@ -298,25 +436,82 @@ struct
                     [I.operate{oper=I.S4ADDL,ra=r1,rb=I.REGop r2,rc=d}])
      val sh3addv = SOME(fn {r1,r2,d} => 
                     [I.operate{oper=I.S8ADDL,ra=r1,rb=I.REGop r2,rc=d}])
-    )
-  structure Mulu32 = Mul32(val signed = false)
-  structure Muls32 = Mul32(val signed = true)
+
+     val signed = true)
 
   (* signed, trapping version of multiply and divide *)
-  structure Mult64 = Multiply64
-    (val trapping = true
+  structure Mult64 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+
+     val intTy = 64
+
+     type arg  = {r1:CB.cell, r2:CB.cell, d:CB.cell}
+     type argi = {r:CB.cell, i:int, d:CB.cell}
+
+     fun mov{r,d}    = I.COPY{k=CB.GP, sz=intTy, dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d}= I.operate{oper=I.ADDQ,ra=r1,rb=I.REGop r2,rc=d}
+     fun slli{r,i,d} = [I.operate{oper=I.SLL,ra=r,rb=I.IMMop i,rc=d}]
+     fun srli{r,i,d} = [I.operate{oper=I.SRL,ra=r,rb=I.IMMop i,rc=d}]
+     fun srai{r,i,d} = [I.operate{oper=I.SRA,ra=r,rb=I.IMMop i,rc=d}]
+
+     val trapping = true
      val multCost = multCost
      fun addv{r1,r2,d} = [I.operatev{oper=I.ADDQV,ra=r1,rb=I.REGop r2,rc=d}]
      fun subv{r1,r2,d} = [I.operatev{oper=I.SUBQV,ra=r1,rb=I.REGop r2,rc=d}]
      val sh1addv = NONE
      val sh2addv = NONE
      val sh3addv = NONE
-    )
-    (val signed = true)
+
+     val signed = true)
 
   (* unsigned, non-trapping version of multiply and divide *)
-  functor Mul64 = Multiply64
-    (val trapping = false
+  structure Mulu64 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+
+     val intTy = 64
+
+     type arg  = {r1:CB.cell, r2:CB.cell, d:CB.cell}
+     type argi = {r:CB.cell, i:int, d:CB.cell}
+
+     fun mov{r,d}    = I.COPY{k=CB.GP, sz=intTy, dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d}= I.operate{oper=I.ADDQ,ra=r1,rb=I.REGop r2,rc=d}
+     fun slli{r,i,d} = [I.operate{oper=I.SLL,ra=r,rb=I.IMMop i,rc=d}]
+     fun srli{r,i,d} = [I.operate{oper=I.SRL,ra=r,rb=I.IMMop i,rc=d}]
+     fun srai{r,i,d} = [I.operate{oper=I.SRA,ra=r,rb=I.IMMop i,rc=d}]
+
+     val trapping = false
+     val multCost = multCost
+     fun addv{r1,r2,d} = [I.operate{oper=I.ADDQ,ra=r1,rb=I.REGop r2,rc=d}]
+     fun subv{r1,r2,d} = [I.operate{oper=I.SUBQ,ra=r1,rb=I.REGop r2,rc=d}]
+     val sh1addv = NONE
+     val sh2addv = SOME(fn {r1,r2,d} =>
+                    [I.operate{oper=I.S4ADDQ,ra=r1,rb=I.REGop r2,rc=d}])
+     val sh3addv = SOME(fn {r1,r2,d} =>
+                    [I.operate{oper=I.S8ADDQ,ra=r1,rb=I.REGop r2,rc=d}])
+
+     val signed = false)
+  (* signed, non-trapping version of multiply and divide *)
+  structure Muls64 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+
+     val intTy = 64
+
+     type arg  = {r1:CB.cell, r2:CB.cell, d:CB.cell}
+     type argi = {r:CB.cell, i:int, d:CB.cell}
+
+     fun mov{r,d}    = I.COPY{k=CB.GP, sz=intTy, dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d}= I.operate{oper=I.ADDQ,ra=r1,rb=I.REGop r2,rc=d}
+     fun slli{r,i,d} = [I.operate{oper=I.SLL,ra=r,rb=I.IMMop i,rc=d}]
+     fun srli{r,i,d} = [I.operate{oper=I.SRL,ra=r,rb=I.IMMop i,rc=d}]
+     fun srai{r,i,d} = [I.operate{oper=I.SRA,ra=r,rb=I.IMMop i,rc=d}]
+
+     val trapping = false
      val multCost = multCost
      fun addv{r1,r2,d} = [I.operate{oper=I.ADDQ,ra=r1,rb=I.REGop r2,rc=d}]
      fun subv{r1,r2,d} = [I.operate{oper=I.SUBQ,ra=r1,rb=I.REGop r2,rc=d}]
@@ -325,9 +520,8 @@ struct
                     [I.operate{oper=I.S4ADDQ,ra=r1,rb=I.REGop r2,rc=d}])
      val sh3addv = SOME(fn {r1,r2,d} => 
                     [I.operate{oper=I.S8ADDQ,ra=r1,rb=I.REGop r2,rc=d}])
-    )
-  structure Mulu64 = Mul64(val signed = false)
-  structure Muls64 = Mul64(val signed = true)
+
+     val signed = true)
 
   (* 
    * The main stuff
@@ -971,10 +1165,10 @@ struct
              *)
           | T.ADD(64,e,T.LABEXP le) => mark(I.LDA{r=d,b=expr e,d=I.LABop le},an)
           | T.ADD(64,T.LABEXP le,e) => mark(I.LDA{r=d,b=expr e,d=I.LABop le},an)
-          | T.ADD(64,e,x as (T.CONST _ | T.LABEL _))  => 
-               mark(I.LDA{r=d,b=expr e,d=I.LABop x},an)
-          | T.ADD(64,x as (T.CONST _ | T.LABEL _),e)  => 
-               mark(I.LDA{r=d,b=expr e,d=I.LABop x},an)
+          | T.ADD(64,e,x as T.CONST _) => mark(I.LDA{r=d,b=expr e,d=I.LABop x},an)
+          | T.ADD(64,e,x as T.LABEL _) => mark(I.LDA{r=d,b=expr e,d=I.LABop x},an)
+          | T.ADD(64,x as T.CONST _,e) => mark(I.LDA{r=d,b=expr e,d=I.LABop x},an)
+          | T.ADD(64,x as T.LABEL _,e) => mark(I.LDA{r=d,b=expr e,d=I.LABop x},an)
           | T.ADD(64,e,T.LI i)     => loadImmed(i, expr e, d, an)
           | T.ADD(64,T.LI i,e)     => loadImmed(i, expr e, d, an)
 	  | T.SUB(sz, a, b as T.LI z)    =>
@@ -1067,8 +1261,13 @@ struct
           | T.SX(_,_,T.LOAD(8,ea,mem)) => load8s(ea,d,mem,an)
           | T.SX(_,_,T.LOAD(16,ea,mem))=> load16s(ea,d,mem,an)
           | T.SX(_,_,T.LOAD(32,ea,mem))=> load32s(ea,d,mem,an)
-          | T.ZX((8|16|32|64),_,T.LOAD(8,ea,mem)) => load8(ea,d,mem,an)
-          | T.ZX((16|32|64),_,T.LOAD(16,ea,mem))=> load16(ea,d,mem,an)
+          | T.ZX(8,_,T.LOAD(8,ea,mem)) => load8(ea,d,mem,an)
+          | T.ZX(16,_,T.LOAD(8,ea,mem)) => load8(ea,d,mem,an)
+          | T.ZX(32,_,T.LOAD(8,ea,mem)) => load8(ea,d,mem,an)
+          | T.ZX(64,_,T.LOAD(8,ea,mem)) => load8(ea,d,mem,an)
+          | T.ZX(16,_,T.LOAD(16,ea,mem))=> load16(ea,d,mem,an)
+          | T.ZX(32,_,T.LOAD(16,ea,mem))=> load16(ea,d,mem,an)
+          | T.ZX(64,_,T.LOAD(16,ea,mem))=> load16(ea,d,mem,an)
           | T.ZX(64,_,T.LOAD(64,ea,mem)) => load(I.LDQ,ea,d,mem,an)
           | T.LOAD(8,ea,mem) => load8(ea,d,mem,an)
           | T.LOAD(16,ea,mem) => load16(ea,d,mem,an)
@@ -1391,8 +1590,10 @@ struct
               val (cond,a,b) = 
                 (* move the immed operand to b *)
                 case a of
-                  (T.LI _ | T.CONST _ | T.LABEL _ | T.LABEXP _) => 
-                    (T.Basis.swapCond cond,b,a)
+                  T.LI _ => (T.Basis.swapCond cond,b,a)
+                | T.CONST _ => (T.Basis.swapCond cond,b,a)
+                | T.LABEL _ => (T.Basis.swapCond cond,b,a)
+                | T.LABEXP _ => (T.Basis.swapCond cond,b,a)
                 | _ => (cond,a,b)
 
               fun sub(a, T.LI z) = 
@@ -1455,8 +1656,10 @@ struct
                   end
               val (cond,e1,e2) =
 		  case e1 of
-                    (T.LI _ | T.CONST _ | T.LABEL _ | T.LABEXP _) => 
-                       (T.Basis.swapCond cond,e2,e1)
+                    T.LI _ => (T.Basis.swapCond cond,e2,e1)
+                  | T.CONST _ => (T.Basis.swapCond cond,e2,e1)
+                  | T.LABEL _ => (T.Basis.swapCond cond,e2,e1)
+                  | T.LABEXP _ => (T.Basis.swapCond cond,e2,e1)
                   | _ => (cond,e1,e2)
           in  case cond of
                 T.EQ  => eq(e1,e2,d)
diff --git a/alpha/mltree/alphaPseudoInstr.sig b/alpha/mltree/alphaPseudoInstr.sig
index a22feeb..f9c584e 100644
--- a/alpha/mltree/alphaPseudoInstr.sig
+++ b/alpha/mltree/alphaPseudoInstr.sig
@@ -4,10 +4,39 @@ signature ALPHA_PSEUDO_INSTR =
 sig
    structure I : ALPHAINSTR
    structure T : MLTREE
+                 where type Basis.cond = I.T.Basis.cond
+                   and type Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                   and type Basis.ext = I.T.Basis.ext
+                   and type Basis.fcond = I.T.Basis.fcond
+                   and type Basis.rounding_mode = I.T.Basis.rounding_mode
+                   and type Constant.const = I.T.Constant.const
+                   and type ('s,'r,'f,'c) Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                   and type ('s,'r,'f,'c) Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                   and type ('s,'r,'f,'c) Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                   and type ('s,'r,'f,'c) Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                   and type I.div_rounding_mode = I.T.I.div_rounding_mode
+                   and type Region.region = I.T.Region.region
+                   and type ccexp = I.T.ccexp
+                   and type fexp = I.T.fexp
+                   (* and type labexp = I.T.labexp *)
+                   and type mlrisc = I.T.mlrisc
+                   and type oper = I.T.oper
+                   and type rep = I.T.rep
+                   and type rexp = I.T.rexp
+                   and type stm = I.T.stm
    structure C : ALPHACELLS
-     sharing C = I.C
-     sharing I.T = T
-   structure CB: CELLS_BASIS = CellsBasis
+     (* sharing C = I.C *)
+     (* sharing I.T = T *)
+   structure CB: CELLS_BASIS (* = CellsBasis *)
+                 where type CellSet.cellset = CellsBasis.CellSet.cellset
+                   and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                   and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                   and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                   and type cell = CellsBasis.cell
+                   and type cellColor = CellsBasis.cellColor
+                   and type cellkind = CellsBasis.cellkind
+                   and type cellkindDesc = CellsBasis.cellkindDesc
+                   and type cellkindInfo = CellsBasis.cellkindInfo
   
    type reduceOpnd = I.operand -> CB.cell
 
diff --git a/amd64/amd64.mdl b/amd64/amd64.mdl
index 15e331b..321894b 100644
--- a/amd64/amd64.mdl
+++ b/amd64/amd64.mdl
@@ -577,7 +577,8 @@ architecture AMD64 =
       fun chop fbinOp =
           let val n = size fbinOp
           in  case Char.toLower(String.sub(fbinOp,n-1)) of
-                (#"s" | #"l") => String.substring(fbinOp,0,n-1)
+                (#"s") => String.substring(fbinOp,0,n-1)
+              | (#"l") => String.substring(fbinOp,0,n-1)
               | _ => fbinOp
           end
 
@@ -709,10 +710,29 @@ architecture AMD64 =
     | BINARY of {binOp:binaryOp, src:operand, dst:operand}
 	asm: (case (src,binOp) of
                (I.Direct _,  (* tricky business here for shifts *)
-               (I.SARQ | I.SHRQ | I.SHLQ |
-		I.SARL | I.SHRL | I.SHLL |
-                I.SARW | I.SHRW | I.SHLW |
-                I.SARB | I.SHRB | I.SHLB)) => ``<binOp>\t%cl, <dst>''
+                I.SARQ) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRQ) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLQ) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SARL) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRL) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLL) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SARW) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRW) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLW) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SARB) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRB) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLB) => ``<binOp>\t%cl, <dst>''
              | _ => ``<binOp>\t<src>, <dst>''
              )
 	(*rtl: ``<binOp>''*)
diff --git a/amd64/amd64MC.sml b/amd64/amd64MC.sml
index 35efcdb..e4536a3 100644
--- a/amd64/amd64MC.sml
+++ b/amd64/amd64MC.sml
@@ -1,8 +1,69 @@
 functor AMD64MCEmitter
   (structure Instr : AMD64INSTR
-   structure Shuffle : AMD64SHUFFLE where I = Instr
-   structure MLTreeEval : MLTREE_EVAL where T = Instr.T
-   structure AsmEmitter : INSTRUCTION_EMITTER where I = Instr) : MC_EMIT = 
+   structure Shuffle : AMD64SHUFFLE (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         (* and type I.addressing_mode = Instr.addressing_mode *)
+                         and type I.binaryOp = Instr.binaryOp
+                         and type I.bitOp = Instr.bitOp
+                         and type I.cond = Instr.cond
+                         and type I.fbin_op = Instr.fbin_op
+                         and type I.fcom_op = Instr.fcom_op
+                         and type I.fmove_op = Instr.fmove_op
+                         and type I.fsize = Instr.fsize
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.isize = Instr.isize
+                         and type I.move = Instr.move
+                         and type I.multDivOp = Instr.multDivOp
+                         and type I.operand = Instr.operand
+                         and type I.shiftOp = Instr.shiftOp
+                         and type I.unaryOp = Instr.unaryOp
+   structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
+   structure AsmEmitter : INSTRUCTION_EMITTER (* where I = Instr *)
+                          where type I.addressing_mode = Instr.addressing_mode
+                            and type I.ea = Instr.ea
+                            and type I.instr = Instr.instr
+                            and type I.instruction = Instr.instruction
+                            and type I.operand = Instr.operand) : MC_EMIT =
 struct
   structure I = Instr
   structure C = I.C
@@ -421,7 +482,21 @@ struct
 		     | I.SHLQ => shift(64, 4, src)
 		     | I.SARQ => shift(64, 7, src)
 		     | I.SHRQ => shift(64, 5, src)
-		     | (I.IMULL | I.MULQ) => 
+		     | (I.IMULL) =>
+		       let val sz = if binOp = I.MULQ then 64 else 32
+		       in (case (src, dst)
+			    of (I.Immed(i), I.Direct (_, dstR)) =>
+			       (case size i
+				 of Bits32 =>
+				    encodeLongImm sz (0wx69, reg (rNum dstR), dst, i)
+				  | _ => encodeByteImm sz (0wx6b, reg (rNum dstR), dst, i)
+			       (* esac *))
+			     | (_, I.Direct (_, dstR)) =>
+			       eBytes (encode32' ([0wx0f, 0wxaf], reg (rNum dstR), src))
+			     | _ => error "imul"
+			  (* esac *))
+		       end
+		     | (I.MULQ) =>
 		       let val sz = if binOp = I.MULQ then 64 else 32
 		       in (case (src, dst) 
 			    of (I.Immed(i), I.Direct (_, dstR)) =>
@@ -475,19 +550,34 @@ struct
 	     | I.INTO => eByte(0xcd+4)
 	     | I.CDQ => (* eByte(0x99) *) (* XXX this is CQO *) eBytes [0wx48, 0wx99]
 	     | I.SAHF => eByte(0x9e)
-	     | ( I.PUSHL (I.Immed i) | I.PUSHQ (I.Immed i) )=> 
+	     | ( I.PUSHL (I.Immed i) )=>
 	       (case size i 
 		 of Bits32 => eBytes(0wx68 :: eLong(i))
 		  | _ => eBytes [0wx6a, toWord8 i]
 	       (* esac *))
-	     | ( I.PUSHL (I.Direct (_, r)) |
-		 I.PUSHQ (I.Direct (_, r)) ) => eByte (0x50+rNum r)
-	     | ( I.PUSHL opnd | I.PUSHQ opnd ) => encode32 (0wxff, opcode 6, opnd)
+	     | ( I.PUSHQ (I.Immed i) )=>
+	       (case size i
+		 of Bits32 => eBytes(0wx68 :: eLong(i))
+		  | _ => eBytes [0wx6a, toWord8 i]
+	       (* esac *))
+	     | ( I.PUSHL (I.Direct (_, r)) ) => eByte (0x50+rNum r)
+	     | ( I.PUSHQ (I.Direct (_, r)) ) => eByte (0x50+rNum r)
+	     | ( I.PUSHL opnd ) => encode32 (0wxff, opcode 6, opnd)
+	     | ( I.PUSHQ opnd ) => encode32 (0wxff, opcode 6, opnd)
 	     | I.POP (I.Direct (_, r)) => eByte (0x58+rNum r)
 	     | I.POP opnd => encode32 (0wx8f, opcode 0, opnd)		     
 	     | I.LEAL{r32, addr} => encodeReg32(0wx8d, r32, addr)			  
 	     | I.LEAQ{r64, addr} => encodeReg64(0wx8d, r64, addr)			  
-	     | I.MOVE{mvOp=mvOp as (I.MOVL | I.MOVQ), src, dst} => 
+	     | I.MOVE{mvOp=mvOp as (I.MOVL), src, dst} =>
+	       let val sz = case mvOp of I.MOVL => 32 | I.MOVQ => 64
+		   fun mv(I.Immed(i), I.Direct (_, r)) =
+                       eBytes(Word8.+(0wxb8, Word8.fromInt(rNum r))::eLong(i))
+		     | mv(I.Immed(i), _) = encodeLongImm sz (0wxc7, opcode 0, dst, i)
+		     | mv(I.ImmedLabel le,dst) = mv(I.Immed(lexp le),dst)
+		     | mv(I.LabelEA le,dst) = error "MOVL: LabelEA"
+		     | mv(src,dst) = arith(sz, 0wx88, opcode 0) (src, dst)
+	       in  mv(src,dst) end
+	     | I.MOVE{mvOp=mvOp as (I.MOVQ), src, dst} =>
 	       let val sz = case mvOp of I.MOVL => 32 | I.MOVQ => 64
 		   fun mv(I.Immed(i), I.Direct (_, r)) =
                    (case sz
@@ -625,7 +715,8 @@ struct
 	     | I.CALL{opnd, ...} => encode32 (0wxff, opcode 2, opnd)
 	     | I.CMPL{lsrc, rsrc} => arith(32, 0wx38, opcode 7) (rsrc, lsrc)
 	     | I.CMPQ{lsrc, rsrc} => arith(64, 0wx38, opcode 7) (rsrc, lsrc)
-	     | (I.CMPW _ | I.CMPB _) => error "CMP"
+	     | (I.CMPW _) => error "CMP"
+	     | (I.CMPB _) => error "CMP"
 	     | I.TESTQ{lsrc, rsrc} => test(64, rsrc, lsrc)
 	     | I.TESTL{lsrc, rsrc} => test(32, rsrc, lsrc)
 	     | I.TESTB{lsrc, rsrc} => test(8, rsrc, lsrc)
diff --git a/amd64/amd64MCFn.sml b/amd64/amd64MCFn.sml
index 4499744..a8ba3a2 100644
--- a/amd64/amd64MCFn.sml
+++ b/amd64/amd64MCFn.sml
@@ -5,8 +5,61 @@
 
 functor AMD64MCFn(
     structure Instr : AMD64INSTR
-    structure Shuffle : AMD64SHUFFLE where I = Instr
-    structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+    structure Shuffle : AMD64SHUFFLE (* where I = Instr *)
+                        where type I.Constant.const = Instr.Constant.const
+                          and type I.Region.region = Instr.Region.region
+                          and type I.T.Basis.cond = Instr.T.Basis.cond
+                          and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                          and type I.T.Basis.ext = Instr.T.Basis.ext
+                          and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                          and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                          and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                          and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                          and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                          and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                          and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                          and type I.T.ccexp = Instr.T.ccexp
+                          and type I.T.fexp = Instr.T.fexp
+                          (* and type I.T.labexp = Instr.T.labexp *)
+                          and type I.T.mlrisc = Instr.T.mlrisc
+                          and type I.T.oper = Instr.T.oper
+                          and type I.T.rep = Instr.T.rep
+                          and type I.T.rexp = Instr.T.rexp
+                          and type I.T.stm = Instr.T.stm
+                          (* and type I.addressing_mode = Instr.addressing_mode *)
+                          and type I.binaryOp = Instr.binaryOp
+                          and type I.bitOp = Instr.bitOp
+                          and type I.cond = Instr.cond
+                          and type I.fsize = Instr.fsize
+                          and type I.instr = Instr.instr
+                          and type I.instruction = Instr.instruction
+                          and type I.isize = Instr.isize
+                          and type I.move = Instr.move
+                          and type I.multDivOp = Instr.multDivOp
+                          and type I.operand = Instr.operand
+                          and type I.shiftOp = Instr.shiftOp
+                          and type I.unaryOp = Instr.unaryOp
+    structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                           where type T.Basis.cond = Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = Instr.T.Basis.ext
+                             and type T.Basis.fcond = Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                             and type T.Region.region = Instr.T.Region.region
+                             and type T.ccexp = Instr.T.ccexp
+                             and type T.fexp = Instr.T.fexp
+                             (* and type T.labexp = Instr.T.labexp *)
+                             and type T.mlrisc = Instr.T.mlrisc
+                             and type T.oper = Instr.T.oper
+                             and type T.rep = Instr.T.rep
+                             and type T.rexp = Instr.T.rexp
+                             and type T.stm = Instr.T.stm
 (*    structure AsmEmitter : INSTRUCTION_EMITTER where I = Instr*)
   ) : MC_EMIT = 
   struct
diff --git a/amd64/backpatch/amd64Jumps.sml b/amd64/backpatch/amd64Jumps.sml
index 539bf54..16ee3a7 100644
--- a/amd64/backpatch/amd64Jumps.sml
+++ b/amd64/backpatch/amd64Jumps.sml
@@ -5,9 +5,71 @@
 
 functor AMD64Jumps
   (structure Instr : AMD64INSTR
-   structure Eval : MLTREE_EVAL where T = Instr.T
-   structure Shuffle : AMD64SHUFFLE where I = Instr
-   structure MCEmitter : MC_EMIT where I = Instr) : SDI_JUMPS = 
+   structure Eval : MLTREE_EVAL (* where T = Instr.T *)
+                    where type T.Basis.cond = Instr.T.Basis.cond
+                      and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                      and type T.Basis.ext = Instr.T.Basis.ext
+                      and type T.Basis.fcond = Instr.T.Basis.fcond
+                      and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                      and type T.Constant.const = Instr.T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                      and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                      and type T.Region.region = Instr.T.Region.region
+                      and type T.ccexp = Instr.T.ccexp
+                      and type T.fexp = Instr.T.fexp
+                      (* and type T.labexp = Instr.T.labexp *)
+                      and type T.mlrisc = Instr.T.mlrisc
+                      and type T.oper = Instr.T.oper
+                      and type T.rep = Instr.T.rep
+                      and type T.rexp = Instr.T.rexp
+                      and type T.stm = Instr.T.stm
+   structure Shuffle : AMD64SHUFFLE (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         (* and type I.addressing_mode = Instr.addressing_mode *)
+                         and type I.binaryOp = Instr.binaryOp
+                         and type I.bitOp = Instr.bitOp
+                         and type I.cond = Instr.cond
+                         and type I.fbin_op = Instr.fbin_op
+                         and type I.fcom_op = Instr.fcom_op
+                         and type I.fmove_op = Instr.fmove_op
+                         and type I.fsize = Instr.fsize
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.isize = Instr.isize
+                         and type I.move = Instr.move
+                         and type I.multDivOp = Instr.multDivOp
+                         and type I.operand = Instr.operand
+                         and type I.shiftOp = Instr.shiftOp
+                         and type I.unaryOp = Instr.unaryOp
+   structure MCEmitter : MC_EMIT (* where I = Instr *)
+                         where type I.addressing_mode = Instr.addressing_mode
+                           and type I.ea = Instr.ea
+                           and type I.instr = Instr.instr
+                           and type I.instruction = Instr.instruction
+                           and type I.operand = Instr.operand
+  ) : SDI_JUMPS =
 struct
   structure I = Instr
   structure C = I.C
@@ -40,15 +102,24 @@ struct
 	   | I.MOVE{src, dst, ...} => operand src orelse operand dst
 	   | I.LEAL{addr, ...} => operand addr
 	   | I.LEAQ{addr, ...} => operand addr
-	   | ( I.CMPQ arg | I.CMPL arg | I.CMPW arg | I.CMPB arg 
-	     | I.TESTQ arg | I.TESTL arg | I.TESTW arg | I.TESTB arg) => cmptest arg
+	   | ( I.CMPQ arg ) => cmptest arg
+	   | ( I.CMPL arg ) => cmptest arg
+	   | ( I.CMPW arg ) => cmptest arg
+	   | ( I.CMPB arg ) => cmptest arg
+           | ( I.TESTQ arg ) => cmptest arg
+           | ( I.TESTL arg ) => cmptest arg
+           | ( I.TESTW arg ) => cmptest arg
+           | ( I.TESTB arg ) => cmptest arg
 	   | I.MULTDIV{src, ...} => operand src
 	   | I.MUL3{src1, ...} => operand src1
 	   | I.MULQ3{src1, ...} => operand src1
 	   | I.UNARY{opnd, ...} => operand opnd
 	   | I.SET{opnd, ...} => operand opnd
 	   | I.CMOV{src, dst, ...} => operand src 
-	   | (I.PUSHQ opnd | I.PUSHL opnd | I.PUSHW opnd | I.PUSHB opnd) => operand opnd
+	   | (I.PUSHQ opnd) => operand opnd
+	   | (I.PUSHL opnd) => operand opnd
+	   | (I.PUSHW opnd) => operand opnd
+	   | (I.PUSHB opnd) => operand opnd
 	   | I.POP opnd =>  operand opnd
 	   | _ => false
       end
diff --git a/amd64/c-calls/amd64-svid.sml b/amd64/c-calls/amd64-svid.sml
index 185f951..c69e7ad 100644
--- a/amd64/c-calls/amd64-svid.sml
+++ b/amd64/c-calls/amd64-svid.sml
@@ -450,7 +450,8 @@ functor AMD64SVID_CCalls (
 	 * differences there might be between the SVID and Windows ABIs. (JHR)
 	 *)
 	  val calleePops = (case #conv proto
-		 of (""|"ccall") => false
+		 of ("") => false
+		  | ("ccall") => false
 		  | "stdcall" => true
 		  | conv => error (concat [
 			"unknown calling convention \"", String.toString conv, "\""
diff --git a/amd64/emit/amd64Asm.sml b/amd64/emit/amd64Asm.sml
index a275515..bc740c4 100644
--- a/amd64/emit/amd64Asm.sml
+++ b/amd64/emit/amd64Asm.sml
@@ -6,12 +6,85 @@
 
 
 functor AMD64AsmEmitter(structure S : INSTRUCTION_STREAM
-                        structure Instr : AMD64INSTR
-                           where T = S.P.T
-                        structure Shuffle : AMD64SHUFFLE
-                           where I = Instr
-                        structure MLTreeEval : MLTREE_EVAL
-                           where T = Instr.T
+                        structure Instr : AMD64INSTR (* where T = S.P.T *)
+                                        where type T.Basis.cond = S.P.T.Basis.cond
+                                          and type T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+                                          and type T.Basis.ext = S.P.T.Basis.ext
+                                          and type T.Basis.fcond = S.P.T.Basis.fcond
+                                          and type T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+                                          and type T.Constant.const = S.P.T.Constant.const
+                                          and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+                                          and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+                                          and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+                                          and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+                                          and type T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+                                          and type T.Region.region = S.P.T.Region.region
+                                          and type T.ccexp = S.P.T.ccexp
+                                          and type T.fexp = S.P.T.fexp
+                                          (* and type T.labexp = S.P.T.labexp *)
+                                          and type T.mlrisc = S.P.T.mlrisc
+                                          and type T.oper = S.P.T.oper
+                                          and type T.rep = S.P.T.rep
+                                          and type T.rexp = S.P.T.rexp
+                                          and type T.stm = S.P.T.stm
+                        structure Shuffle : AMD64SHUFFLE (* where I = Instr *)
+                                          where type I.Constant.const = Instr.Constant.const
+                                            and type I.Region.region = Instr.Region.region
+                                            and type I.T.Basis.cond = Instr.T.Basis.cond
+                                            and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                            and type I.T.Basis.ext = Instr.T.Basis.ext
+                                            and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                            and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                            and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                            and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                            and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                            and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                            and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                            and type I.T.ccexp = Instr.T.ccexp
+                                            and type I.T.fexp = Instr.T.fexp
+                                            (* and type I.T.labexp = Instr.T.labexp *)
+                                            and type I.T.mlrisc = Instr.T.mlrisc
+                                            and type I.T.oper = Instr.T.oper
+                                            and type I.T.rep = Instr.T.rep
+                                            and type I.T.rexp = Instr.T.rexp
+                                            and type I.T.stm = Instr.T.stm
+                                            (* and type I.addressing_mode = Instr.addressing_mode *)
+                                            and type I.binaryOp = Instr.binaryOp
+                                            and type I.bitOp = Instr.bitOp
+                                            and type I.cond = Instr.cond
+                                            and type I.fbin_op = Instr.fbin_op
+                                            and type I.fcom_op = Instr.fcom_op
+                                            and type I.fmove_op = Instr.fmove_op
+                                            and type I.fsize = Instr.fsize
+                                            and type I.instr = Instr.instr
+                                            and type I.instruction = Instr.instruction
+                                            and type I.isize = Instr.isize
+                                            and type I.move = Instr.move
+                                            and type I.multDivOp = Instr.multDivOp
+                                            and type I.operand = Instr.operand
+                                            and type I.shiftOp = Instr.shiftOp
+                                            and type I.unaryOp = Instr.unaryOp
+                        structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                             where type T.Basis.cond = Instr.T.Basis.cond
+                                               and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                               and type T.Basis.ext = Instr.T.Basis.ext
+                                               and type T.Basis.fcond = Instr.T.Basis.fcond
+                                               and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                               and type T.Constant.const = Instr.T.Constant.const
+                                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                               and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                               and type T.Region.region = Instr.T.Region.region
+                                               and type T.ccexp = Instr.T.ccexp
+                                               and type T.fexp = Instr.T.fexp
+                                               (* and type T.labexp = Instr.T.labexp *)
+                                               and type T.mlrisc = Instr.T.mlrisc
+                                               and type T.oper = Instr.T.oper
+                                               and type T.rep = Instr.T.rep
+                                               and type T.rexp = Instr.T.rexp
+                                               and type T.stm = Instr.T.stm
                        ) : INSTRUCTION_EMITTER =
 struct
    structure I  = Instr
@@ -372,7 +445,8 @@ struct
            val n = size fbinOp
        in 
           (case Char.toLower (String.sub (fbinOp, n - 1)) of
-            (#"s" | #"l") => String.substring (fbinOp, 0, n - 1)
+            (#"s") => String.substring (fbinOp, 0, n - 1)
+          | (#"l") => String.substring (fbinOp, 0, n - 1)
           | _ => fbinOp
           )
        end
@@ -513,18 +587,62 @@ struct
        | I.BINARY{binOp, src, dst} => 
          (case (src, binOp) of
            (I.Direct _, 
-           ( I.SARQ |
-           I.SHRQ |
-           I.SHLQ |
-           I.SARL |
-           I.SHRL |
-           I.SHLL |
-           I.SARW |
-           I.SHRW |
-           I.SHLW |
-           I.SARB |
-           I.SHRB |
-           I.SHLB )) => 
+           ( I.SARQ )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHRQ )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHLQ )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SARL )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHRL )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHLL )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+        | (I.Direct _,
+           ( I.SARW )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHRW )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHLW )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+        | (I.Direct _,
+           ( I.SARB )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHRB )) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _,
+           ( I.SHLB )) =>
            ( emit_binaryOp binOp; 
              emit "\t%cl, "; 
              emit_dst dst )
diff --git a/amd64/flowgraph/amd64-darwin-pseudo-ops.sml b/amd64/flowgraph/amd64-darwin-pseudo-ops.sml
index de9238f..c60550a 100644
--- a/amd64/flowgraph/amd64-darwin-pseudo-ops.sml
+++ b/amd64/flowgraph/amd64-darwin-pseudo-ops.sml
@@ -7,7 +7,27 @@
 functor AMD64DarwinPseudoOps (
 
     structure T : MLTREE
-    structure MLTreeEval : MLTREE_EVAL  where T = T
+    structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                           where type T.Basis.cond = T.Basis.cond
+                             and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                             and type T.Basis.ext = T.Basis.ext
+                             and type T.Basis.fcond = T.Basis.fcond
+                             and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                             and type T.Constant.const = T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                             and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                             and type T.Region.region = T.Region.region
+                             and type T.ccexp = T.ccexp
+                             and type T.fexp = T.fexp
+                             (* and type T.labexp = T.labexp *)
+                             and type T.mlrisc = T.mlrisc
+                             and type T.oper = T.oper
+                             and type T.rep = T.rep
+                             and type T.rexp = T.rexp
+                             and type T.stm = T.stm
 
   ) : PSEUDO_OPS_BASIS = struct
 
diff --git a/amd64/flowgraph/amd64GasPseudoOps.sml b/amd64/flowgraph/amd64GasPseudoOps.sml
index f9adca4..8addf5d 100644
--- a/amd64/flowgraph/amd64GasPseudoOps.sml
+++ b/amd64/flowgraph/amd64GasPseudoOps.sml
@@ -6,7 +6,27 @@
 
 functor AMD64GasPseudoOps (
     structure T : MLTREE
-    structure MLTreeEval : MLTREE_EVAL  where T = T
+    structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                           where type T.Basis.cond = T.Basis.cond
+                             and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                             and type T.Basis.ext = T.Basis.ext
+                             and type T.Basis.fcond = T.Basis.fcond
+                             and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                             and type T.Constant.const = T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                             and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                             and type T.Region.region = T.Region.region
+                             and type T.ccexp = T.ccexp
+                             and type T.fexp = T.fexp
+                             (* and type T.labexp = T.labexp *)
+                             and type T.mlrisc = T.mlrisc
+                             and type T.oper = T.oper
+                             and type T.rep = T.rep
+                             and type T.rexp = T.rexp
+                             and type T.stm = T.stm
   ) : PSEUDO_OPS_BASIS =  struct
     structure T = T
     structure PB = PseudoOpsBasisTyp
diff --git a/amd64/instructions/amd64CompInstrExt.sml b/amd64/instructions/amd64CompInstrExt.sml
index 981d4de..9afe8d7 100644
--- a/amd64/instructions/amd64CompInstrExt.sml
+++ b/amd64/instructions/amd64CompInstrExt.sml
@@ -7,11 +7,54 @@
 
 signature AMD64COMP_INSTR_EXT = sig
   structure I : AMD64INSTR
-  structure TS : MLTREE_STREAM
-		 where T = I.T
-  structure CFG : CONTROL_FLOW_GRAPH 
- 	         where I = I
-                   and P = TS.S.P
+  structure TS : MLTREE_STREAM (* where T = I.T *)
+                 where type T.Basis.cond = I.T.Basis.cond
+                   and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                   and type T.Basis.ext = I.T.Basis.ext
+                   and type T.Basis.fcond = I.T.Basis.fcond
+                   and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                   and type T.Constant.const = I.T.Constant.const
+                   and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                   and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                   and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                   and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                   and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                   and type T.Region.region = I.T.Region.region
+                   and type T.ccexp = I.T.ccexp
+                   and type T.fexp = I.T.fexp
+                   (* and type T.labexp = I.T.labexp *)
+                   and type T.mlrisc = I.T.mlrisc
+                   and type T.oper = I.T.oper
+                   and type T.rep = I.T.rep
+	           and type T.rexp = I.T.rexp
+                   and type T.stm = I.T.stm
+  structure CFG : CONTROL_FLOW_GRAPH (* where I = I and P = TS.S.P *)
+                  where type I.addressing_mode = I.addressing_mode
+                    and type I.ea = I.ea
+                    and type I.instr = I.instr
+                    and type I.instruction = I.instruction
+                    and type I.operand = I.operand
+                  where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                    and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                    and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                    and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                    and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                    and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                    and type P.T.Constant.const = TS.S.P.T.Constant.const
+                    and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                    and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                    and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                    and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                    and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                    and type P.T.Region.region = TS.S.P.T.Region.region
+                    and type P.T.ccexp = TS.S.P.T.ccexp
+                    and type P.T.fexp = TS.S.P.T.fexp
+                    (* and type P.T.labexp = TS.S.P.T.labexp *)
+                    and type P.T.mlrisc = TS.S.P.T.mlrisc
+                    and type P.T.oper = TS.S.P.T.oper
+                    and type P.T.rep = TS.S.P.T.rep
+                    and type P.T.rexp = TS.S.P.T.rexp
+                    and type P.T.stm = TS.S.P.T.stm
 
   type reducer = 
     (I.instruction, I.C.cellset, I.operand, I.addressing_mode, CFG.cfg) TS.reducer
@@ -26,11 +69,54 @@ end
 
 functor AMD64CompInstrExt
   ( structure I : AMD64INSTR
-    structure TS  : MLTREE_STREAM
-		   where T = I.T
-    structure CFG : CONTROL_FLOW_GRAPH 
-		   where P = TS.S.P
-		     and I = I
+    structure TS  : MLTREE_STREAM (* where T = I.T *)
+                    where type T.Basis.cond = I.T.Basis.cond
+                      and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                      and type T.Basis.ext = I.T.Basis.ext
+                      and type T.Basis.fcond = I.T.Basis.fcond
+                      and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                      and type T.Constant.const = I.T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                      and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                      and type T.Region.region = I.T.Region.region
+                      and type T.ccexp = I.T.ccexp
+                      and type T.fexp = I.T.fexp
+                      (* and type T.labexp = I.T.labexp *)
+                      and type T.mlrisc = I.T.mlrisc
+                      and type T.oper = I.T.oper
+                      and type T.rep = I.T.rep
+                      and type T.rexp = I.T.rexp
+                      and type T.stm = I.T.stm
+    structure CFG : CONTROL_FLOW_GRAPH (* where P = TS.S.P and I = I *)
+                    where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                      and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                      and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                      and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                      and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                      and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                      and type P.T.Constant.const = TS.S.P.T.Constant.const
+                      and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                      and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                      and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                      and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                      and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                      and type P.T.Region.region = TS.S.P.T.Region.region
+                      and type P.T.ccexp = TS.S.P.T.ccexp
+                      and type P.T.fexp = TS.S.P.T.fexp
+                      (* and type P.T.labexp = TS.S.P.T.labexp *)
+                      and type P.T.mlrisc = TS.S.P.T.mlrisc
+                      and type P.T.oper = TS.S.P.T.oper
+                      and type P.T.rep = TS.S.P.T.rep
+                      and type P.T.rexp = TS.S.P.T.rexp
+                      and type P.T.stm = TS.S.P.T.stm
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
    ) : AMD64COMP_INSTR_EXT = 
 struct
   structure CFG = CFG
diff --git a/amd64/instructions/amd64Instr.sml b/amd64/instructions/amd64Instr.sml
index 7f117cf..01c16e0 100644
--- a/amd64/instructions/amd64Instr.sml
+++ b/amd64/instructions/amd64Instr.sml
@@ -8,7 +8,16 @@
 signature AMD64INSTR =
 sig
    structure C : AMD64CELLS
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    structure T : MLTREE
    structure Constant: CONSTANT
    structure Region : REGION
diff --git a/amd64/instructions/amd64Peephole.peep b/amd64/instructions/amd64Peephole.peep
index c12b8ad..3a37542 100644
--- a/amd64/instructions/amd64Peephole.peep
+++ b/amd64/instructions/amd64Peephole.peep
@@ -20,7 +20,27 @@ in
 functor AMD64Peephole
    (structure Instr : AMD64INSTR
     structure Eval  : MLTREE_EVAL
-      sharing Instr.T = Eval.T
+      (* sharing Instr.T = Eval.T *)
+      where type T.Basis.cond = Instr.T.Basis.cond
+        and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+        and type T.Basis.ext = Instr.T.Basis.ext
+        and type T.Basis.fcond = Instr.T.Basis.fcond
+        and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+        and type T.Constant.const = Instr.T.Constant.const
+        and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+        and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+        and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+        and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+        and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+        and type T.Region.region = Instr.T.Region.region
+        and type T.ccexp = Instr.T.ccexp
+        and type T.fexp = Instr.T.fexp
+        (* and type T.labexp = Instr.T.labexp *)
+        and type T.mlrisc = Instr.T.mlrisc
+        and type T.oper = Instr.T.oper
+        and type T.rep = Instr.T.rep
+        and type T.rexp = Instr.T.rexp
+        and type T.stm = Instr.T.stm
    ) : PEEPHOLE =
 struct
    structure I = Instr
diff --git a/amd64/instructions/amd64Peephole.sml b/amd64/instructions/amd64Peephole.sml
index b561a67..a235b50 100644
--- a/amd64/instructions/amd64Peephole.sml
+++ b/amd64/instructions/amd64Peephole.sml
@@ -12,7 +12,27 @@ functor AMD64Peephole(
                       structure Eval : MLTREE_EVAL
 
 (*#line 23.7 "amd64Peephole.peep"*)
-                      sharing Instr.T = Eval.T
+                      (* sharing Instr.T = Eval.T *)
+                      where type T.Basis.cond = Instr.T.Basis.cond
+                       and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                       and type T.Basis.ext = Instr.T.Basis.ext
+                       and type T.Basis.fcond = Instr.T.Basis.fcond
+                       and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                       and type T.Constant.const = Instr.T.Constant.const
+                       and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                       and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                       and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                       and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                       and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                       and type T.Region.region = Instr.T.Region.region
+                       and type T.ccexp = Instr.T.ccexp
+                       and type T.fexp = Instr.T.fexp
+                       (* and type T.labexp = Instr.T.labexp *)
+                       and type T.mlrisc = Instr.T.mlrisc
+                       and type T.oper = Instr.T.oper
+                       and type T.rep = Instr.T.rep
+                       and type T.rexp = Instr.T.rexp
+                       and type T.stm = Instr.T.stm
                      ): PEEPHOLE =
 struct
 
diff --git a/amd64/instructions/amd64Props.sml b/amd64/instructions/amd64Props.sml
index 5ff322a..f8834de 100644
--- a/amd64/instructions/amd64Props.sml
+++ b/amd64/instructions/amd64Props.sml
@@ -15,10 +15,48 @@ signature AMD64INSN_PROPERTIES =
 
 functor AMD64Props (
     structure Instr : AMD64INSTR
-    structure MLTreeHash : MLTREE_HASH 
-        where T = Instr.T
-    structure MLTreeEval : MLTREE_EVAL 
-        where T = Instr.T
+    structure MLTreeHash : MLTREE_HASH (* where T = Instr.T *)
+                           where type T.Basis.cond = Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = Instr.T.Basis.ext
+                             and type T.Basis.fcond = Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                             and type T.Region.region = Instr.T.Region.region
+                             and type T.ccexp = Instr.T.ccexp
+                             and type T.fexp = Instr.T.fexp
+                             (* and type T.labexp = Instr.T.labexp *)
+                             and type T.mlrisc = Instr.T.mlrisc
+                             and type T.oper = Instr.T.oper
+                             and type T.rep = Instr.T.rep
+                             and type T.rexp = Instr.T.rexp
+                             and type T.stm = Instr.T.stm
+    structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                           where type T.Basis.cond = Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = Instr.T.Basis.ext
+                             and type T.Basis.fcond = Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                             and type T.Region.region = Instr.T.Region.region
+                             and type T.ccexp = Instr.T.ccexp
+                             and type T.fexp = Instr.T.fexp
+                             (* and type T.labexp = Instr.T.labexp *)
+                             and type T.mlrisc = Instr.T.mlrisc
+                             and type T.oper = Instr.T.oper
+                             and type T.rep = Instr.T.rep
+                             and type T.rexp = Instr.T.rexp
+                             and type T.stm = Instr.T.stm
   ) : AMD64INSN_PROPERTIES =
   struct
 
@@ -39,10 +77,16 @@ functor AMD64Props (
       | instrKind (I.COPY _) = IK_COPY
       | instrKind (I.INSTR instr) = (case instr
 	of I.NOP => IK_NOP
-	 | ( I.CALL {cutsTo=_::_, ...} | I.CALLQ {cutsTo=_::_, ...} ) =>
+	 | ( I.CALL {cutsTo=_::_, ...} ) =>
 	   IK_CALL_WITH_CUTS
-	 | ( I.JMP _ | I.JCC _ | I.RET _ | I.INTO ) => IK_JUMP
-	 | ( I.CALL _ | I. CALLQ _ ) => IK_CALL
+	 | ( I.CALLQ {cutsTo=_::_, ...} ) =>
+	   IK_CALL_WITH_CUTS
+	 | ( I.JMP _ ) => IK_JUMP
+	 | ( I.JCC _ ) => IK_JUMP
+	 | ( I.RET _ ) => IK_JUMP
+	 | ( I.INTO) => IK_JUMP
+	 | ( I.CALL _ ) => IK_CALL
+	 | ( I.CALLQ _ ) => IK_CALL
 	 | I.PHI {} => IK_PHI
 	 | I.SOURCE {} => IK_SOURCE
 	 | I.SINK {} => IK_SINK
@@ -55,8 +99,9 @@ functor AMD64Props (
       | moveInstr _ = false
 
     fun moveTmpR (I.ANNOTATION {i, ...}) = moveTmpR i
-      | moveTmpR ( I.COPY {k=CB.GP, tmp=SOME (I.Direct (_, r)), ...}
-                 | I.COPY {k=CB.FP, tmp=SOME (I.FDirect r), ...} ) = 
+      | moveTmpR ( I.COPY {k=CB.GP, tmp=SOME (I.Direct (_, r)), ...} ) =
+	SOME r
+      | moveTmpR ( I.COPY {k=CB.FP, tmp=SOME (I.FDirect r), ...} ) =
 	SOME r
       | moveTmpR _ = NONE
 
@@ -176,25 +221,54 @@ functor AMD64Props (
 	    val uses = operandUse src
 	    in
 	      case multDivOp
-	       of (I.IDIVL1 | I.DIVL1 | I.IDIVQ1 | I.DIVQ1) => 
+	       of (I.IDIVL1) =>
 	           (raxPair, C.rdx::C.rax::uses)
-	        | (I.IMULL1 | I.MULL1 | I.IMULQ1 | I.MULQ1) => 
+                | (I.DIVL1) =>
+	           (raxPair, C.rdx::C.rax::uses)
+                | (I.IDIVQ1) =>
+	           (raxPair, C.rdx::C.rax::uses)
+                | (I.DIVQ1) =>
+	           (raxPair, C.rdx::C.rax::uses)
+	        | (I.IMULL1) =>
+	          (raxPair, C.rax::uses)
+	        | (I.MULL1) =>
+	          (raxPair, C.rax::uses)
+	        | (I.IMULQ1) =>
+	          (raxPair, C.rax::uses)
+	        | (I.MULQ1) =>
 	          (raxPair, C.rax::uses)
 	      (* end case *)
 	    end
 	fun rspOnly () = let val s = [C.stackptrR] in (s, s) end
 	fun push opnd = ([C.stackptrR], operandAcc (opnd, [C.stackptrR]))
 	fun f i = (case i
-	    of ( I.JMP (opnd, _) | I.JCC {opnd, ...} ) => ([], 	operandUse opnd)
-	     | ( I.CALL {opnd, defs, uses, ...} |
-	         I.CALLQ {opnd, defs, uses, ...} )=>
+	    of ( I.JMP (opnd, _) ) => ([], 	operandUse opnd)
+             | ( I.JCC {opnd, ...} ) => ([], 	operandUse opnd)
+	     | ( I.CALL {opnd, defs, uses, ...} )=>
+	       (C.getReg defs, operandAcc (opnd, C.getReg uses))
+	     | ( I.CALLQ {opnd, defs, uses, ...} )=>
  	       (C.getReg defs, operandAcc (opnd, C.getReg uses))
 	     | I.MOVE {src, dst=I.Direct (_, r), ...} => ([r], operandUse src) 
 	     | I.MOVE {src, dst, ...} => ([], operandAcc (dst, operandUse src))
-	     | ( I.LEAL {r32=r, addr} | I.LEAQ {r64=r, addr} ) =>
+	     | ( I.LEAL {r32=r, addr} ) =>
 	       ([r], operandUse addr)
-	     | ( I.CMPQ arg | I.CMPL arg | I.CMPW arg | I.CMPB arg
-	       | I.TESTQ arg | I.TESTL arg | I.TESTW arg | I.TESTB arg )  =>
+	     | ( I.LEAQ {r64=r, addr} ) =>
+	       ([r], operandUse addr)
+	     | ( I.CMPQ arg )  =>
+	       cmpTest arg
+	     | ( I.CMPL arg )  =>
+	       cmpTest arg
+	     | ( I.CMPW arg )  =>
+	       cmpTest arg
+	     | ( I.CMPB arg )  =>
+	       cmpTest arg
+	     | ( I.TESTQ arg )  =>
+	       cmpTest arg
+	     | ( I.TESTL arg )  =>
+	       cmpTest arg
+	     | ( I.TESTW arg )  =>
+	       cmpTest arg
+	     | ( I.TESTB arg )  =>
 	       cmpTest arg
 	     | I.BITOP{lsrc, rsrc, ...} => cmpTest {lsrc=lsrc,rsrc=rsrc}
 	     | I.BINARY{binOp=I.XORL, src=I.Direct (_,rs),
@@ -214,14 +288,22 @@ functor AMD64Props (
 	       (C.rax::operandDef dst, C.rax::operandAcc (src, operandUse dst))
 	     | I.XCHG {src, dst, ...} =>
 	       (operandDef dst, operandAcc (src, operandUse dst)) 
-	     | ( I.ENTER _ | I.LEAVE ) => ([C.rsp, C.rbp], [C.rsp, C.rbp])
+	     | ( I.ENTER _ ) => ([C.rsp, C.rbp], [C.rsp, C.rbp])
+	     | ( I.LEAVE ) => ([C.rsp, C.rbp], [C.rsp, C.rbp])
 	     | I.MULTDIV arg => multDiv arg
-	     | ( I.MUL3  {src1, dst, ...} | I.MULQ3 {src1, dst, ...} ) => 
+	     | ( I.MUL3  {src1, dst, ...} ) =>
 	       ([dst], operandUse src1)
-	     | ( I.UNARY{opnd, ...} | I.SET {opnd, ...} ) => unary opnd
-	     | (I.PUSHQ arg | I.PUSHL arg | I.PUSHW arg | I.PUSHB arg ) => push arg
+	     | ( I.MULQ3 {src1, dst, ...} ) =>
+	       ([dst], operandUse src1)
+	     | ( I.UNARY{opnd, ...} ) => unary opnd
+	     | ( I.SET {opnd, ...} ) => unary opnd
+	     | ( I.PUSHQ arg ) => push arg
+	     | ( I.PUSHL arg ) => push arg
+	     | ( I.PUSHW arg ) => push arg
+	     | ( I.PUSHB arg ) => push arg
 	     | I.POP arg => (C.stackptrR::operandDef arg, [C.stackptrR])
-	     | ( I.PUSHFD | I.POPFD )=> rspOnly ()
+	     | ( I.POPFD )=> rspOnly ()
+	     | ( I.POPFD )=> rspOnly ()
 	     | I.CDQ => ([C.rdx], [C.rax])
 	     | I.FMOVE {dst, src, ...} => ([], operandAcc (dst, operandUse src))
 	     | I.FCOM {src, ...} => ([], operandUse src)
@@ -259,9 +341,13 @@ functor AMD64Props (
             of I.FMOVE {dst, src, ...} => (operand dst, operand src)
              | I.FBINOP {dst, src, ...} => ([dst], dst :: operand src)
              | I.FCOM {dst, src, ...} => ([], operandAcc (src, [dst]))
-             | ( I.FSQRTS {dst, src} | I.FSQRTD {dst, src} )=> 
+             | ( I.FSQRTS {dst, src} )=>
                (operand dst, operand src)
-             | ( I.CALL {defs, uses, ...} | I.CALLQ {defs, uses, ...} ) =>
+             | ( I.FSQRTD {dst, src} )=>
+               (operand dst, operand src)
+             | ( I.CALL {defs, uses, ...} ) =>
+               (C.getFreg defs, C.getFreg uses)
+             | ( I.CALLQ {defs, uses, ...} ) =>
                (C.getFreg defs, C.getFreg uses)
              | _ => ([], [])
             (* end case *))
@@ -311,50 +397,136 @@ functor AMD64Props (
 	 | I.CMOV {src=I.Direct (sz, _), ...} => sz
 	 | I.MOVE {mvOp, ...} => 
 	   (case mvOp
-	     of ( I.MOVQ | I.MOVSWQ | I.MOVZWQ | I.MOVSBQ | 
-		  I.MOVZBQ | I.MOVSLQ |
-		  I.CVTSD2SIQ | I.CVTSS2SIQ
-		) => 64
-	      | ( I.MOVL | I.MOVSWL | I.MOVZWL | I.MOVSBL | 
-		  I.CVTSD2SI | I.CVTSS2SI |
-		  I.MOVZBL ) => 32
+	     of ( I.MOVQ ) => 64
+              | ( I.MOVSWQ ) => 64
+              | ( I.MOVZWQ ) => 64
+              | ( I.MOVSBQ ) => 64
+              | ( I.MOVZBQ ) => 64
+              | ( I.MOVSLQ ) => 64
+              | ( I.CVTSD2SIQ ) => 64
+              | ( I.CVTSS2SIQ ) => 64
+	      | ( I.MOVL ) => 32
+              | ( I.MOVSWL ) => 32
+              | ( I.MOVZWL ) => 32
+              | ( I.MOVSBL ) => 32
+              | ( I.CVTSD2SI ) => 32
+              | ( I.CVTSS2SI ) => 32
+              | ( I.MOVZBL ) => 32
 	      | I.MOVW => 16
 	      | I.MOVB => 8
 	   (* esac *))
-	 | ( I.CALL _ | I.LEAL _ | I.CMPL _ | I.TESTL _ | I.MUL3 _ )
-	     => 32
-	 | ( I.CALLQ _ | I.LEAQ _ | I.CMPQ _ | I.TESTQ _ | I.MULQ3 _ | I.CMOV _)
-	     => 64 
-	 | ( I.CMPW _ | I.TESTW _ ) => 16
-	 | ( I.CMPB _ | I.TESTB _ ) => 8 
+	 | ( I.CALL _ ) => 32
+         | ( I.LEAL _ ) => 32
+         | ( I.CMPL _ ) => 32
+         | ( I.TESTL _ ) => 32
+         | ( I.MUL3 _ ) => 32
+	 | ( I.CALLQ _ ) => 64
+         | ( I.LEAQ _ ) => 64
+         | ( I.CMPQ _ ) => 64
+         | ( I.TESTQ _ ) => 64
+         | ( I.MULQ3 _ ) => 64
+         | ( I.CMOV _ ) => 64
+	 | ( I.CMPW _ ) => 16
+	 | ( I.TESTW _ ) => 16
+	 | ( I.CMPB _ ) => 8
+	 | ( I.TESTB _ ) => 8
 	 | I.SHIFT {shiftOp, ...} => (case shiftOp
-	   of ( I.SHLDL | I.SHRDL ) => 32
+	   of ( I.SHLDL ) => 32
+            | ( I.SHRDL ) => 32
 	   (* esac *))
 	 | I.UNARY {unOp, ...} =>
 	   (case unOp
-	     of ( I.DECQ | I.INCQ | I.NEGQ | I.NOTQ | 
-		  I.LOCK_DECQ | I.LOCK_INCQ | I.LOCK_NEGQ | I.LOCK_NOTQ ) => 64
-	      | ( I.DECL | I.INCL | I.NEGL | I.NOTL ) => 32
-	      | ( I.DECW | I.INCW | I.NEGW | I.NOTW ) => 16
-	      | ( I.DECB | I.INCB | I.NEGB | I.NOTB ) => 8
+	     of ( I.DECQ ) => 64
+              | ( I.INCQ ) => 64
+              | ( I.NEGQ ) => 64
+              | ( I.NOTQ ) => 64
+              | ( I.LOCK_DECQ ) => 64
+              | ( I.LOCK_INCQ ) => 64
+              | ( I.LOCK_NEGQ ) => 64
+              | ( I.LOCK_NOTQ ) => 64
+	      | ( I.DECL ) => 32
+              | ( I.INCL ) => 32
+              | ( I.NEGL ) => 32
+              | ( I.NOTL ) => 32
+	      | ( I.DECW ) => 16
+              | ( I.INCW ) => 16
+              | ( I.NEGW ) => 16
+              | ( I.NOTW ) => 16
+	      | ( I.DECB ) => 8
+              | ( I.INCB ) => 8
+              | ( I.NEGB ) => 8
+              | ( I.NOTB ) => 8
 	   (* esac *))
 	 | I.MULTDIV {multDivOp, ...} => 
 	   (case multDivOp
-	     of ( I.IMULL1 | I.MULL1 | I.IDIVL1 | I.DIVL1 ) => 32
-	      | ( I.IMULQ1 | I.MULQ1 | I.IDIVQ1 | I.DIVQ1 ) => 64
+	     of ( I.IMULL1 ) => 32
+              | ( I.MULL1 ) => 32
+              | ( I.IDIVL1 ) => 32
+              | ( I.DIVL1 ) => 32
+	      | ( I.IMULQ1 ) => 64
+              | ( I.MULQ1 ) => 64
+              | ( I.IDIVQ1 ) => 64
+              | ( I.DIVQ1 ) => 64
 	   (* esac *))
 	 | I.BINARY {binOp, ...} => 
 	   (case binOp
-	     of ( I.ADDQ | I.SUBQ | I.ANDQ | I.ORQ | I.XORQ | I.SHLQ | I.SARQ 
-	        | I.SHRQ | I.MULQ | I.IMULQ | I.ADCQ | I.SBBQ ) => 64
-	      | ( I.ADDL | I.SUBL | I.ANDL | I.ORL | I.XORL | I.SHLL | I.SARL
-                | I.SHRL | I.MULL | I.IMULL | I.ADCL | I.SBBL | I.BTSL | I.BTCL
-                | I.BTRL | I.ROLL | I.RORL | I.XCHGL ) => 32
-	      | ( I.ADDW | I.SUBW | I.ANDW | I.ORW | I.XORW | I.SHLW | I.SARW 
-                | I.SHRW | I.MULW | I.IMULW | I.BTSW | I.BTCW | I.BTRW | I.ROLW 
-                | I.RORW | I.XCHGW ) => 16
-	      | ( I.ADDB | I.SUBB | I.ANDB | I.ORB | I.XORB | I.SHLB | I.SARB 
-                | I.SHRB | I.MULB | I.IMULB | I.XCHGB ) => 8
+	     of ( I.ADDQ ) => 64
+              | ( I.SUBQ ) => 64
+              | ( I.ANDQ ) => 64
+              | ( I.ORQ ) => 64
+              | ( I.XORQ ) => 64
+              | ( I.SHLQ ) => 64
+              | ( I.SARQ ) => 64
+              | ( I.SHRQ ) => 64
+              | ( I.MULQ ) => 64
+              | ( I.IMULQ ) => 64
+              | ( I.ADCQ ) => 64
+              | ( I.SBBQ ) => 64
+	      | ( I.ADDL ) => 32
+              | ( I.SUBL ) => 32
+              | ( I.ANDL ) => 32
+              | ( I.ORL ) => 32
+              | ( I.XORL ) => 32
+              | ( I.SHLL ) => 32
+              | ( I.SARL ) => 32
+              | ( I.SHRL ) => 32
+              | ( I.MULL ) => 32
+              | ( I.IMULL ) => 32
+              | ( I.ADCL ) => 32
+              | ( I.SBBL ) => 32
+              | ( I.BTSL ) => 32
+              | ( I.BTCL ) => 32
+              | ( I.BTRL ) => 32
+              | ( I.ROLL ) => 32
+              | ( I.RORL ) => 32
+              | ( I.XCHGL ) => 32
+	      | ( I.ADDW ) => 16
+              | ( I.SUBW ) => 16
+              | ( I.ANDW ) => 16
+              | ( I.ORW ) => 16
+              | ( I.XORW ) => 16
+              | ( I.SHLW ) => 16
+              | ( I.SARW ) => 16
+              | ( I.SHRW ) => 16
+              | ( I.MULW ) => 16
+              | ( I.IMULW ) => 16
+              | ( I.BTSW ) => 16
+              | ( I.BTCW ) => 16
+              | ( I.BTRW ) => 16
+              | ( I.ROLW ) => 16
+              | ( I.RORW ) => 16
+              | ( I.XCHGW ) => 16
+	      | ( I.ADDB ) => 8
+              | ( I.SUBB ) => 8
+              | ( I.ANDB ) => 8
+              | ( I.ORB ) => 8
+              | ( I.XORB ) => 8
+              | ( I.SHLB ) => 8
+              | ( I.SARB ) => 8
+              | ( I.SHRB ) => 8
+              | ( I.MULB ) => 8
+              | ( I.IMULB ) => 8
+              | ( I.XCHGB ) => 8
 	      | _ => raise Fail "" (* 64*)
 	   (* esac *))
 	 | I.XADD {sz, ...} => szToInt sz
@@ -362,22 +534,44 @@ functor AMD64Props (
 	 | I.PAUSE => 64
 	 | I.RDTSC => 64
 	 | I.RDTSCP => 64
-	 | (I.MFENCE | I.SFENCE | I.LFENCE) => 64
+	 | (I.MFENCE) => 64
+	 | (I.SFENCE) => 64
+	 | (I.LFENCE) => 64
 	 | _ => raise Fail "" (*64*)
       (* esac *))
 
     fun szOfFinstr instr = (case instr
         of I.FMOVE {fmvOp, ...} => (case fmvOp
-           of ( I.MOVSS | I.CVTSS2SD | I.CVTSI2SS | I.CVTSI2SSQ ) => 32
-            | ( I.MOVSD | I.CVTSD2SS | I.CVTSI2SD | I.CVTSI2SDQ ) => 64
+           of ( I.MOVSS ) => 32
+            | ( I.CVTSS2SD ) => 32
+            | ( I.CVTSI2SS ) => 32
+            | ( I.CVTSI2SSQ ) => 32
+            | ( I.MOVSD ) => 64
+            | ( I.CVTSD2SS ) => 64
+            | ( I.CVTSI2SD ) => 64
+            | ( I.CVTSI2SDQ ) => 64
            (* end case *))
          | I.FCOM {comOp, ...} => (case comOp
-           of ( I.COMISS | I.UCOMISS ) => 32
-            | ( I.COMISD | I.UCOMISD ) => 64
+           of ( I.COMISS ) => 32
+            | ( I.UCOMISS ) => 32
+            | ( I.COMISD ) => 64
+            | ( I.UCOMISD ) => 64
            (* end case *))
          | I.FBINOP {binOp, ...} => (case binOp
-           of ( I.ADDSS | I.SUBSS | I.MULSS | I.DIVSS | I.XORPS | I.ANDPS | I.ORPS ) => 32
-            | ( I.ADDSD | I.SUBSD | I.MULSD | I.DIVSD | I.XORPD | I.ANDPD | I.ORPD ) => 64
+           of ( I.ADDSS ) => 32
+            | ( I.SUBSS ) => 32
+            | ( I.MULSS ) => 32
+            | ( I.DIVSS ) => 32
+            | ( I.XORPS ) => 32
+            | ( I.ANDPS ) => 32
+            | ( I.ORPS ) => 32
+            | ( I.ADDSD ) => 64
+            | ( I.SUBSD ) => 64
+            | ( I.MULSD ) => 64
+            | ( I.DIVSD ) => 64
+            | ( I.XORPD ) => 64
+            | ( I.ANDPD ) => 64
+            | ( I.ORPD ) => 64
            (* end case *))
          | I.FSQRTS _ => 32
          | I.FSQRTD _ => 64
diff --git a/amd64/mltree/amd64-gen.sml b/amd64/mltree/amd64-gen.sml
index 9cd49d3..23a17ef 100644
--- a/amd64/mltree/amd64-gen.sml
+++ b/amd64/mltree/amd64-gen.sml
@@ -5,10 +5,53 @@
 
 functor AMD64Gen (
     structure I : AMD64INSTR
-    structure MLTreeUtils : MLTREE_UTILS
-	where T = I.T
-    structure ExtensionComp : MLTREE_EXTENSION_COMP
-        where I = I and T = I.T
+    structure MLTreeUtils : MLTREE_UTILS (* where T = I.T *)
+                            where type T.Basis.cond = I.T.Basis.cond
+                              and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                              and type T.Basis.ext = I.T.Basis.ext
+                              and type T.Basis.fcond = I.T.Basis.fcond
+                              and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                              and type T.Constant.const = I.T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                              and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                               and type T.Region.region = I.T.Region.region
+                              and type T.ccexp = I.T.ccexp
+                              and type T.fexp = I.T.fexp
+                              (* and type T.labexp = I.T.labexp *)
+                              and type T.mlrisc = I.T.mlrisc
+                              and type T.oper = I.T.oper
+                              and type T.rep = I.T.rep
+                              and type T.rexp = I.T.rexp
+                              and type T.stm = I.T.stm
+    structure ExtensionComp : MLTREE_EXTENSION_COMP (* where I = I and T = I.T *)
+                              where type I.addressing_mode = I.addressing_mode
+                                and type I.ea = I.ea
+                                and type I.instr = I.instr
+                                and type I.instruction = I.instruction
+                                and type I.operand = I.operand
+                              where type T.Basis.cond = I.T.Basis.cond
+                                and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                                and type T.Basis.ext = I.T.Basis.ext
+                                and type T.Basis.fcond = I.T.Basis.fcond
+                                and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                                and type T.Constant.const = I.T.Constant.const
+                                and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                                and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                                and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                                and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                                and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                                and type T.Region.region = I.T.Region.region
+                                and type T.ccexp = I.T.ccexp
+                                and type T.fexp = I.T.fexp
+                                (* and type T.labexp = I.T.labexp *)
+                                and type T.mlrisc = I.T.mlrisc
+                                and type T.oper = I.T.oper
+                                and type T.rep = I.T.rep
+                                and type T.rexp = I.T.rexp
+                                and type T.stm = I.T.stm
 
     (* Take a number of bits and returns a label that points to a literal with the high bit set.
      * We need this literal value for floating-point negation and absolute value (at least
@@ -378,7 +421,8 @@ functor AMD64Gen (
 		   move (ty, I.Immed64 (Int64.fromLarge i'), dst);
 		   dst
                end
-          | operand _ (x as (T.CONST _ | T.LABEL _)) = loadLabel (I.ImmedLabel x)
+          | operand _ (x as (T.CONST _ )) = loadLabel (I.ImmedLabel x)
+          | operand _ (x as (T.LABEL _)) = loadLabel (I.ImmedLabel x)
           | operand _ (T.LABEXP le) = loadLabel (I.ImmedLabel le)
           | operand _ (T.REG(ty,r)) = gpr (ty, r)
           | operand _ (T.LOAD(ty,ea,mem)) = address (ea, mem)
@@ -392,7 +436,8 @@ functor AMD64Gen (
 	  | immedOrReg(ty, opnd as I.LabelEA _)  = moveToReg (ty, opnd)
 	  | immedOrReg (ty, opnd)  = opnd
 
-	and regOrMem (ty, opnd as (I.Immed _ | I.ImmedLabel _)) = moveToReg (ty, opnd)
+	and regOrMem (ty, opnd as (I.Immed _)) = moveToReg (ty, opnd)
+	  | regOrMem (ty, opnd as (I.ImmedLabel _)) = moveToReg (ty, opnd)
 	  | regOrMem (ty, opnd) = opnd
 
 	and getExpr (exp as T.REG(_, rd)) = rd
@@ -806,7 +851,9 @@ functor AMD64Gen (
 		 | T.LI z => if (fitsIn32Bits z)
                    then move' (ty, I.Immed (toInt32 z), dstOpnd, an)
                    else mark' (move64 (I.Immed64(toInt64 z), dstOpnd), an)
-		 | (T.CONST _ | T.LABEL _) => 
+		 | (T.CONST _) =>
+                   move' (ty, I.ImmedLabel e, dstOpnd, an)
+		 | (T.LABEL _) =>
                    move' (ty, I.ImmedLabel e, dstOpnd, an)
 		 | T.LABEXP le => move' (ty, I.ImmedLabel le, dstOpnd, an)
 		 (* arithmetic operations *)
@@ -945,7 +992,34 @@ functor AMD64Gen (
 	and fbinop (fty, binOp, a, b, d, an) = let
            (* try to move memory operands to src rather than dst if binOp is commutative *)
 	    val (a, b) = (case (binOp, a, b)
-                of ( (I.ADDSS | I.ADDSD | I.MULSS | I.MULSD | I.XORPS | I.XORPD | I.ANDPS | I.ANDPD | I.ORPS | I.ORPD), 		     
+                of ( (I.ADDSS),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.ADDSD),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.MULSS),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.MULSD),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.XORPS),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.XORPD),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.ANDPS),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.ANDPD),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.ORPS),
+		     T.FLOAD _,
+		     T.FREG _) => (b, a)
+                 | ( (I.ORPD),
 		     T.FLOAD _,
 		     T.FREG _) => (b, a)
 		 | _ => (a, b)
@@ -1316,7 +1390,15 @@ functor AMD64Gen (
 	 * On the amd64, TEST is superior to AND for doing the same thing,
 	 * since it doesn't need to write out the result in a register.
 	 *)
-	and cmpWithZero(cc as (T.EQ | T.NE), e as T.ANDB(ty, a, b), an) = 
+	and cmpWithZero(cc as (T.EQ), e as T.ANDB(ty, a, b), an) =
+		(case ty
+		  of 8 => test(ty, I.TESTB, a, b, an)
+		  | 16 => test(ty, I.TESTW, a, b, an)
+		  | 32 => test(ty, I.TESTL, a, b, an)
+		  | 64 => test(ty, I.TESTQ, a, b, an)
+		  | _  => expr (e, newReg(), an);
+		cc)
+	 | cmpWithZero(cc as (T.NE), e as T.ANDB(ty, a, b), an) =
 		(case ty 
 		  of 8 => test(ty, I.TESTB, a, b, an)
 		  | 16 => test(ty, I.TESTW, a, b, an)
diff --git a/amd64/omit-frameptr/amd64omit-frameptr.sml b/amd64/omit-frameptr/amd64omit-frameptr.sml
index 5c122da..b079909 100644
--- a/amd64/omit-frameptr/amd64omit-frameptr.sml
+++ b/amd64/omit-frameptr/amd64omit-frameptr.sml
@@ -10,9 +10,51 @@
  *)
 functor AMD64OmitFramePointer (
     structure I : AMD64INSTR 
-    structure CFG : CONTROL_FLOW_GRAPH where I = I): OMIT_FRAME_POINTER = 
+    structure CFG : CONTROL_FLOW_GRAPH (* where I = I *)
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand): OMIT_FRAME_POINTER = 
 (*
-    structure MemRegs : MEMORY_REGISTERS where I=I
+    structure MemRegs : MEMORY_REGISTERS (* where I = I *)
+                        where type I.Constant.const = I.Constant.const
+                          and type I.Region.region = I.Region.region
+                          and type I.T.Basis.cond = I.T.Basis.cond
+                          and type I.T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                          and type I.T.Basis.ext = I.T.Basis.ext
+                          and type I.T.Basis.fcond = I.T.Basis.fcond
+                          and type I.T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                          and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                          and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                          and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                          and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                          and type I.T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                          and type I.T.ccexp = I.T.ccexp
+                          and type I.T.fexp = I.T.fexp
+                          (* and type I.T.labexp = I.T.labexp *)
+                          and type I.T.mlrisc = I.T.mlrisc
+                          and type I.T.oper = I.T.oper
+                          and type I.T.rep = I.T.rep
+                          and type I.T.rexp = I.T.rexp
+                          and type I.T.stm = I.T.stm
+                          (* and type I.addressing_mode = I.addressing_mode *)
+                          and type I.binaryOp = I.binaryOp
+                          and type I.bitOp = I.bitOp
+                          and type I.cond = I.cond
+                          and type I.fbinOp = I.fbinOp
+                          and type I.fenvOp = I.fenvOp
+                          and type I.fibinOp = I.fibinOp
+                          and type I.fsize = I.fsize
+                          and type I.funOp = I.funOp
+                          and type I.instr = I.instr
+                          and type I.instruction = I.instruction
+                          and type I.isize = I.isize
+                          and type I.move = I.move
+                          and type I.multDivOp = I.multDivOp
+                          and type I.operand = I.operand
+                          and type I.shiftOp = I.shiftOp
+                          and type I.unaryOp = I.unaryOp
     val memRegBase : CellsBasis.cell option
 *)
 struct
diff --git a/amd64/ra/amd64RegAlloc.sml b/amd64/ra/amd64RegAlloc.sml
index cf1b6f2..ef4fdd9 100644
--- a/amd64/ra/amd64RegAlloc.sml
+++ b/amd64/ra/amd64RegAlloc.sml
@@ -6,15 +6,51 @@
 functor AMD64RegAlloc (
       structure I : AMD64INSTR
       structure SpillHeur : RA_SPILL_HEURISTICS 
-      structure Props : AMD64INSN_PROPERTIES
-          where I = I
-      structure CFG : CONTROL_FLOW_GRAPH
-          where I = I
-      structure Spill : RA_SPILL
-          where I = I
-      structure Asm : INSTRUCTION_EMITTER
-          where I = I
-          and   S.P = CFG.P
+      structure Props : AMD64INSN_PROPERTIES (* where I = I *)
+                        where type I.addressing_mode = I.addressing_mode
+                          and type I.ea = I.ea
+                          and type I.instr = I.instr
+                          and type I.instruction = I.instruction
+                          and type I.operand = I.operand
+      structure CFG : CONTROL_FLOW_GRAPH (* where I = I *)
+                      where type I.addressing_mode = I.addressing_mode
+                        and type I.ea = I.ea
+                        and type I.instr = I.instr
+                        and type I.instruction = I.instruction
+                        and type I.operand = I.operand
+      structure Spill : RA_SPILL (* where I = I *)
+                      where type I.addressing_mode = I.addressing_mode
+                        and type I.ea = I.ea
+                        and type I.instr = I.instr
+                        and type I.instruction = I.instruction
+                        and type I.operand = I.operand
+      structure Asm : INSTRUCTION_EMITTER (* where I = I and S.P = CFG.P *)
+                           where type I.addressing_mode = I.addressing_mode
+                             and type I.ea = I.ea
+                             and type I.instr = I.instr
+                             and type I.instruction = I.instruction
+                             and type I.operand = I.operand
+                           where type S.P.Client.pseudo_op = CFG.P.Client.pseudo_op
+                             and type S.P.T.Basis.cond = CFG.P.T.Basis.cond
+                             and type S.P.T.Basis.div_rounding_mode = CFG.P.T.Basis.div_rounding_mode
+                             and type S.P.T.Basis.ext = CFG.P.T.Basis.ext
+                             and type S.P.T.Basis.fcond = CFG.P.T.Basis.fcond
+                             and type S.P.T.Basis.rounding_mode = CFG.P.T.Basis.rounding_mode
+                             and type S.P.T.Constant.const = CFG.P.T.Constant.const
+                             and type ('s,'r,'f,'c) S.P.T.Extension.ccx = ('s,'r,'f,'c) CFG.P.T.Extension.ccx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.fx = ('s,'r,'f,'c) CFG.P.T.Extension.fx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.rx = ('s,'r,'f,'c) CFG.P.T.Extension.rx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.sx = ('s,'r,'f,'c) CFG.P.T.Extension.sx
+                             and type S.P.T.I.div_rounding_mode = CFG.P.T.I.div_rounding_mode
+                             and type S.P.T.Region.region = CFG.P.T.Region.region
+                             and type S.P.T.ccexp = CFG.P.T.ccexp
+                             and type S.P.T.fexp = CFG.P.T.fexp
+                             (* and type S.P.T.labexp = CFG.P.T.labexp *)
+                             and type S.P.T.mlrisc = CFG.P.T.mlrisc
+                             and type S.P.T.oper = CFG.P.T.oper
+                             and type S.P.T.rep = CFG.P.T.rep
+                             and type S.P.T.rexp = CFG.P.T.rexp
+                             and type S.P.T.stm = CFG.P.T.stm
 
       type spill_info
       datatype spill_operand_kind = SPILL_LOC 
@@ -138,17 +174,16 @@ functor AMD64RegAlloc (
     (* use the standard register allocator *)
     structure RA = 
         RegisterAllocator
-          (SpillHeur)
-          (MemoryRA
+          (structure SpillHeuristics = SpillHeur
+           structure Flowgraph = MemoryRA
              (RADeadCodeElim
-                (ClusterRA
+                (structure Flowgraph = ClusterRA
                    (structure Flowgraph = CFG
                     structure Asm = Asm
                     structure InsnProps = Props
                     structure Spill = Spill
                    )
-                 )
-                (fun cellkind CB.GP = true
+                 fun cellkind CB.GP = true
 		   | cellkind CB.FP = true
 		   | cellkind _ = false 
                  val deadRegs = deadRegs
diff --git a/amd64/ra/amd64SpillInstr.sml b/amd64/ra/amd64SpillInstr.sml
index 2be8cfd..82b5f3a 100644
--- a/amd64/ra/amd64SpillInstr.sml
+++ b/amd64/ra/amd64SpillInstr.sml
@@ -6,8 +6,12 @@
 
 functor AMD64SpillInstr (
       structure I : AMD64INSTR
-      structure Props : AMD64INSN_PROPERTIES
-          where I = I
+      structure Props : AMD64INSN_PROPERTIES (* where I = I *)
+                        where type I.addressing_mode = I.addressing_mode
+                          and type I.ea = I.ea
+                          and type I.instr = I.instr
+                          and type I.instruction = I.instruction
+                          and type I.operand = I.operand
 
    (* guaranteeing that floats are stored at 16-byte aligned addresses reduces the number of instructions *)
     val floats16ByteAligned : bool
@@ -74,7 +78,8 @@ functor AMD64SpillInstr (
                        proh=[], newReg=NONE}
         in
           (case ea
-            of ( I.Displace _ | I.Indexed _ ) => move ()
+            of ( I.Displace _ ) => move ()
+             | ( I.Indexed _ ) => move ()
              | _ => error "spillToEA"
           (* end case *))
         end 
@@ -86,7 +91,8 @@ functor AMD64SpillInstr (
                        proh=[], newReg=NONE}
         in
           (case ea
-            of ( I.Displace _ | I.Indexed _ ) => move ()
+            of ( I.Displace _ ) => move ()
+             | ( I.Indexed _ ) => move ()
              | _ => error "reloadFromEA"
           (* end case *))
         end
@@ -116,9 +122,63 @@ functor AMD64SpillInstr (
 			        cutsTo=cutsTo, mem=mem, pops=pops}, an)
 		 (* With sign or zero extended spills we use different operand sizes
 		  * for copying to the tmp operand and for copying from the tmp operand. *)
-		 | I.MOVE {mvOp as (I.MOVZBQ|I.MOVSBQ|I.MOVZWQ|I.MOVSWQ|
-		                    I.MOVSLQ|I.MOVZBL|I.MOVSBL|I.MOVZWL|
-		                    I.MOVSWL), src, dst} => let
+		 | I.MOVE {mvOp as (I.MOVZBQ), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVSBQ), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVZWQ), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVSWQ), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVSLQ), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVZBL), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVSBL), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVZWL), src, dst} => let
+		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
+		   in
+		     {proh=[tmpR], newReg=SOME tmpR,
+		      code=[mark (I.MOVE {mvOp=mvOp, src=src, dst=tmpOpnd}, an),
+		            I.move {mvOp=defaultMov, src=tmpOpnd64, dst=spillLoc}]}
+		   end
+		 | I.MOVE {mvOp as (I.MOVSWL), src, dst} => let
 		   val (tmpR, tmpOpnd, tmpOpnd64) = freshTmp ()
 		   in
 		     {proh=[tmpR], newReg=SOME tmpR,
@@ -182,8 +242,14 @@ functor AMD64SpillInstr (
 			  
 		 | I.BINARY {binOp, src, dst} => let 
 		   (* note: dst = r *)
-		   fun multBinOp(I.MULQ|I.MULL|I.MULW|I.MULB|
-				 I.IMULQ|I.IMULL|I.IMULW|I.IMULB) = true
+		   fun multBinOp(I.MULQ) = true
+		     | multBinOp(I.MULL) = true
+		     | multBinOp(I.MULW) = true
+		     | multBinOp(I.MULB) = true
+		     | multBinOp(I.IMULQ) = true
+		     | multBinOp(I.IMULL) = true
+		     | multBinOp(I.IMULW) = true
+		     | multBinOp(I.IMULB) = true
 		     | multBinOp _ = false
 		   in
 		     if multBinOp binOp 
@@ -613,7 +679,77 @@ functor AMD64SpillInstr (
                       proh=[tmpR], newReg=SOME tmpR}
                    end
                 (* treat bitwise operators differently, as they require that their source operand is 16-byte aligned *)
-		 | I.FBINOP {binOp=binOp as (I.XORPS | I.XORPD | I.ANDPS | I.ANDPD | I.ORPS | I.ORPD), src, dst} => if CB.sameColor (r, dst)
+		 | I.FBINOP {binOp=binOp as (I.XORPS), src, dst} => if CB.sameColor (r, dst)
+                   then {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=I.FDirect dst},
+			       mark (I.FBINOP {binOp=binOp, src=src, dst=dst}, an)],
+		         proh=[], newReg=NONE}
+                   else if floats16ByteAligned
+                        then let
+                          val tmpR = newFreg ()
+                          val tmp = I.FDirect tmpR
+                          in
+                              {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=tmp},
+				     mark (I.FBINOP {binOp=binOp, src=tmp, dst=dst}, an)],
+		               proh=[tmpR], newReg=SOME tmpR}
+                          end
+                   else {code=[mark (I.FBINOP {binOp=binOp, src=replace src, dst=dst}, an)], proh=[], newReg=NONE}
+		 | I.FBINOP {binOp=binOp as (I.XORPD), src, dst} => if CB.sameColor (r, dst)
+                   then {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=I.FDirect dst},
+			       mark (I.FBINOP {binOp=binOp, src=src, dst=dst}, an)],
+		         proh=[], newReg=NONE}
+                   else if floats16ByteAligned
+                        then let
+                          val tmpR = newFreg ()
+                          val tmp = I.FDirect tmpR
+                          in
+                              {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=tmp},
+				     mark (I.FBINOP {binOp=binOp, src=tmp, dst=dst}, an)],
+		               proh=[tmpR], newReg=SOME tmpR}
+                          end
+                   else {code=[mark (I.FBINOP {binOp=binOp, src=replace src, dst=dst}, an)], proh=[], newReg=NONE}
+		 | I.FBINOP {binOp=binOp as (I.ANDPS), src, dst} => if CB.sameColor (r, dst)
+                   then {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=I.FDirect dst},
+			       mark (I.FBINOP {binOp=binOp, src=src, dst=dst}, an)],
+		         proh=[], newReg=NONE}
+                   else if floats16ByteAligned
+                        then let
+                          val tmpR = newFreg ()
+                          val tmp = I.FDirect tmpR
+                          in
+                              {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=tmp},
+				     mark (I.FBINOP {binOp=binOp, src=tmp, dst=dst}, an)],
+		               proh=[tmpR], newReg=SOME tmpR}
+                          end
+                   else {code=[mark (I.FBINOP {binOp=binOp, src=replace src, dst=dst}, an)], proh=[], newReg=NONE}
+		 | I.FBINOP {binOp=binOp as (I.ANDPD), src, dst} => if CB.sameColor (r, dst)
+                   then {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=I.FDirect dst},
+			       mark (I.FBINOP {binOp=binOp, src=src, dst=dst}, an)],
+		         proh=[], newReg=NONE}
+                   else if floats16ByteAligned
+                        then let
+                          val tmpR = newFreg ()
+                          val tmp = I.FDirect tmpR
+                          in
+                              {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=tmp},
+				     mark (I.FBINOP {binOp=binOp, src=tmp, dst=dst}, an)],
+		               proh=[tmpR], newReg=SOME tmpR}
+                          end
+                   else {code=[mark (I.FBINOP {binOp=binOp, src=replace src, dst=dst}, an)], proh=[], newReg=NONE}
+		 | I.FBINOP {binOp=binOp as (I.ORPS), src, dst} => if CB.sameColor (r, dst)
+                   then {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=I.FDirect dst},
+			       mark (I.FBINOP {binOp=binOp, src=src, dst=dst}, an)],
+		         proh=[], newReg=NONE}
+                   else if floats16ByteAligned
+                        then let
+                          val tmpR = newFreg ()
+                          val tmp = I.FDirect tmpR
+                          in
+                              {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=tmp},
+				     mark (I.FBINOP {binOp=binOp, src=tmp, dst=dst}, an)],
+		               proh=[tmpR], newReg=SOME tmpR}
+                          end
+                   else {code=[mark (I.FBINOP {binOp=binOp, src=replace src, dst=dst}, an)], proh=[], newReg=NONE}
+		 | I.FBINOP {binOp=binOp as (I.ORPD), src, dst} => if CB.sameColor (r, dst)
                    then {code=[I.fmove {fmvOp=fmvOp, src=spillLoc, dst=I.FDirect dst},
 			       mark (I.FBINOP {binOp=binOp, src=src, dst=dst}, an)], 
 		         proh=[], newReg=NONE}
diff --git a/backpatch/backpatch.sml b/backpatch/backpatch.sml
index 962bbf9..dceed1f 100644
--- a/backpatch/backpatch.sml
+++ b/backpatch/backpatch.sml
@@ -8,13 +8,45 @@
 
 functor BBSched2
     (structure Emitter : INSTRUCTION_EMITTER
-     structure CFG     : CONTROL_FLOW_GRAPH
-			where I = Emitter.I
-		          and P = Emitter.S.P
-     structure Jumps   : SDI_JUMPS
-     			where I = CFG.I
-     structure Props   : INSN_PROPERTIES
-			where I = CFG.I
+     structure CFG     : CONTROL_FLOW_GRAPH (* where I = Emitter.I and P = Emitter.S.P *)
+                         where type I.addressing_mode = Emitter.I.addressing_mode
+                           and type I.ea = Emitter.I.ea
+                           and type I.instr = Emitter.I.instr
+                           and type I.instruction = Emitter.I.instruction
+                           and type I.operand = Emitter.I.operand
+                         where type P.Client.pseudo_op = Emitter.S.P.Client.pseudo_op
+                           and type P.T.Basis.cond = Emitter.S.P.T.Basis.cond
+                           and type P.T.Basis.div_rounding_mode = Emitter.S.P.T.Basis.div_rounding_mode
+                           and type P.T.Basis.ext = Emitter.S.P.T.Basis.ext
+                           and type P.T.Basis.fcond = Emitter.S.P.T.Basis.fcond
+                           and type P.T.Basis.rounding_mode = Emitter.S.P.T.Basis.rounding_mode
+                           and type P.T.Constant.const = Emitter.S.P.T.Constant.const
+                           and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.ccx
+                           and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.fx
+                           and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.rx
+                           and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.sx
+                           and type P.T.I.div_rounding_mode = Emitter.S.P.T.I.div_rounding_mode
+                           and type P.T.Region.region = Emitter.S.P.T.Region.region
+                           and type P.T.ccexp = Emitter.S.P.T.ccexp
+                           and type P.T.fexp = Emitter.S.P.T.fexp
+                           (* and type P.T.labexp = Emitter.S.P.T.labexp *)
+                           and type P.T.mlrisc = Emitter.S.P.T.mlrisc
+                           and type P.T.oper = Emitter.S.P.T.oper
+                           and type P.T.rep = Emitter.S.P.T.rep
+                           and type P.T.rexp = Emitter.S.P.T.rexp
+                           and type P.T.stm = Emitter.S.P.T.stm
+     structure Jumps   : SDI_JUMPS (* where I = CFG.I *)
+                         where type I.addressing_mode = CFG.I.addressing_mode
+                           and type I.ea = CFG.I.ea
+                           and type I.instr = CFG.I.instr
+                           and type I.instruction = CFG.I.instruction
+                           and type I.operand = CFG.I.operand
+     structure Props   : INSN_PROPERTIES (* where I = CFG.I *)
+                         where type I.addressing_mode = CFG.I.addressing_mode
+                           and type I.ea = CFG.I.ea
+                           and type I.instr = CFG.I.instr
+                           and type I.instruction = CFG.I.instruction
+                           and type I.operand = CFG.I.operand
     ) = 
 struct
 
diff --git a/backpatch/sdi-jumps.sig b/backpatch/sdi-jumps.sig
index d06e456..f63b5b7 100644
--- a/backpatch/sdi-jumps.sig
+++ b/backpatch/sdi-jumps.sig
@@ -7,7 +7,7 @@
 signature SDI_JUMPS = sig
   structure I : INSTRUCTIONS
   structure C : CELLS
-    sharing I.C = C
+    (* sharing I.C = C *)
 
   val branchDelayedArch : bool
 
diff --git a/backpatch/spanDep.sml b/backpatch/spanDep.sml
index c26b29a..a665b9c 100644
--- a/backpatch/spanDep.sml
+++ b/backpatch/spanDep.sml
@@ -9,18 +9,79 @@
 
 functor SpanDependencyResolution
     (structure Emitter   : INSTRUCTION_EMITTER
-     structure CFG       : CONTROL_FLOW_GRAPH
-                             where I = Emitter.I
-                          and P = Emitter.S.P
-     structure Jumps     : SDI_JUMPS
-                             where I = CFG.I
-     structure DelaySlot : DELAY_SLOT_PROPERTIES
-                             where I = CFG.I
-     structure Props     : INSN_PROPERTIES
-                             where I = CFG.I
-     structure Asm        : INSTRUCTION_EMITTER
-                             where I = CFG.I
-                             and   S = Emitter.S
+     structure CFG       : CONTROL_FLOW_GRAPH (* where I = Emitter.I and P = Emitter.S.P *)
+                           where type I.addressing_mode = Emitter.I.addressing_mode
+                             and type I.ea = Emitter.I.ea
+                             and type I.instr = Emitter.I.instr
+                             and type I.instruction = Emitter.I.instruction
+                             and type I.operand = Emitter.I.operand
+                           where type P.Client.pseudo_op = Emitter.S.P.Client.pseudo_op
+                             and type P.T.Basis.cond = Emitter.S.P.T.Basis.cond
+                             and type P.T.Basis.div_rounding_mode = Emitter.S.P.T.Basis.div_rounding_mode
+                             and type P.T.Basis.ext = Emitter.S.P.T.Basis.ext
+                             and type P.T.Basis.fcond = Emitter.S.P.T.Basis.fcond
+                             and type P.T.Basis.rounding_mode = Emitter.S.P.T.Basis.rounding_mode
+                             and type P.T.Constant.const = Emitter.S.P.T.Constant.const
+                             and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.ccx
+                             and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.fx
+                             and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.rx
+                             and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.sx
+                             and type P.T.I.div_rounding_mode = Emitter.S.P.T.I.div_rounding_mode
+                             and type P.T.Region.region = Emitter.S.P.T.Region.region
+                             and type P.T.ccexp = Emitter.S.P.T.ccexp
+                             and type P.T.fexp = Emitter.S.P.T.fexp
+                             (* and type P.T.labexp = Emitter.S.P.T.labexp *)
+                             and type P.T.mlrisc = Emitter.S.P.T.mlrisc
+                             and type P.T.oper = Emitter.S.P.T.oper
+                             and type P.T.rep = Emitter.S.P.T.rep
+                             and type P.T.rexp = Emitter.S.P.T.rexp
+                             and type P.T.stm = Emitter.S.P.T.stm
+     structure Jumps     : SDI_JUMPS (* where I = CFG.I *)
+                           where type I.addressing_mode = CFG.I.addressing_mode
+                             and type I.ea = CFG.I.ea
+                             and type I.instr = CFG.I.instr
+                             and type I.instruction = CFG.I.instruction
+                             and type I.operand = CFG.I.operand
+     structure DelaySlot : DELAY_SLOT_PROPERTIES (* where I = CFG.I *)
+                           where type I.addressing_mode = CFG.I.addressing_mode
+                             and type I.ea = CFG.I.ea
+                             and type I.instr = CFG.I.instr
+                             and type I.instruction = CFG.I.instruction
+                             and type I.operand = CFG.I.operand
+     structure Props     : INSN_PROPERTIES (* where I = CFG.I *)
+                           where type I.addressing_mode = CFG.I.addressing_mode
+                             and type I.ea = CFG.I.ea
+                             and type I.instr = CFG.I.instr
+                             and type I.instruction = CFG.I.instruction
+                             and type I.operand = CFG.I.operand
+     structure Asm       : INSTRUCTION_EMITTER (* where I = CFG.I and S = Emitter.S *)
+                           where type I.addressing_mode = CFG.I.addressing_mode
+                             and type I.ea = CFG.I.ea
+                             and type I.instr = CFG.I.instr
+                             and type I.instruction = CFG.I.instruction
+                             and type I.operand = CFG.I.operand
+                           where type S.P.Client.pseudo_op = Emitter.S.P.Client.pseudo_op
+                             and type S.P.T.Basis.cond = Emitter.S.P.T.Basis.cond
+                             and type S.P.T.Basis.div_rounding_mode = Emitter.S.P.T.Basis.div_rounding_mode
+                             and type S.P.T.Basis.ext = Emitter.S.P.T.Basis.ext
+                             and type S.P.T.Basis.fcond = Emitter.S.P.T.Basis.fcond
+                             and type S.P.T.Basis.rounding_mode = Emitter.S.P.T.Basis.rounding_mode
+                             and type S.P.T.Constant.const = Emitter.S.P.T.Constant.const
+                             and type ('s,'r,'f,'c) S.P.T.Extension.ccx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.ccx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.fx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.fx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.rx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.rx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.sx = ('s,'r,'f,'c) Emitter.S.P.T.Extension.sx
+                             and type S.P.T.I.div_rounding_mode = Emitter.S.P.T.I.div_rounding_mode
+                             and type S.P.T.Region.region = Emitter.S.P.T.Region.region
+                             and type S.P.T.ccexp = Emitter.S.P.T.ccexp
+                             and type S.P.T.fexp = Emitter.S.P.T.fexp
+                             (* and type S.P.T.labexp = Emitter.S.P.T.labexp *)
+                             and type S.P.T.mlrisc = Emitter.S.P.T.mlrisc
+                             and type S.P.T.oper = Emitter.S.P.T.oper
+                             and type S.P.T.rep = Emitter.S.P.T.rep
+                             and type S.P.T.rexp = Emitter.S.P.T.rexp
+                             and type S.P.T.stm = Emitter.S.P.T.stm
+                             and type ('a,'b,'c,'d) S.stream = ('a,'b,'c,'d) Emitter.S.stream
      ) : BBSCHED = 
 struct
 
@@ -275,7 +336,9 @@ struct
 
               and eliminateNop(jmp) = 
                   case (nop,nOn) of
-                     (true,(D.D_FALLTHRU | D.D_NONE)) =>
+                     (true,D.D_FALLTHRU) =>
+                          D.enableDelaySlot{n=true,nop=false,instr=jmp}
+                  |  (true,D.D_NONE) =>
                           D.enableDelaySlot{n=true,nop=false,instr=jmp}
                   |  _ => jmp
 
diff --git a/backpatch/vlBackPatch.sml b/backpatch/vlBackPatch.sml
index 78f639a..3366e4c 100644
--- a/backpatch/vlBackPatch.sml
+++ b/backpatch/vlBackPatch.sml
@@ -26,14 +26,31 @@
 functor BackPatch
   (structure CodeString : CODE_STRING
    structure Jumps      : SDI_JUMPS 
-   structure Props      : INSN_PROPERTIES 
-                        where I = Jumps.I
-   structure Emitter    : MC_EMIT
-                        where I = Props.I
-   structure CFG        : CONTROL_FLOW_GRAPH
-                        where I = Emitter.I
-   structure Asm        : INSTRUCTION_EMITTER
-                        where I = CFG.I) =
+   structure Props      : INSN_PROPERTIES (* where I = Jumps.I *)
+                          where type I.addressing_mode = Jumps.I.addressing_mode
+                            and type I.ea = Jumps.I.ea
+                            and type I.instr = Jumps.I.instr
+                            and type I.instruction = Jumps.I.instruction
+                            and type I.operand = Jumps.I.operand
+   structure Emitter    : MC_EMIT (* where I = Props.I *)
+                          where type I.addressing_mode = Props.I.addressing_mode
+                            and type I.ea = Props.I.ea
+                            and type I.instr = Props.I.instr
+                            and type I.instruction = Props.I.instruction
+                            and type I.operand = Props.I.operand
+   structure CFG        : CONTROL_FLOW_GRAPH (* where I = Emitter.I *)
+                          where type I.addressing_mode = Emitter.I.addressing_mode
+                            and type I.ea = Emitter.I.ea
+                            and type I.instr = Emitter.I.instr
+                            and type I.instruction = Emitter.I.instruction
+                            and type I.operand = Emitter.I.operand
+   structure Asm        : INSTRUCTION_EMITTER (* where I = CFG.I *)
+                          where type I.addressing_mode = CFG.I.addressing_mode
+                            and type I.ea = CFG.I.ea
+                            and type I.instr = CFG.I.instr
+                            and type I.instruction = CFG.I.instruction
+                            and type I.operand = CFG.I.operand
+  ) =
 struct 
   structure I   = Jumps.I
   structure C   = I.C
diff --git a/block-placement/block-placement.sml b/block-placement/block-placement.sml
index 702f584..6066578 100644
--- a/block-placement/block-placement.sml
+++ b/block-placement/block-placement.sml
@@ -5,10 +5,13 @@
 
 functor BlockPlacement 
    (structure CFG : CONTROL_FLOW_GRAPH
-    structure Props : INSN_PROPERTIES
-	where I = CFG.I)
-
-   : BLOCK_PLACEMENT =
+    structure Props : INSN_PROPERTIES (* where I = CFG.I *)
+                      where type I.addressing_mode = CFG.I.addressing_mode
+                        and type I.ea = CFG.I.ea
+                        and type I.instr = CFG.I.instr
+                        and type I.instruction = CFG.I.instruction
+                        and type I.operand = CFG.I.operand
+   ) : BLOCK_PLACEMENT =
 
 struct
   structure CFG = CFG
diff --git a/block-placement/check-placement-fn.sml b/block-placement/check-placement-fn.sml
index 6eae5d7..4c4aeff 100644
--- a/block-placement/check-placement-fn.sml
+++ b/block-placement/check-placement-fn.sml
@@ -9,8 +9,12 @@
 functor CheckPlacementFn (
 
     structure CFG : CONTROL_FLOW_GRAPH
-    structure InsnProps : INSN_PROPERTIES
-      where I = CFG.I
+    structure InsnProps : INSN_PROPERTIES (* where I = CFG.I *)
+                          where type I.addressing_mode = CFG.I.addressing_mode
+                            and type I.ea = CFG.I.ea
+                            and type I.instr = CFG.I.instr
+                            and type I.instruction = CFG.I.instruction
+                            and type I.operand = CFG.I.operand
 
   ) : sig
 
@@ -81,7 +85,11 @@ functor CheckPlacementFn (
 		(* end case *))
 	(* check that FALLSTHRU and BRANCH false edges connect adjacent nodes *)
 	  fun chkEdge (src, dst, CFG.EDGE{k, ...}) = (case k
-		 of (CFG.FALLSTHRU | CFG.BRANCH false) =>
+		 of CFG.FALLSTHRU =>
+		      if adjacentNodes(src, dst)
+			then ()
+			else reportNotAdjacent(src, dst)
+		  | CFG.BRANCH false =>
 		      if adjacentNodes(src, dst)
 			then ()
 			else reportNotAdjacent(src, dst)
diff --git a/block-placement/jump-chain-elim-fn.sml b/block-placement/jump-chain-elim-fn.sml
index 678da26..ceb242f 100644
--- a/block-placement/jump-chain-elim-fn.sml
+++ b/block-placement/jump-chain-elim-fn.sml
@@ -12,8 +12,12 @@
 functor JumpChainElimFn (
 
     structure CFG : CONTROL_FLOW_GRAPH
-    structure InsnProps : INSN_PROPERTIES
-      where I = CFG.I
+    structure InsnProps : INSN_PROPERTIES (* where I = CFG.I *)
+                          where type I.addressing_mode = CFG.I.addressing_mode
+                            and type I.ea = CFG.I.ea
+                            and type I.instr = CFG.I.instr
+                            and type I.instruction = CFG.I.instruction
+                            and type I.operand = CFG.I.operand
 
   (* Control flag that when set true allows jumps to labels outside
    * of the CFG to be chained.  Set this false when there are many
diff --git a/block-placement/weighted-block-placement-fn.sml b/block-placement/weighted-block-placement-fn.sml
index 4668215..1f7a704 100644
--- a/block-placement/weighted-block-placement-fn.sml
+++ b/block-placement/weighted-block-placement-fn.sml
@@ -12,8 +12,12 @@
 functor WeightedBlockPlacementFn (
 
     structure CFG : CONTROL_FLOW_GRAPH
-    structure InsnProps : INSN_PROPERTIES
-      where I = CFG.I
+    structure InsnProps : INSN_PROPERTIES (* where I = CFG.I *)
+                          where type I.addressing_mode = CFG.I.addressing_mode
+                            and type I.ea = CFG.I.ea
+                            and type I.instr = CFG.I.instr
+                            and type I.instruction = CFG.I.instruction
+                            and type I.operand = CFG.I.operand
 
   ) : BLOCK_PLACEMENT = struct
 
diff --git a/c-call/archs/sparc-c-call-fn.sml b/c-call/archs/sparc-c-call-fn.sml
index eff4c31..db08cfe 100644
--- a/c-call/archs/sparc-c-call-fn.sml
+++ b/c-call/archs/sparc-c-call-fn.sml
@@ -77,18 +77,25 @@ functor SparcCCallFn (
 		      structure SA = SA)
 
   (* assign a C type to a kind of machine location *)
-    fun kindOfCTy (CTy.C_float | CTy.C_double | CTy.C_long_double) = FPR
-      | kindOfCTy (CTy.C_unsigned _ | CTy.C_signed _ | CTy.C_PTR | 
-		   CTy.C_ARRAY _ | CTy.C_STRUCT _ | CTy.C_UNION _) = GPR
+    fun kindOfCTy (CTy.C_float) = FPR
+      | kindOfCTy (CTy.C_double) = FPR
+      | kindOfCTy (CTy.C_long_double) = FPR
+      | kindOfCTy (CTy.C_unsigned _) = GPR
+      | kindOfCTy (CTy.C_signed _) = GPR
+      | kindOfCTy (CTy.C_PTR) = GPR
+      | kindOfCTy (CTy.C_ARRAY _) = GPR
+      | kindOfCTy (CTy.C_STRUCT _) = GPR
+      | kindOfCTy (CTy.C_UNION _) = GPR
 
   (* takes a C type and a request for passing values of that type *)
     fun cTyToReq cTy = let
 	  val {sz, align} = SparcCSizes.sizeOfTy cTy
           in
 	    case cTy
-	     of (CTy.C_STRUCT _ | CTy.C_UNION _) => (32, kindOfCTy cTy, align)
-	      | (CTy.C_unsigned CTy.I_long_long |
-		 CTy.C_signed CTy.I_long_long   ) => raise Fail "todo"
+	     of (CTy.C_STRUCT _) => (32, kindOfCTy cTy, align)
+	      | (CTy.C_UNION _) => (32, kindOfCTy cTy, align)
+	      | (CTy.C_unsigned CTy.I_long_long) => raise Fail "todo"
+	      | (CTy.C_signed CTy.I_long_long) => raise Fail "todo"
 	      | _ => (sz * 8, kindOfCTy cTy, align)
 	  end
 
@@ -135,7 +142,11 @@ functor SparcCCallFn (
         (* bytes to allocate on the stack for returning structs *)
 	  val res_szal =
 	    case retTy of
-		(Ty.C_long_double | Ty.C_STRUCT _ | Ty.C_UNION _) =>
+		(Ty.C_long_double) =>
+		  SOME (SparcCSizes.sizeOfTy retTy)
+              | (Ty.C_STRUCT _) =>
+		  SOME (SparcCSizes.sizeOfTy retTy)
+	      | (Ty.C_UNION _) =>
 		  SOME (SparcCSizes.sizeOfTy retTy)
 	      | _ => NONE
 
diff --git a/c-call/archs/sparc-c-sizes.sml b/c-call/archs/sparc-c-sizes.sml
index 78e55d4..af1807d 100644
--- a/c-call/archs/sparc-c-sizes.sml
+++ b/c-call/archs/sparc-c-sizes.sml
@@ -6,15 +6,21 @@ structure SparcCSizes =
     fun roundup (i, a) = a * ((i + a - 1) div a)
 
   (* calculate size and alignment for a C type *)
-    fun sizeOfTy (Ty.C_void | Ty.C_float | Ty.C_PTR |
-	      Ty.C_signed (Ty.I_int | Ty.I_long) |
-	      Ty.C_unsigned (Ty.I_int | Ty.I_long)) = {sz=4, align=4}
-      | sizeOfTy (Ty.C_double |
-	      Ty.C_signed Ty.I_long_long |
-	      Ty.C_unsigned Ty.I_long_long) = {sz=8, align=8}
+    fun sizeOfTy (Ty.C_void) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_float) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_PTR) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_signed (Ty.I_int)) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_signed (Ty.I_long)) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_unsigned (Ty.I_int)) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_unsigned (Ty.I_long)) = {sz=4, align=4}
+      | sizeOfTy (Ty.C_double) = {sz=8, align=8}
+      | sizeOfTy (Ty.C_signed Ty.I_long_long) = {sz=8, align=8}
+      | sizeOfTy (Ty.C_unsigned Ty.I_long_long) = {sz=8, align=8}
       | sizeOfTy (Ty.C_long_double) = {sz=16, align=8}
-      | sizeOfTy (Ty.C_signed Ty.I_char | Ty.C_unsigned Ty.I_char) = {sz=1, align=1}
-      | sizeOfTy (Ty.C_signed Ty.I_short | Ty.C_unsigned Ty.I_short) = {sz=2, align=2}
+      | sizeOfTy (Ty.C_signed Ty.I_char) = {sz=1, align=1}
+      | sizeOfTy (Ty.C_unsigned Ty.I_char) = {sz=1, align=1}
+      | sizeOfTy (Ty.C_signed Ty.I_short) = {sz=2, align=2}
+      | sizeOfTy (Ty.C_unsigned Ty.I_short) = {sz=2, align=2}
       | sizeOfTy (Ty.C_ARRAY (t, n)) = let val {sz=s, align=a} = sizeOfTy t in {sz=n * s, align=a} end
       | sizeOfTy (Ty.C_STRUCT l) =
 	let (* i: next free memory address (relative to struct start);
diff --git a/c-call/archs/x86-64-svid-fn.sml b/c-call/archs/x86-64-svid-fn.sml
index 96f29f9..8bd5790 100644
--- a/c-call/archs/x86-64-svid-fn.sml
+++ b/c-call/archs/x86-64-svid-fn.sml
@@ -75,7 +75,7 @@ functor X86_64SVIDFn (
     val calleeSaveRegs = [C.rbx, C.r12, C.r13, C.r14, C.r15]
     val callerSaveRegs =  [C.rax, C.rcx, C.rdx, C.rsi, C.rdi, C.r8, C.r9, C.r10, C.r11]
     val callerSaveFRegs = (C.Regs CB.FP {from=0, to=15, step=1})
-    val calleeSaveFRegs = []
+    val calleeSaveFRegs : T.reg list = []
 			  
     val frameAlignB = 16
 
@@ -102,9 +102,15 @@ functor X86_64SVIDFn (
     fun eightBytesOfCTy cTy = eightBytesOfCTys (CType.flattenCTy cTy, [], [])
 
   (* classify a C type into its location kind (assuming that aggregates cannot be passed in registers) *)
-    fun kindOfCTy (CTy.C_float | CTy.C_double | CTy.C_long_double) = FPR
-      | kindOfCTy (CTy.C_ARRAY _ | CTy.C_STRUCT _ | CTy.C_UNION _) = raise Fail "impossible"
-      | kindOfCTy (CTy.C_unsigned _ | CTy.C_signed _ | CTy.C_PTR) = GPR
+    fun kindOfCTy (CTy.C_float) = FPR
+      | kindOfCTy (CTy.C_double) = FPR
+      | kindOfCTy (CTy.C_long_double) = FPR
+      | kindOfCTy (CTy.C_ARRAY _) = raise Fail "impossible"
+      | kindOfCTy (CTy.C_STRUCT _) = raise Fail "impossible"
+      | kindOfCTy (CTy.C_UNION _) = raise Fail "impossible"
+      | kindOfCTy (CTy.C_unsigned _) = GPR
+      | kindOfCTy (CTy.C_signed _) = GPR
+      | kindOfCTy (CTy.C_PTR) = GPR
 
     fun combineKinds (k1, k2) = if (k1 = k2)
 	then k1
@@ -128,11 +134,20 @@ functor X86_64SVIDFn (
 	   end
 
     fun containsUnalignedFields cTy = (case cTy
-        of (CTy.C_STRUCT cTys | CTy.C_UNION cTys) => List.exists containsUnalignedFields cTys
+        of (CTy.C_STRUCT cTys) => List.exists containsUnalignedFields cTys
+         | (CTy.C_UNION cTys) => List.exists containsUnalignedFields cTys
 	 | cTy => Int.max(8, szBOfCTy cTy) mod 8 <> 0
         (* end case *))
 
-    fun reqsOfCTy (cTy as (CTy.C_STRUCT _ | CTy.C_UNION _ | CTy.C_ARRAY _)) = 
+    fun reqsOfCTy (cTy as (CTy.C_STRUCT _)) =
+	   if (szBOfCTy cTy > 2*8 orelse containsUnalignedFields cTy)
+	      then List.tabulate (szBOfCTy cTy div 8, fn _ => (8*8, STK, 8))
+	      else List.map (fn eb => (8*8, kindOfEightByte eb, 8)) (eightBytesOfCTy cTy)
+      | reqsOfCTy (cTy as (CTy.C_UNION _)) =
+	   if (szBOfCTy cTy > 2*8 orelse containsUnalignedFields cTy)
+	      then List.tabulate (szBOfCTy cTy div 8, fn _ => (8*8, STK, 8))
+	      else List.map (fn eb => (8*8, kindOfEightByte eb, 8)) (eightBytesOfCTy cTy)
+      | reqsOfCTy (cTy as (CTy.C_ARRAY _)) =
 	   if (szBOfCTy cTy > 2*8 orelse containsUnalignedFields cTy)
 	      then List.tabulate (szBOfCTy cTy div 8, fn _ => (8*8, STK, 8))
 	      else List.map (fn eb => (8*8, kindOfEightByte eb, 8)) (eightBytesOfCTy cTy)
diff --git a/c-call/archs/x86-svid-fn.sml b/c-call/archs/x86-svid-fn.sml
index 49e5add..b1d362e 100644
--- a/c-call/archs/x86-svid-fn.sml
+++ b/c-call/archs/x86-svid-fn.sml
@@ -68,8 +68,13 @@ functor X86SVIDFn (
     val callerSaveFRegs = []
 
   (* assign a C type to a kind of machine location *)
-    fun kindOfCTy (CTy.C_float | CTy.C_double | CTy.C_long_double) = FPR
-      | kindOfCTy (CTy.C_unsigned _ | CTy.C_signed _ | CTy.C_PTR | CTy.C_ARRAY _) = GPR
+    fun kindOfCTy (CTy.C_float) = FPR
+      | kindOfCTy (CTy.C_double) = FPR
+      | kindOfCTy (CTy.C_long_double) = FPR
+      | kindOfCTy (CTy.C_unsigned _) = GPR
+      | kindOfCTy (CTy.C_signed _) = GPR
+      | kindOfCTy (CTy.C_PTR) = GPR
+      | kindOfCTy (CTy.C_ARRAY _) = GPR
 
     (* convert a C type to reqs for staged allocation *)
     fun cTyToReqs cTy = let
@@ -86,8 +91,11 @@ functor X86SVIDFn (
               else if (sz <= 8)
                  then [(8, GPR, align), (8, GPR, align)]
               else reqs
-	    | ( (CTy.C_unsigned CTy.I_long_long |
-		 CTy.C_signed CTy.I_long_long   ),
+	    | ( (CTy.C_unsigned CTy.I_long_long),
+		_ ) =>
+	      (* 64-bit integers are returned in GPRs *)
+	      [(8, GPR, align), (8, GPR, align)]
+	    | ( (CTy.C_signed CTy.I_long_long),
 		_ ) => 
 	      (* 64-bit integers are returned in GPRs *)
 	      [(8, GPR, align), (8, GPR, align)]
@@ -202,7 +210,8 @@ functor X86SVIDFn (
 	 * differences there might be between the SVID and Windows ABIs. (JHR)
 	 *)
 	  val calleePops = (case #conv proto
-		 of (""|"ccall") => false
+		 of ("") => false
+                  | ("ccall") => false
 		  | "stdcall" => true
 		  | conv => raise Fail (concat [
 			"unknown calling convention \"", String.toString conv, "\""
diff --git a/c-call/gen/c-call-gen-fn.sml b/c-call/gen/c-call-gen-fn.sml
index f39eece..17153d4 100644
--- a/c-call/gen/c-call-gen-fn.sml
+++ b/c-call/gen/c-call-gen-fn.sml
@@ -91,10 +91,22 @@ functor CCallGenFn (
      *)
     fun writeLoc arg (off, loc, stms) = (
 	  case (arg, loc)
-	   of (ARG (e as T.REG _), SA.BLOCK_OFFSET(w, (K.GPR | K.STK), offset)) =>
+	   of (ARG (e as T.REG _), SA.BLOCK_OFFSET(w, (K.GPR), offset)) =>
 	      (* register to stack (gpr) *)
 	      T.STORE(wordTy, offSp offset, e, stack) :: stms
-	    | (ARG (e as T.REG _), SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR | K.STK), offset), w', (K.GPR | K.STK))) =>
+	    | (ARG (e as T.REG _), SA.BLOCK_OFFSET(w, (K.STK), offset)) =>
+	      (* register to stack (gpr) *)
+	      T.STORE(wordTy, offSp offset, e, stack) :: stms
+	    | (ARG (e as T.REG _), SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR), offset), w', (K.GPR))) =>
+	      (* register to stack with width conversion (gpr) *)
+	      T.STORE(w, offSp offset, sx{fromWidth=w', toWidth=w, e=e}, stack) :: stms
+	    | (ARG (e as T.REG _), SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR), offset), w', (K.STK))) =>
+	      (* register to stack with width conversion (gpr) *)
+	      T.STORE(w, offSp offset, sx{fromWidth=w', toWidth=w, e=e}, stack) :: stms
+	    | (ARG (e as T.REG _), SA.NARROW(SA.BLOCK_OFFSET(w, (K.STK), offset), w', (K.GPR))) =>
+	      (* register to stack with width conversion (gpr) *)
+	      T.STORE(w, offSp offset, sx{fromWidth=w', toWidth=w, e=e}, stack) :: stms
+	    | (ARG (e as T.REG _), SA.NARROW(SA.BLOCK_OFFSET(w, (K.STK), offset), w', (K.STK))) =>
 	      (* register to stack with width conversion (gpr) *)
 	      T.STORE(w, offSp offset, sx{fromWidth=w', toWidth=w, e=e}, stack) :: stms
 	    | (ARG (T.LOAD (ty, e, rgn)), SA.REG (w, K.GPR, r)) =>
@@ -109,33 +121,62 @@ functor CCallGenFn (
 	    | (ARG e, SA.NARROW (SA.REG(w, K.GPR, r), w', K.GPR)) => 
 	      (* expression to register with conversion *)
 	      copyToReg(w, r, sx{fromWidth=w', toWidth=w, e=e}) @ stms
-	    | (ARG (T.LOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.GPR | K.STK), offset)) => let
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.GPR), offset)) => let
 	      (* memory to stack (gpr) *)
 		val tmp = C.newReg ()
 	        in
 		  T.STORE (ty, offSp offset, T.REG (ty, tmp), stack) :: 
 		  T.MV (ty, tmp, T.LOAD (ty, T.ADD(wordTy, e, off), rgn)) :: stms
 	        end
-	    | (ARG (T.LOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR | K.STK), offset), w', K.GPR)) => let
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.STK), offset)) => let
+	      (* memory to stack (gpr) *)
+		val tmp = C.newReg ()
+	        in
+		  T.STORE (ty, offSp offset, T.REG (ty, tmp), stack) ::
+		  T.MV (ty, tmp, T.LOAD (ty, T.ADD(wordTy, e, off), rgn)) :: stms
+	        end
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR), offset), w', K.GPR)) => let
 	      (* memory to stack with conversion (gpr) *)
 		val tmp = C.newReg ()
 	        in
 		  T.STORE (w, offSp offset, T.REG (w, tmp), stack) :: 
 		  T.MV (w, tmp, sx{fromWidth=w', toWidth=w, e=T.LOAD (w', T.ADD(wordTy, e, off), rgn)}) :: stms
 	        end
-	    | (ARG e, SA.BLOCK_OFFSET(w, (K.GPR | K.STK), offset)) => let
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.STK), offset), w', K.GPR)) => let
+	      (* memory to stack with conversion (gpr) *)
+		val tmp = C.newReg ()
+	        in
+		  T.STORE (w, offSp offset, T.REG (w, tmp), stack) ::
+		  T.MV (w, tmp, sx{fromWidth=w', toWidth=w, e=T.LOAD (w', T.ADD(wordTy, e, off), rgn)}) :: stms
+	        end
+	    | (ARG e, SA.BLOCK_OFFSET(w, (K.GPR), offset)) => let
 	      (* expression to stack (gpr) *)
 		val tmp = C.newReg ()
 	        in
 		  T.STORE (w, offSp offset, T.REG (w, tmp), stack) :: T.MV (w, tmp, e) :: stms
 	        end
-	    | (ARG e, SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR | K.STK), offset), w', K.GPR)) => let
+	    | (ARG e, SA.BLOCK_OFFSET(w, (K.STK), offset)) => let
+	      (* expression to stack (gpr) *)
+		val tmp = C.newReg ()
+	        in
+		  T.STORE (w, offSp offset, T.REG (w, tmp), stack) :: T.MV (w, tmp, e) :: stms
+	        end
+	    | (ARG e, SA.NARROW(SA.BLOCK_OFFSET(w, (K.GPR), offset), w', K.GPR)) => let
+	      (* expression to stack with conversion (gpr) *)
+		val tmp = C.newReg ()
+	        in
+		  T.STORE (w, offSp offset, T.REG (w, tmp), stack) :: T.MV (w, tmp, sx{fromWidth=w', toWidth=w, e=e}) :: stms
+	        end
+	    | (ARG e, SA.NARROW(SA.BLOCK_OFFSET(w, (K.STK), offset), w', K.GPR)) => let
 	      (* expression to stack with conversion (gpr) *)
 		val tmp = C.newReg ()
 	        in
 		  T.STORE (w, offSp offset, T.REG (w, tmp), stack) :: T.MV (w, tmp, sx{fromWidth=w', toWidth=w, e=e}) :: stms
 	        end
-	    | (FARG (e as T.FREG _), SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset)) =>
+	    | (FARG (e as T.FREG _), SA.BLOCK_OFFSET(w, (K.FPR), offset)) =>
+	      (* register to stack (fpr) *)
+	      T.FSTORE (w, offSp offset, e, stack) :: stms
+	    | (FARG (e as T.FREG _), SA.BLOCK_OFFSET(w, (K.FSTK), offset)) =>
 	      (* register to stack (fpr) *)
 	      T.FSTORE (w, offSp offset, e, stack) :: stms
 	    | (FARG e, SA.REG(w, K.FPR, r)) => 
@@ -147,41 +188,81 @@ functor CCallGenFn (
 	    | (ARG (T.LOAD (ty, e, rgn)), SA.REG(w, K.FPR, r)) =>
 	      (* memory to register (fpr) *)
 	      copyToFReg(w, r, T.FLOAD (ty, T.ADD(wordTy, e, off), rgn)) @ stms
-	    | (ARG (T.LOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset)) => let
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.FPR), offset)) => let
+              (* memory to stack (fpr) *)
+		val tmp = C.newFreg ()
+	        in
+		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) ::
+		  T.FMV (w, tmp, T.FLOAD (ty, T.ADD(wordTy, e, off), rgn)) :: stms
+	        end
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.FSTK), offset)) => let
               (* memory to stack (fpr) *)
 		val tmp = C.newFreg ()
 	        in
 		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) :: 
 		  T.FMV (w, tmp, T.FLOAD (ty, T.ADD(wordTy, e, off), rgn)) :: stms
 	        end
-	    | (ARG (T.LOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset), w', K.FPR)) => let
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.FPR), offset), w', K.FPR)) => let
               (* memory to stack with conversion (fpr) *)
 		val tmp = C.newFreg ()
 	        in
 		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) :: 
 		  T.FMV (w', tmp, f2f{fromWidth=w, toWidth=w', e=T.FLOAD (w', T.ADD(wordTy, e, off), rgn)}) :: stms
 	        end
-	    | (FARG (T.FLOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset)) => let
+	    | (ARG (T.LOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.FSTK), offset), w', K.FPR)) => let
+              (* memory to stack with conversion (fpr) *)
+		val tmp = C.newFreg ()
+	        in
+		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) ::
+		  T.FMV (w', tmp, f2f{fromWidth=w, toWidth=w', e=T.FLOAD (w', T.ADD(wordTy, e, off), rgn)}) :: stms
+	        end
+	    | (FARG (T.FLOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.FSTK), offset)) => let
+              (* memory to stack (fpr) *)
+		val tmp = C.newFreg ()
+	        in
+		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) ::
+		  T.FMV (w, tmp, T.FLOAD (w, T.ADD(wordTy, e, off), rgn)) :: stms
+	        end
+	    | (FARG (T.FLOAD (ty, e, rgn)), SA.BLOCK_OFFSET(w, (K.FPR), offset)) => let
               (* memory to stack (fpr) *)
 		val tmp = C.newFreg ()
 	        in
 		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) :: 
 		  T.FMV (w, tmp, T.FLOAD (w, T.ADD(wordTy, e, off), rgn)) :: stms
 	        end
-	    | (FARG (T.FLOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset), w', K.FPR)) => let
+	    | (FARG (T.FLOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.FPR), offset), w', K.FPR)) => let
               (* memory to stack with conversion (fpr) *)
 		val tmp = C.newFreg ()
 	        in
 		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) :: 
 		  T.FMV (w', tmp, f2f{fromWidth=w, toWidth=w', e=T.FLOAD (w, T.ADD(wordTy, e, off), rgn)}) :: stms
 	        end
-	    | (FARG e, SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset)) => let
+	    | (FARG (T.FLOAD (ty, e, rgn)), SA.NARROW(SA.BLOCK_OFFSET(w, (K.FSTK), offset), w', K.FPR)) => let
+              (* memory to stack with conversion (fpr) *)
+		val tmp = C.newFreg ()
+	        in
+		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) ::
+		  T.FMV (w', tmp, f2f{fromWidth=w, toWidth=w', e=T.FLOAD (w, T.ADD(wordTy, e, off), rgn)}) :: stms
+	        end
+	    | (FARG e, SA.BLOCK_OFFSET(w, (K.FPR), offset)) => let
+              (* expression to stack (fpr) *)
+		val tmp = C.newFreg ()
+	        in
+		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) :: T.FMV (w, tmp, e) :: stms
+	        end
+	    | (FARG e, SA.BLOCK_OFFSET(w, (K.FSTK), offset)) => let
               (* expression to stack (fpr) *)
 		val tmp = C.newFreg ()
 	        in
 		  T.FSTORE (w, offSp offset, T.FREG (w, tmp), stack) :: T.FMV (w, tmp, e) :: stms
 	        end
-	    | (FARG e, SA.NARROW(SA.BLOCK_OFFSET(w, (K.FPR | K.FSTK), offset), w', K.FPR)) => let
+	    | (FARG e, SA.NARROW(SA.BLOCK_OFFSET(w, (K.FPR), offset), w', K.FPR)) => let
+              (* expression to stack (fpr) *)
+		val tmp = C.newFreg ()
+	        in
+		  T.FSTORE (w', offSp offset, f2f{fromWidth=w, toWidth=w', e=T.FREG (w, tmp)}, stack) :: T.FMV (w, tmp, e) :: stms
+	        end
+	    | (FARG e, SA.NARROW(SA.BLOCK_OFFSET(w, (K.FSTK), offset), w', K.FPR)) => let
               (* expression to stack (fpr) *)
 		val tmp = C.newFreg ()
 	        in
diff --git a/c-call/gen/c-call-sig.sml b/c-call/gen/c-call-sig.sml
index 35718b0..9d07716 100644
--- a/c-call/gen/c-call-sig.sml
+++ b/c-call/gen/c-call-sig.sml
@@ -3,7 +3,27 @@ signature C_CALL =
 
     structure T : MLTREE
     structure Gen : C_CALL_GEN
-      where T = T
+      (* where T = T *)
+      where type T.Basis.cond = T.Basis.cond
+        and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+        and type T.Basis.ext = T.Basis.ext
+        and type T.Basis.fcond = T.Basis.fcond
+        and type T.Basis.rounding_mode = T.Basis.rounding_mode
+        and type T.Constant.const = T.Constant.const
+        and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+        and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+        and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+        and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+        and type T.I.div_rounding_mode = T.I.div_rounding_mode
+        and type T.Region.region = T.Region.region
+        and type T.ccexp = T.ccexp
+        and type T.fexp = T.fexp
+        (* and type T.labexp = T.labexp *)
+        and type T.mlrisc = T.mlrisc
+        and type T.oper = T.oper
+        and type T.rep = T.rep
+        and type T.rexp = T.rexp
+        and type T.stm = T.stm
 
     datatype c_arg = datatype Gen.c_arg
 
diff --git a/c-call/gen/c-type.sml b/c-call/gen/c-type.sml
index b2d716e..684632b 100644
--- a/c-call/gen/c-type.sml
+++ b/c-call/gen/c-type.sml
@@ -42,8 +42,8 @@ structure CType =
 
     (* eliminate aggregates in a C type *)
     fun flattenCTy cTy = (case cTy
-        of (C_STRUCT cTys |
-	    C_UNION cTys ) => List.concat (List.map flattenCTy cTys)
+        of (C_STRUCT cTys ) => List.concat (List.map flattenCTy cTys)
+         | (C_UNION cTys ) => List.concat (List.map flattenCTy cTys)
 	 | C_ARRAY (cTy, n) => List.tabulate (n, fn _ => cTy)
 	 | cTy => [cTy])
 
diff --git a/c-calls/c-types.sml b/c-calls/c-types.sml
index 62cb3fe..a5eaa32 100644
--- a/c-calls/c-types.sml
+++ b/c-calls/c-types.sml
@@ -42,8 +42,8 @@ structure CTypes =
 
     (* eliminate aggregates in a C type *)
     fun flattenCTy cTy = (case cTy
-        of (C_STRUCT cTys |
-	    C_UNION cTys ) => List.concat (List.map flattenCTy cTys)
+        of (C_STRUCT cTys ) => List.concat (List.map flattenCTy cTys)
+	 | (C_UNION cTys ) => List.concat (List.map flattenCTy cTys)
 	 | C_ARRAY (cTy, n) => List.tabulate (n, fn _ => cTy)
 	 | cTy => [cTy])
 
diff --git a/c-calls/unimplemented-c-calls.sml b/c-calls/unimplemented-c-calls.sml
index 507a247..3f6bbc6 100644
--- a/c-calls/unimplemented-c-calls.sml
+++ b/c-calls/unimplemented-c-calls.sml
@@ -6,7 +6,27 @@
  *)
 functor UnimplementedCCallsFn
 	    (structure T: MLTREE
-	     val impossible: string -> 'a) :> C_CALLS where T = T =
+	     val impossible: string -> 'a) :> C_CALLS (* where T = T *)
+                                              where type T.Basis.cond = T.Basis.cond
+                                                and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                                                and type T.Basis.ext = T.Basis.ext
+                                                and type T.Basis.fcond = T.Basis.fcond
+                                                and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                                                and type T.Constant.const = T.Constant.const
+                                                and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                                                and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                                                and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                                                and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                                                and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                                                and type T.Region.region = T.Region.region
+                                                and type T.ccexp = T.ccexp
+                                                and type T.fexp = T.fexp
+                                                (* and type T.labexp = T.labexp *)
+                                                and type T.mlrisc = T.mlrisc
+                                                and type T.oper = T.oper
+                                                and type T.rep = T.rep
+                                                and type T.rexp = T.rexp
+                                                and type T.stm = T.stm =
 struct
     structure T = T
 
diff --git a/cm/proxyLib.cm b/cm/proxyLib.cm
new file mode 100644
index 0000000..72c35c1
--- /dev/null
+++ b/cm/proxyLib.cm
@@ -0,0 +1,61 @@
+Group
+        group(proxyGrp.cm)
+is
+	proxyGrp.cm
+(
+bind:(anchor:ALPHA.cm value:.)
+bind:(anchor:ALPHA-GC.cm value:.)
+bind:(anchor:ALPHA-Peephole.cm value:.)
+bind:(anchor:ALPHA-RTL.cm value:.)
+bind:(anchor:ALPHA-Sched.cm value:.)
+bind:(anchor:ALPHA-SSA.cm value:.)
+bind:(anchor:AMD64.cm value:.)
+bind:(anchor:AMD64-GC.cm value:.)
+bind:(anchor:AMD64-Peephole.cm value:.)
+bind:(anchor:AMD64-RTL.cm value:.)
+bind:(anchor:AMD64-Sched.cm value:.)
+bind:(anchor:AMD64-SSA.cm value:.)
+bind:(anchor:CCall.cm value:.)
+bind:(anchor:CCall-sparc.cm value:.)
+bind:(anchor:CCall-x86-64.cm value:.)
+bind:(anchor:CCall-x86.cm value:.)
+bind:(anchor:Control.cm value:.)
+bind:(anchor:GC.cm value:.)
+bind:(anchor:Graphs.cm value:.)
+bind:(anchor:HPPA.cm value:.)
+bind:(anchor:HPPA-GC.cm value:.)
+bind:(anchor:HPPA-RTL.cm value:.)
+bind:(anchor:HPPA-Sched.cm value:.)
+bind:(anchor:HPPA-SSA.cm value:.)
+bind:(anchor:IA32.cm value:.)
+bind:(anchor:IA32-GC.cm value:.)
+bind:(anchor:IA32-Peephole.cm value:.)
+bind:(anchor:IA32-RTL.cm value:.)
+bind:(anchor:IA32-Sched.cm value:.)
+bind:(anchor:IA32-SSA.cm value:.)
+bind:(anchor:ir-archive.cm value:.)
+bind:(anchor:IR.cm value:.)
+bind:(anchor:Lib.cm value:.)
+bind:(anchor:MIPS.cm value:.)
+bind:(anchor:MLRISC.cm value:.)
+bind:(anchor:MLTREE.cm value:.)
+bind:(anchor:Opt.cm value:.)
+bind:(anchor:Peephole.cm value:.)
+bind:(anchor:PPC.cm value:.)
+bind:(anchor:PPC-GC.cm value:.)
+bind:(anchor:PPC-Sched.cm value:.)
+bind:(anchor:RA.cm value:.)
+bind:(anchor:Region.cm value:.)
+bind:(anchor:RTL.cm value:.)
+bind:(anchor:Sched.cm value:.)
+bind:(anchor:SPARC.cm value:.)
+bind:(anchor:SPARC-GC.cm value:.)
+bind:(anchor:SPARC-Peephole.cm value:.)
+bind:(anchor:SPARC-RTL.cm value:.)
+bind:(anchor:SPARC-Sched.cm value:.)
+bind:(anchor:SPARC-SSA.cm value:.)
+bind:(anchor:SSA.cm value:.)
+bind:(anchor:StagedAlloc.cm value:.)
+bind:(anchor:Visual.cm value:.)
+bind:(anchor:VLIW.cm value:.)
+)
diff --git a/emit/cfgEmit.sml b/emit/cfgEmit.sml
index 4b0393e..6795ba0 100644
--- a/emit/cfgEmit.sml
+++ b/emit/cfgEmit.sml
@@ -13,9 +13,34 @@
 
 functor CFGEmit
   (structure E   : INSTRUCTION_EMITTER
-   structure CFG : CONTROL_FLOW_GRAPH
-		   where I = E.I
-		     and P = E.S.P)  : ASSEMBLY_EMITTER = 
+   structure CFG : CONTROL_FLOW_GRAPH (* where I = E.I and P = E.S.P *)
+                   where type I.addressing_mode = E.I.addressing_mode
+                     and type I.ea = E.I.ea
+                     and type I.instr = E.I.instr
+                     and type I.instruction = E.I.instruction
+                     and type I.operand = E.I.operand
+                   where type P.Client.pseudo_op = E.S.P.Client.pseudo_op
+                     and type P.T.Basis.cond = E.S.P.T.Basis.cond
+                     and type P.T.Basis.div_rounding_mode = E.S.P.T.Basis.div_rounding_mode
+                     and type P.T.Basis.ext = E.S.P.T.Basis.ext
+                     and type P.T.Basis.fcond = E.S.P.T.Basis.fcond
+                     and type P.T.Basis.rounding_mode = E.S.P.T.Basis.rounding_mode
+                     and type P.T.Constant.const = E.S.P.T.Constant.const
+                     and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) E.S.P.T.Extension.ccx
+                     and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) E.S.P.T.Extension.fx
+                     and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) E.S.P.T.Extension.rx
+                     and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) E.S.P.T.Extension.sx
+                     and type P.T.I.div_rounding_mode = E.S.P.T.I.div_rounding_mode
+                     and type P.T.Region.region = E.S.P.T.Region.region
+                     and type P.T.ccexp = E.S.P.T.ccexp
+                     and type P.T.fexp = E.S.P.T.fexp
+                     (* and type P.T.labexp = E.S.P.T.labexp *)
+                     and type P.T.mlrisc = E.S.P.T.mlrisc
+                     and type P.T.oper = E.S.P.T.oper
+                     and type P.T.rep = E.S.P.T.rep
+                     and type P.T.rexp = E.S.P.T.rexp
+                     and type P.T.stm = E.S.P.T.stm
+  )  : ASSEMBLY_EMITTER =
 struct
   structure CFG = CFG
 
diff --git a/flowgraph/buildFlowgraph.sml b/flowgraph/buildFlowgraph.sml
index a6d4582..533b83d 100644
--- a/flowgraph/buildFlowgraph.sml
+++ b/flowgraph/buildFlowgraph.sml
@@ -9,9 +9,34 @@ sig
    structure S   : INSTRUCTION_STREAM
    structure I   : INSTRUCTIONS
    structure P   : PSEUDO_OPS
-   structure CFG : CONTROL_FLOW_GRAPH
-   		where I = I
-                  and P = P
+   structure CFG : CONTROL_FLOW_GRAPH (* where I = I and P = P *)
+                   where type I.addressing_mode = I.addressing_mode
+                     and type I.ea = I.ea
+                     and type I.instr = I.instr
+                     and type I.instruction = I.instruction
+                     and type I.operand = I.operand
+                   where type P.Client.pseudo_op = P.Client.pseudo_op
+                     and type P.T.Basis.cond = P.T.Basis.cond
+                     and type P.T.Basis.div_rounding_mode = P.T.Basis.div_rounding_mode
+                     and type P.T.Basis.ext = P.T.Basis.ext
+                     and type P.T.Basis.fcond = P.T.Basis.fcond
+                     and type P.T.Basis.rounding_mode = P.T.Basis.rounding_mode
+                     and type P.T.Constant.const = P.T.Constant.const
+                     and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) P.T.Extension.ccx
+                     and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) P.T.Extension.fx
+                     and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) P.T.Extension.rx
+                     and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) P.T.Extension.sx
+                     and type P.T.I.div_rounding_mode = P.T.I.div_rounding_mode
+                     and type P.T.Region.region = P.T.Region.region
+                     and type P.T.ccexp = P.T.ccexp
+                     and type P.T.fexp = P.T.fexp
+                     (* and type P.T.labexp = P.T.labexp *)
+                     and type P.T.mlrisc = P.T.mlrisc
+                     and type P.T.oper = P.T.oper
+                     and type P.T.rep = P.T.rep
+                     and type P.T.rexp = P.T.rexp
+                     and type P.T.stm = P.T.stm
+
    (*
     * This creates an emitter which can be used to build a CFG incrementally
     *)
@@ -26,9 +51,33 @@ end
 functor BuildFlowgraph 
   (structure Props  : INSN_PROPERTIES
    structure Stream : INSTRUCTION_STREAM
-   structure CFG    : CONTROL_FLOW_GRAPH  
-			  where I = Props.I
-			    and P = Stream.P
+   structure CFG    : CONTROL_FLOW_GRAPH (* where I = Props.I and P = Stream.P *)
+                      where type I.addressing_mode = Props.I.addressing_mode
+                        and type I.ea = Props.I.ea
+                        and type I.instr = Props.I.instr
+                        and type I.instruction = Props.I.instruction
+                        and type I.operand = Props.I.operand
+                      where type P.Client.pseudo_op = Stream.P.Client.pseudo_op
+                        and type P.T.Basis.cond = Stream.P.T.Basis.cond
+                        and type P.T.Basis.div_rounding_mode = Stream.P.T.Basis.div_rounding_mode
+                        and type P.T.Basis.ext = Stream.P.T.Basis.ext
+                        and type P.T.Basis.fcond = Stream.P.T.Basis.fcond
+                        and type P.T.Basis.rounding_mode = Stream.P.T.Basis.rounding_mode
+                        and type P.T.Constant.const = Stream.P.T.Constant.const
+                        and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Stream.P.T.Extension.ccx
+                        and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Stream.P.T.Extension.fx
+                        and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Stream.P.T.Extension.rx
+                        and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Stream.P.T.Extension.sx
+                        and type P.T.I.div_rounding_mode = Stream.P.T.I.div_rounding_mode
+                        and type P.T.Region.region = Stream.P.T.Region.region
+                        and type P.T.ccexp = Stream.P.T.ccexp
+                        and type P.T.fexp = Stream.P.T.fexp
+                        (* and type P.T.labexp = Stream.P.T.labexp *)
+                        and type P.T.mlrisc = Stream.P.T.mlrisc
+                        and type P.T.oper = Stream.P.T.oper
+                        and type P.T.rep = Stream.P.T.rep
+                        and type P.T.rexp = Stream.P.T.rexp
+                        and type P.T.stm = Stream.P.T.stm
   ) : CONTROL_FLOWGRAPH_GEN =
 struct
   structure CFG = CFG
diff --git a/flowgraph/cfg.sml b/flowgraph/cfg.sml
index 430cfdd..9998db9 100644
--- a/flowgraph/cfg.sml
+++ b/flowgraph/cfg.sml
@@ -10,8 +10,18 @@
 functor ControlFlowGraph
    (structure I : INSTRUCTIONS
     structure GraphImpl : GRAPH_IMPLEMENTATION
-    structure InsnProps : INSN_PROPERTIES where I = I
-    structure Asm : INSTRUCTION_EMITTER where I = I
+    structure InsnProps : INSN_PROPERTIES (* where I = I *)
+                          where type I.addressing_mode = I.addressing_mode
+                            and type I.ea = I.ea
+                            and type I.instr = I.instr
+                            and type I.instruction = I.instruction
+                            and type I.operand = I.operand
+    structure Asm : INSTRUCTION_EMITTER (* where I = I *)
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
    ) : CONTROL_FLOW_GRAPH =
 struct
 
@@ -314,7 +324,10 @@ struct
    fun mustPreceed (G.GRAPH cfg) (i,j) =
    let val visited = H.mkTable(23,NotFound)
        fun chase [] = false
-         | chase((u,v,EDGE{k=(FALLSTHRU|BRANCH false),...})::_) =
+         | chase((u,v,EDGE{k= FALLSTHRU,...})::_) =
+           if H.inDomain visited u then false
+           else u = i orelse (H.insert visited (u,true); chase(#in_edges cfg u))
+         | chase((u,v,EDGE{k= BRANCH false,...})::_) =
            if H.inDomain visited u then false
            else u = i orelse (H.insert visited (u,true); chase(#in_edges cfg u))
          | chase(_::es) = chase es
@@ -355,7 +368,8 @@ struct
        |  BLOCK{insns=insns as ref(jmp::rest),...} => 
              (case #out_edges cfg node of
                 [] => ()
-             |  [(_,_,EDGE{k=(ENTRY | EXIT),...})] => ()
+             |  [(_,_,EDGE{k=ENTRY,...})] => ()
+             |  [(_,_,EDGE{k=EXIT,...})] => ()
              |  [(i,j,_)] =>
                   if InsnProps.instrKind jmp = InsnProps.IK_JUMP then
                        insns := InsnProps.setJumpTarget(jmp,labelOf j)::rest
@@ -388,7 +402,8 @@ struct
     *=====================================================================*)
    fun mergeEdge (CFG as G.GRAPH cfg) (i,j,e as EDGE{w,k,...}) = 
    let val _ = case k of
-                  (ENTRY | EXIT) => raise Can'tMerge
+                  ENTRY => raise Can'tMerge
+               |  EXIT => raise Can'tMerge
                |  _ => () 
        val _ = case (#out_edges cfg i,#in_edges cfg j) of
                   ([(_,j',_)],[(i',_,_)]) => 
@@ -713,7 +728,8 @@ struct
     *========================================================================*)
    fun cdgEdge(EDGE{k, ...}) = 
         case k of
-           (JUMP | FALLSTHRU) => false
+           JUMP => false
+        |  FALLSTHRU => false
         |  _ => true
 
    (*========================================================================
diff --git a/flowgraph/cfgCountCopies.sml b/flowgraph/cfgCountCopies.sml
index d02d2b5..9c68c03 100644
--- a/flowgraph/cfgCountCopies.sml
+++ b/flowgraph/cfgCountCopies.sml
@@ -4,10 +4,18 @@
  *)
 functor CFGCountCopies
    ( structure CFG : CONTROL_FLOW_GRAPH
-     structure InsnProps : INSN_PROPERTIES
-     		where I = CFG.I
-     structure SdiJumps : SDI_JUMPS
-     		where I = CFG.I
+     structure InsnProps : INSN_PROPERTIES (* where I = CFG.I *)
+                           where type I.addressing_mode = CFG.I.addressing_mode
+                             and type I.ea = CFG.I.ea
+                             and type I.instr = CFG.I.instr
+                             and type I.instruction = CFG.I.instruction
+                             and type I.operand = CFG.I.operand
+     structure SdiJumps : SDI_JUMPS (* where I = CFG.I *)
+                          where type I.addressing_mode = CFG.I.addressing_mode
+                            and type I.ea = CFG.I.ea
+                            and type I.instr = CFG.I.instr
+                            and type I.instruction = CFG.I.instruction
+                            and type I.operand = CFG.I.operand
     ) : CFG_OPTIMIZATION =
 struct
    structure CFG = CFG
diff --git a/flowgraph/cfgExpandCopies.sml b/flowgraph/cfgExpandCopies.sml
index dc22908..2fc7240 100644
--- a/flowgraph/cfgExpandCopies.sml
+++ b/flowgraph/cfgExpandCopies.sml
@@ -7,8 +7,12 @@
 
 functor CFGExpandCopies
    (structure CFG    : CONTROL_FLOW_GRAPH
-    structure Shuffle : SHUFFLE
-    			where I = CFG.I
+    structure Shuffle : SHUFFLE (* where I = CFG.I *)
+                        where type I.addressing_mode = CFG.I.addressing_mode
+                          and type I.ea = CFG.I.ea
+                          and type I.instr = CFG.I.instr
+                          and type I.instruction = CFG.I.instruction
+                          and type I.operand = CFG.I.operand
    ) : CFG_OPTIMIZATION =
   struct
     structure CFG = CFG
diff --git a/flowgraph/cfgPeephole.sml b/flowgraph/cfgPeephole.sml
index 9cf9fa8..f7b21db 100644
--- a/flowgraph/cfgPeephole.sml
+++ b/flowgraph/cfgPeephole.sml
@@ -3,8 +3,12 @@
  *)
 functor CFGPeephole
   (structure CFG      : CONTROL_FLOW_GRAPH
-   structure PeepHole : PEEPHOLE
-     sharing CFG.I = PeepHole.I
+   structure PeepHole : PEEPHOLE (* sharing CFG.I = PeepHole.I *)
+                        where type I.addressing_mode = CFG.I.addressing_mode
+                          and type I.ea = CFG.I.ea
+                          and type I.instr = CFG.I.instr
+                          and type I.instruction = CFG.I.instruction
+                          and type I.operand = CFG.I.operand
   ) : CFG_OPTIMIZATION =
 struct
    structure CFG = CFG
diff --git a/flowgraph/printFlowgraph.sml b/flowgraph/printFlowgraph.sml
index 84732fa..3c0718c 100644
--- a/flowgraph/printFlowgraph.sml
+++ b/flowgraph/printFlowgraph.sml
@@ -5,9 +5,33 @@
 signature PRINT_FLOWGRAPH = 
 sig
    structure Asm : INSTRUCTION_EMITTER
-   structure CFG : CONTROL_FLOW_GRAPH
-		      where I = Asm.I 
-			and P = Asm.S.P
+   structure CFG : CONTROL_FLOW_GRAPH (* where I = Asm.I and P = Asm.S.P *)
+                   where type I.addressing_mode = Asm.I.addressing_mode
+                     and type I.ea = Asm.I.ea
+                     and type I.instr = Asm.I.instr
+                     and type I.instruction = Asm.I.instruction
+                     and type I.operand = Asm.I.operand
+                   where type P.Client.pseudo_op = Asm.S.P.Client.pseudo_op
+                     and type P.T.Basis.cond = Asm.S.P.T.Basis.cond
+                     and type P.T.Basis.div_rounding_mode = Asm.S.P.T.Basis.div_rounding_mode
+                     and type P.T.Basis.ext = Asm.S.P.T.Basis.ext
+                     and type P.T.Basis.fcond = Asm.S.P.T.Basis.fcond
+                     and type P.T.Basis.rounding_mode = Asm.S.P.T.Basis.rounding_mode
+                     and type P.T.Constant.const = Asm.S.P.T.Constant.const
+                     and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Asm.S.P.T.Extension.ccx
+                     and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Asm.S.P.T.Extension.fx
+                     and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Asm.S.P.T.Extension.rx
+                     and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Asm.S.P.T.Extension.sx
+                     and type P.T.I.div_rounding_mode = Asm.S.P.T.I.div_rounding_mode
+                     and type P.T.Region.region = Asm.S.P.T.Region.region
+                     and type P.T.ccexp = Asm.S.P.T.ccexp
+                     and type P.T.fexp = Asm.S.P.T.fexp
+                     (* and type P.T.labexp = Asm.S.P.T.labexp *)
+                     and type P.T.mlrisc = Asm.S.P.T.mlrisc
+                     and type P.T.oper = Asm.S.P.T.oper
+                     and type P.T.rep = Asm.S.P.T.rep
+                     and type P.T.rexp = Asm.S.P.T.rexp
+                     and type P.T.stm = Asm.S.P.T.stm
 
    val printCFG : TextIO.outstream -> string -> CFG.cfg -> unit
 end
@@ -15,9 +39,33 @@ end
 
 functor PrintFlowgraph 
    (structure Asm : INSTRUCTION_EMITTER
-    structure CFG : CONTROL_FLOW_GRAPH
-		    where I = Asm.I
-		      and P = Asm.S.P
+    structure CFG : CONTROL_FLOW_GRAPH (* where I = Asm.I and P = Asm.S.P *)
+                    where type I.addressing_mode = Asm.I.addressing_mode
+                      and type I.ea = Asm.I.ea
+                      and type I.instr = Asm.I.instr
+                      and type I.instruction = Asm.I.instruction
+                      and type I.operand = Asm.I.operand
+                    where type P.Client.pseudo_op = Asm.S.P.Client.pseudo_op
+                      and type P.T.Basis.cond = Asm.S.P.T.Basis.cond
+                      and type P.T.Basis.div_rounding_mode = Asm.S.P.T.Basis.div_rounding_mode
+                      and type P.T.Basis.ext = Asm.S.P.T.Basis.ext
+                      and type P.T.Basis.fcond = Asm.S.P.T.Basis.fcond
+                      and type P.T.Basis.rounding_mode = Asm.S.P.T.Basis.rounding_mode
+                      and type P.T.Constant.const = Asm.S.P.T.Constant.const
+                      and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Asm.S.P.T.Extension.ccx
+                      and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Asm.S.P.T.Extension.fx
+                      and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Asm.S.P.T.Extension.rx
+                      and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Asm.S.P.T.Extension.sx
+                      and type P.T.I.div_rounding_mode = Asm.S.P.T.I.div_rounding_mode
+                      and type P.T.Region.region = Asm.S.P.T.Region.region
+                      and type P.T.ccexp = Asm.S.P.T.ccexp
+                      and type P.T.fexp = Asm.S.P.T.fexp
+                      (* and type P.T.labexp = Asm.S.P.T.labexp *)
+                      and type P.T.mlrisc = Asm.S.P.T.mlrisc
+                      and type P.T.oper = Asm.S.P.T.oper
+                      and type P.T.rep = Asm.S.P.T.rep
+                      and type P.T.rexp = Asm.S.P.T.rexp
+                      and type P.T.stm = Asm.S.P.T.stm
    ) : PRINT_FLOWGRAPH =
 struct
    structure Asm = Asm
diff --git a/flowgraph/pseudo-ops-big.sml b/flowgraph/pseudo-ops-big.sml
index 6834f48..7a31d3c 100644
--- a/flowgraph/pseudo-ops-big.sml
+++ b/flowgraph/pseudo-ops-big.sml
@@ -7,8 +7,27 @@
 
 functor PseudoOpsBig
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL 
-			     where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
      val  icache_alignment : int	(* cache line size *)
      val max_alignment : int option	(* maximum alignment for internal labels *)
      val nop: {sz:int, en:Word32.word}	(* encoding for noop *)
diff --git a/flowgraph/pseudo-ops-little.sml b/flowgraph/pseudo-ops-little.sml
index 2d433cd..38b180e 100644
--- a/flowgraph/pseudo-ops-little.sml
+++ b/flowgraph/pseudo-ops-little.sml
@@ -7,8 +7,27 @@
 
 functor PseudoOpsLittle
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL
-			    where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
      val icache_alignment : int		(* cache line size *)
      val max_alignment : int option	(* maximum alignment for internal labels *)
      val nop: {sz:int, en:Word32.word}	(* encoding for noop *)
diff --git a/flowgraph/pseudo-ops.sig b/flowgraph/pseudo-ops.sig
index f5165c9..7f0b394 100644
--- a/flowgraph/pseudo-ops.sig
+++ b/flowgraph/pseudo-ops.sig
@@ -8,7 +8,27 @@
 
 signature PSEUDO_OPS = sig
   structure T : MLTREE
-  structure Client : CLIENT_PSEUDO_OPS where AsmPseudoOps.T = T
+  structure Client : CLIENT_PSEUDO_OPS (* where AsmPseudoOps.T = T *)
+                     where type AsmPseudoOps.T.Basis.cond = T.Basis.cond
+                       and type AsmPseudoOps.T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                       and type AsmPseudoOps.T.Basis.ext = T.Basis.ext
+                       and type AsmPseudoOps.T.Basis.fcond = T.Basis.fcond
+                       and type AsmPseudoOps.T.Basis.rounding_mode = T.Basis.rounding_mode
+                       and type AsmPseudoOps.T.Constant.const = T.Constant.const
+                       and type ('s,'r,'f,'c) AsmPseudoOps.T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                       and type ('s,'r,'f,'c) AsmPseudoOps.T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                       and type ('s,'r,'f,'c) AsmPseudoOps.T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                       and type ('s,'r,'f,'c) AsmPseudoOps.T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                       and type AsmPseudoOps.T.I.div_rounding_mode = T.I.div_rounding_mode
+                       and type AsmPseudoOps.T.Region.region = T.Region.region
+                       and type AsmPseudoOps.T.ccexp = T.ccexp
+                       and type AsmPseudoOps.T.fexp = T.fexp
+                       (* and type AsmPseudoOps.T.labexp = T.labexp *)
+                       and type AsmPseudoOps.T.mlrisc = T.mlrisc
+                       and type AsmPseudoOps.T.oper = T.oper
+                       and type AsmPseudoOps.T.rep = T.rep
+                       and type AsmPseudoOps.T.rexp = T.rexp
+                       and type AsmPseudoOps.T.stm = T.stm
 
   type pseudo_op = (T.labexp, Client.pseudo_op) PseudoOpsBasisTyp.pseudo_op
 
diff --git a/frequencies/compute-freqs-fn.sml b/frequencies/compute-freqs-fn.sml
index 2c701ce..cc41c8d 100644
--- a/frequencies/compute-freqs-fn.sml
+++ b/frequencies/compute-freqs-fn.sml
@@ -40,9 +40,9 @@ functor ComputeFreqsFn (
 
   (***** Representation of equations *****)
     type var = Graph.node_id
+    type term = (real * var)
+    type sum = {terms : term list, c : real}
     datatype def = Unknown | Sum of sum
-    withtype term = (real * var)
-	 and sum = {terms : term list, c : real}
 
     val zero = {c = 0.0, terms = []}
     val one = {c = 1.0, terms = []}
diff --git a/gc-safety/gc-cells.sig b/gc-safety/gc-cells.sig
index c70e143..09f8388 100644
--- a/gc-safety/gc-cells.sig
+++ b/gc-safety/gc-cells.sig
@@ -8,7 +8,16 @@ sig
 
    structure C  : CELLS
    structure GC : GC_TYPE
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
 
    (* Generate a virtual register and update the gc info at the same time. *)
    val newCell   : CB.cellkind -> GC.gctype -> CB.cell
diff --git a/graphs/bigraph.sig b/graphs/bigraph.sig
index 218d36f..33b5b30 100644
--- a/graphs/bigraph.sig
+++ b/graphs/bigraph.sig
@@ -9,8 +9,7 @@ sig
 
    include GRAPH
 
-   datatype ('m,'n,'e,'g) bigraph = BIGRAPH of ('m,'n,'e,'g) bigraph_methods
-   withtype ('m,'n,'e,'g) bigraph_methods =
+   type ('m,'n,'e,'g) bigraph_methods =
        {  name        : string,
           graph_info  : 'g,
 
@@ -50,5 +49,6 @@ sig
           forall_dst   : ('n node -> unit) -> unit,
           forall_edges : ('e edge -> unit) -> unit
        }
+   datatype ('m,'n,'e,'g) bigraph = BIGRAPH of ('m,'n,'e,'g) bigraph_methods
 end
 
diff --git a/graphs/digraph.sml b/graphs/digraph.sml
index 44d341a..1832f21 100644
--- a/graphs/digraph.sml
+++ b/graphs/digraph.sml
@@ -7,7 +7,33 @@
  * -- Allen
  *)
 
-functor DirectedGraph(A : ARRAY) : 
+functor DirectedGraph(A : sig type 'a array
+                              type 'a vector
+
+                              val all: ('a -> bool) -> 'a array -> bool
+                              val app: ('a -> unit) -> 'a array -> unit
+                              val appi: (int * 'a -> unit) -> 'a array -> unit
+                              val array: int * 'a -> 'a array
+                              val collate: ('a * 'a -> order) -> 'a array * 'a array -> order
+                              val copy: {src: 'a array, dst: 'a array, di: int} -> unit
+                              val copyVec: {src: 'a vector, dst: 'a array, di: int} -> unit
+                              val exists: ('a -> bool) -> 'a array -> bool
+                              val find: ('a -> bool) -> 'a array -> 'a option
+                              val findi: (int * 'a -> bool) -> 'a array -> (int * 'a) option
+                              val foldl: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
+                              val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
+                              val foldr: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
+                              val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
+                              val fromList: 'a list -> 'a array
+                              val length: 'a array -> int
+                              val maxLen: int
+                              val modify: ('a -> 'a) -> 'a array -> unit
+                              val modifyi: (int * 'a -> 'a) -> 'a array -> unit
+                              val sub: 'a array * int -> 'a
+                              val tabulate: int * (int -> 'a) -> 'a array
+                              val update: 'a array * int * 'a -> unit
+                              val vector: 'a array -> 'a vector
+                          end) :
 sig include GRAPH_IMPLEMENTATION 
 
     type 'e adjlist   = 'e Graph.edge list A.array
diff --git a/graphs/graph.sig b/graphs/graph.sig
index 50b2ff0..0d98039 100644
--- a/graphs/graph.sig
+++ b/graphs/graph.sig
@@ -25,8 +25,7 @@ sig
    type 'n node = node_id * 'n 
    type 'e edge = node_id * node_id * 'e
 
-   datatype ('n,'e,'g) graph = GRAPH of ('n,'e,'g) graph_methods
-   withtype ('n,'e,'g) graph_methods = 
+   type ('n,'e,'g) graph_methods =
        {  name            : string,
           graph_info      : 'g,
 
@@ -65,6 +64,7 @@ sig
           forall_nodes    : ('n node -> unit) -> unit,
           forall_edges    : ('e edge -> unit) -> unit
        }
+   datatype ('n,'e,'g) graph = GRAPH of ('n,'e,'g) graph_methods
    val unimplemented : 'a -> 'b
 
          (* remove one edge i->j from graph *)
diff --git a/hppa/backpatch/hppaDelaySlotProps.sml b/hppa/backpatch/hppaDelaySlotProps.sml
index 5b2ffbb..113525b 100644
--- a/hppa/backpatch/hppaDelaySlotProps.sml
+++ b/hppa/backpatch/hppaDelaySlotProps.sml
@@ -4,7 +4,12 @@
 
 functor HppaDelaySlots
    (structure I : HPPAINSTR
-    structure P : INSN_PROPERTIES where I = I
+    structure P : INSN_PROPERTIES (* where I = I *)
+                  where type I.addressing_mode = I.addressing_mode
+                    and type I.ea = I.ea
+                    and type I.instr = I.instr
+                    and type I.instruction = I.instruction
+                    and type I.operand = I.operand
    ) : DELAY_SLOT_PROPERTIES =
 struct
    structure I  = I
@@ -100,11 +105,19 @@ struct
         in  clash(defUseInt) orelse clash(defUseReal) 
         end
 
-    fun delaySlotCandidate{jmp,delaySlot=
-             (  I.INSTR(I.BCOND _) | I.INSTR(I.BCONDI _) | I.INSTR(I.BB _) | I.INSTR(I.FBRANCH _) 
-              | I.INSTR(I.BV _) | I.INSTR(I.BE _) | I.INSTR(I.COMCLR_LDO _) | I.INSTR(I.COMICLR_LDO _) 
-	      | I.INSTR(I.B _) | I.INSTR(I.LONGJUMP _) | I.INSTR(I.BLR _) | I.INSTR(I.BL _) 
-	      | I.INSTR(I.BLE _))} = false
+    fun delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BCOND _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BCONDI _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BB _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.FBRANCH _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BV _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BE _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.COMCLR_LDO _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.COMICLR_LDO _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.B _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.LONGJUMP _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BLR _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BL _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BLE _)} = false
       | delaySlotCandidate{jmp=I.ANNOTATION{i,...},delaySlot} = 
            delaySlotCandidate{jmp=i,delaySlot=delaySlot}
       | delaySlotCandidate{jmp,delaySlot=I.ANNOTATION{i,...}} = 
diff --git a/hppa/backpatch/hppaJumps.sml b/hppa/backpatch/hppaJumps.sml
index df66191..fc3e049 100644
--- a/hppa/backpatch/hppaJumps.sml
+++ b/hppa/backpatch/hppaJumps.sml
@@ -5,10 +5,75 @@
  *)
 functor HppaJumps
   ( structure Instr:HPPAINSTR
-    structure Shuffle:HPPASHUFFLE 
-			 where I = Instr
-    structure MLTreeEval : MLTREE_EVAL 
-		         where T = Instr.T
+    structure Shuffle:HPPASHUFFLE (* where I = Instr *)
+                      where type I.Constant.const = Instr.Constant.const
+                        and type I.Region.region = Instr.Region.region
+                        and type I.T.Basis.cond = Instr.T.Basis.cond
+                        and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                        and type I.T.Basis.ext = Instr.T.Basis.ext
+                        and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                        and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                        and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                        and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                        and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                        and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                        and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                        and type I.T.ccexp = Instr.T.ccexp
+                        and type I.T.fexp = Instr.T.fexp
+                        (* and type I.T.labexp = Instr.T.labexp *)
+                        and type I.T.mlrisc = Instr.T.mlrisc
+                        and type I.T.oper = Instr.T.oper
+                        and type I.T.rep = Instr.T.rep
+                        and type I.T.rexp = Instr.T.rexp
+                        and type I.T.stm = Instr.T.stm
+                        and type I.addressing_mode = Instr.addressing_mode
+                        and type I.arith = Instr.arith
+                        and type I.arithi = Instr.arithi
+                        and type I.bcond = Instr.bcond
+                        and type I.bitcond = Instr.bitcond
+                        and type I.cmp = Instr.cmp
+                        and type I.cmpi = Instr.cmpi
+                        and type I.ea = Instr.ea
+                        and type I.farith = Instr.farith
+                        and type I.fcnv = Instr.fcnv
+                        and type I.fcond = Instr.fcond
+                        and type I.field_selector = Instr.field_selector
+                        and type I.fload = Instr.fload
+                        and type I.floadx = Instr.floadx
+                        and type I.fmt = Instr.fmt
+                        and type I.fstore = Instr.fstore
+                        and type I.fstorex = Instr.fstorex
+                        and type I.funary = Instr.funary
+                        and type I.instr = Instr.instr
+                        and type I.instruction = Instr.instruction
+                        and type I.load = Instr.load
+                        and type I.loadi = Instr.loadi
+                        and type I.operand = Instr.operand
+                        and type I.scond = Instr.scond
+                        and type I.shift = Instr.shift
+                        and type I.shiftv = Instr.shiftv
+                        and type I.store = Instr.store
+    structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                           where type T.Basis.cond = Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = Instr.T.Basis.ext
+                             and type T.Basis.fcond = Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                             and type T.Region.region = Instr.T.Region.region
+                             and type T.ccexp = Instr.T.ccexp
+                             and type T.fexp = Instr.T.fexp
+                             (* and type T.labexp = Instr.T.labexp *)
+                             and type T.mlrisc = Instr.T.mlrisc
+                             and type T.oper = Instr.T.oper
+                             and type T.rep = Instr.T.rep
+                             and type T.rexp = Instr.T.rexp
+                             and type T.stm = Instr.T.stm
   ) : SDI_JUMPS =				
 struct
   structure I = Instr
diff --git a/hppa/emit/hppaAsm.sml b/hppa/emit/hppaAsm.sml
index ead6d50..ba1a410 100644
--- a/hppa/emit/hppaAsm.sml
+++ b/hppa/emit/hppaAsm.sml
@@ -6,12 +6,96 @@
 
 
 functor HppaAsmEmitter(structure S : INSTRUCTION_STREAM
-                       structure Instr : HPPAINSTR
-                          where T = S.P.T
-                       structure Shuffle : HPPASHUFFLE
-                          where I = Instr
-                       structure MLTreeEval : MLTREE_EVAL
-                          where T = Instr.T
+                       structure Instr : HPPAINSTR (* where T = S.P.T *)
+                                         where type T.Basis.cond = S.P.T.Basis.cond
+                                           and type T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+                                           and type T.Basis.ext = S.P.T.Basis.ext
+                                           and type T.Basis.fcond = S.P.T.Basis.fcond
+                                           and type T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+                                           and type T.Constant.const = S.P.T.Constant.const
+                                           and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+                                           and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+                                           and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+                                           and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+                                           and type T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+                                           and type T.Region.region = S.P.T.Region.region
+                                           and type T.ccexp = S.P.T.ccexp
+                                           and type T.fexp = S.P.T.fexp
+                                           (* and type T.labexp = S.P.T.labexp *)
+                                           and type T.mlrisc = S.P.T.mlrisc
+                                           and type T.oper = S.P.T.oper
+                                           and type T.rep = S.P.T.rep
+                                           and type T.rexp = S.P.T.rexp
+                                           and type T.stm = S.P.T.stm
+                       structure Shuffle : HPPASHUFFLE (* where I = Instr *)
+                                           where type I.Constant.const = Instr.Constant.const
+                                             and type I.Region.region = Instr.Region.region
+                                             and type I.T.Basis.cond = Instr.T.Basis.cond
+                                             and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                             and type I.T.Basis.ext = Instr.T.Basis.ext
+                                             and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                             and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                             and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                             and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                             and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                             and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                             and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                             and type I.T.ccexp = Instr.T.ccexp
+                                             and type I.T.fexp = Instr.T.fexp
+                                             (* and type I.T.labexp = Instr.T.labexp *)
+                                             and type I.T.mlrisc = Instr.T.mlrisc
+                                             and type I.T.oper = Instr.T.oper
+                                             and type I.T.rep = Instr.T.rep
+                                             and type I.T.rexp = Instr.T.rexp
+                                             and type I.T.stm = Instr.T.stm
+                                             and type I.addressing_mode = Instr.addressing_mode
+                                             and type I.arith = Instr.arith
+                                             and type I.arithi = Instr.arithi
+                                             and type I.bcond = Instr.bcond
+                                             and type I.bitcond = Instr.bitcond
+                                             and type I.cmp = Instr.cmp
+                                             and type I.cmpi = Instr.cmpi
+                                             and type I.ea = Instr.ea
+                                             and type I.farith = Instr.farith
+                                             and type I.fcnv = Instr.fcnv
+                                             and type I.fcond = Instr.fcond
+                                             and type I.field_selector = Instr.field_selector
+                                             and type I.fload = Instr.fload
+                                             and type I.floadx = Instr.floadx
+                                             and type I.fmt = Instr.fmt
+                                             and type I.fstore = Instr.fstore
+                                             and type I.fstorex = Instr.fstorex
+                                             and type I.funary = Instr.funary
+                                             and type I.instr = Instr.instr
+                                             and type I.instruction = Instr.instruction
+                                             and type I.load = Instr.load
+                                             and type I.loadi = Instr.loadi
+                                             and type I.operand = Instr.operand
+                                             and type I.scond = Instr.scond
+                                             and type I.shift = Instr.shift
+                                             and type I.shiftv = Instr.shiftv
+                                             and type I.store = Instr.store
+                       structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                              where type T.Basis.cond = Instr.T.Basis.cond
+                                                and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                                and type T.Basis.ext = Instr.T.Basis.ext
+                                                and type T.Basis.fcond = Instr.T.Basis.fcond
+                                                and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                                and type T.Constant.const = Instr.T.Constant.const
+                                                and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                                and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                                and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                                and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                                and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                                and type T.Region.region = Instr.T.Region.region
+                                                and type T.ccexp = Instr.T.ccexp
+                                                and type T.fexp = Instr.T.fexp
+                                                (* and type T.labexp = Instr.T.labexp *)
+                                                and type T.mlrisc = Instr.T.mlrisc
+                                                and type T.oper = Instr.T.oper
+                                                and type T.rep = Instr.T.rep
+                                                and type T.rexp = Instr.T.rexp
+                                                and type T.stm = Instr.T.stm
                       ) : INSTRUCTION_EMITTER =
 struct
    structure I  = Instr
diff --git a/hppa/emit/hppaMC.sml b/hppa/emit/hppaMC.sml
index e4d5ad4..37805e3 100644
--- a/hppa/emit/hppaMC.sml
+++ b/hppa/emit/hppaMC.sml
@@ -6,7 +6,27 @@
 
 
 functor HppaMCEmitter(structure Instr : HPPAINSTR
-                      structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+                      structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                             where type T.Basis.cond = Instr.T.Basis.cond
+                                               and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                               and type T.Basis.ext = Instr.T.Basis.ext
+                                               and type T.Basis.fcond = Instr.T.Basis.fcond
+                                               and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                               and type T.Constant.const = Instr.T.Constant.const
+                                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                               and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                               and type T.Region.region = Instr.T.Region.region
+                                               and type T.ccexp = Instr.T.ccexp
+                                               and type T.fexp = Instr.T.fexp
+                                               (* and type T.labexp = Instr.T.labexp *)
+                                               and type T.mlrisc = Instr.T.mlrisc
+                                               and type T.oper = Instr.T.oper
+                                               and type T.rep = Instr.T.rep
+                                               and type T.rexp = Instr.T.rexp
+                                               and type T.stm = Instr.T.stm
                       structure Stream : INSTRUCTION_STREAM 
                       structure CodeString : CODE_STRING
                      ) : INSTRUCTION_EMITTER =
@@ -47,6 +67,7 @@ struct
        (* note: fromLargeWord strips the high order bits! *)
        fun eByteW w =
        let val i = !loc
+           val w = W.toLargeWord w
        in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
    
        fun doNothing _ = ()
diff --git a/hppa/flowgraph/hppaGasPseudoOps.sml b/hppa/flowgraph/hppaGasPseudoOps.sml
index 8e77f26..859cb7a 100644
--- a/hppa/flowgraph/hppaGasPseudoOps.sml
+++ b/hppa/flowgraph/hppaGasPseudoOps.sml
@@ -1,6 +1,26 @@
 functor HppaGasPseudoOps 
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL  where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
     ) : PSEUDO_OPS_BASIS = 
 
 struct
diff --git a/hppa/instructions/hppaInstr.sml b/hppa/instructions/hppaInstr.sml
index 34a89b2..a2d0e29 100644
--- a/hppa/instructions/hppaInstr.sml
+++ b/hppa/instructions/hppaInstr.sml
@@ -8,7 +8,16 @@
 signature HPPAINSTR =
 sig
    structure C : HPPACELLS
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    structure T : MLTREE
    structure Constant: CONSTANT
    structure Region : REGION
diff --git a/hppa/instructions/hppaProps.sml b/hppa/instructions/hppaProps.sml
index df9b170..50d9210 100644
--- a/hppa/instructions/hppaProps.sml
+++ b/hppa/instructions/hppaProps.sml
@@ -6,8 +6,48 @@
 
 functor HppaProps
    ( structure HppaInstr : HPPAINSTR
-     structure MLTreeEval : MLTREE_EVAL where T = HppaInstr.T
-     structure MLTreeHash : MLTREE_HASH where T = HppaInstr.T
+     structure MLTreeEval : MLTREE_EVAL (* where T = HppaInstr.T *)
+                            where type T.Basis.cond = HppaInstr.T.Basis.cond
+                              and type T.Basis.div_rounding_mode = HppaInstr.T.Basis.div_rounding_mode
+                              and type T.Basis.ext = HppaInstr.T.Basis.ext
+                              and type T.Basis.fcond = HppaInstr.T.Basis.fcond
+                              and type T.Basis.rounding_mode = HppaInstr.T.Basis.rounding_mode
+                              and type T.Constant.const = HppaInstr.T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) HppaInstr.T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) HppaInstr.T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) HppaInstr.T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) HppaInstr.T.Extension.sx
+                              and type T.I.div_rounding_mode = HppaInstr.T.I.div_rounding_mode
+                              and type T.Region.region = HppaInstr.T.Region.region
+                              and type T.ccexp = HppaInstr.T.ccexp
+                              and type T.fexp = HppaInstr.T.fexp
+                              (* and type T.labexp = HppaInstr.T.labexp *)
+                              and type T.mlrisc = HppaInstr.T.mlrisc
+                              and type T.oper = HppaInstr.T.oper
+                              and type T.rep = HppaInstr.T.rep
+                              and type T.rexp = HppaInstr.T.rexp
+                              and type T.stm = HppaInstr.T.stm
+     structure MLTreeHash : MLTREE_HASH (* where T = HppaInstr.T *)
+                            where type T.Basis.cond = HppaInstr.T.Basis.cond
+                              and type T.Basis.div_rounding_mode = HppaInstr.T.Basis.div_rounding_mode
+                              and type T.Basis.ext = HppaInstr.T.Basis.ext
+                              and type T.Basis.fcond = HppaInstr.T.Basis.fcond
+                              and type T.Basis.rounding_mode = HppaInstr.T.Basis.rounding_mode
+                              and type T.Constant.const = HppaInstr.T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) HppaInstr.T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) HppaInstr.T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) HppaInstr.T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) HppaInstr.T.Extension.sx
+                              and type T.I.div_rounding_mode = HppaInstr.T.I.div_rounding_mode
+                              and type T.Region.region = HppaInstr.T.Region.region
+                              and type T.ccexp = HppaInstr.T.ccexp
+                              and type T.fexp = HppaInstr.T.fexp
+                              (* and type T.labexp = HppaInstr.T.labexp *)
+                              and type T.mlrisc = HppaInstr.T.mlrisc
+                              and type T.oper = HppaInstr.T.oper
+                              and type T.rep = HppaInstr.T.rep
+                              and type T.rexp = HppaInstr.T.rexp
+                              and type T.stm = HppaInstr.T.stm
     ) : INSN_PROPERTIES = 
 struct
   structure I = HppaInstr
@@ -206,9 +246,12 @@ struct
    *========================================================================*)
   fun defUseR instr = let
     fun hppaDU instr = let
-      fun trap((I.ADDO | I.SUBO | I.SH1ADDO), d, u) = (d, u)
+      fun trap(I.ADDO, d, u) = (d, u)
+        | trap(I.SUBO, d, u) = (d, u)
+        | trap(I.SH1ADDO, d, u) = (d, u)
 	| trap(_, d, u) = (d, u)
-      fun trapi((I.ADDIO | I.SUBIO), d, u) = (d, u)
+      fun trapi(I.ADDIO, d, u) = (d, u)
+        | trapi(I.SUBIO, d, u) = (d, u)
 	| trapi(_, d, u) = (d, u)
     in
       case instr
diff --git a/hppa/mltree/hppa.sml b/hppa/mltree/hppa.sml
index 50a58b4..ea04970 100644
--- a/hppa/mltree/hppa.sml
+++ b/hppa/mltree/hppa.sml
@@ -14,14 +14,106 @@
 
 functor Hppa
   (structure HppaInstr : HPPAINSTR
-   structure ExtensionComp : MLTREE_EXTENSION_COMP
-      		where I = HppaInstr 
-		  and T = HppaInstr.T
-   structure MilliCode : HPPA_MILLICODE
-      		where I = HppaInstr
-   structure LabelComp : LABEL_COMP 
-   		where I = HppaInstr  
-		  and T = HppaInstr.T
+   structure ExtensionComp : MLTREE_EXTENSION_COMP (* where I = HppaInstr and T = HppaInstr.T *)
+                             where type I.addressing_mode = HppaInstr.addressing_mode
+                               and type I.ea = HppaInstr.ea
+                               and type I.instr = HppaInstr.instr
+                               and type I.instruction = HppaInstr.instruction
+                               and type I.operand = HppaInstr.operand
+                             where type T.Basis.cond = HppaInstr.T.Basis.cond
+                               and type T.Basis.div_rounding_mode = HppaInstr.T.Basis.div_rounding_mode
+                               and type T.Basis.ext = HppaInstr.T.Basis.ext
+                               and type T.Basis.fcond = HppaInstr.T.Basis.fcond
+                               and type T.Basis.rounding_mode = HppaInstr.T.Basis.rounding_mode
+                               and type T.Constant.const = HppaInstr.T.Constant.const
+                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) HppaInstr.T.Extension.ccx
+                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) HppaInstr.T.Extension.fx
+                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) HppaInstr.T.Extension.rx
+                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) HppaInstr.T.Extension.sx
+                               and type T.I.div_rounding_mode = HppaInstr.T.I.div_rounding_mode
+                               and type T.Region.region = HppaInstr.T.Region.region
+                               and type T.ccexp = HppaInstr.T.ccexp
+                               and type T.fexp = HppaInstr.T.fexp
+                               (* and type T.labexp = HppaInstr.T.labexp *)
+                               and type T.mlrisc = HppaInstr.T.mlrisc
+                               and type T.oper = HppaInstr.T.oper
+                               and type T.rep = HppaInstr.T.rep
+                               and type T.rexp = HppaInstr.T.rexp
+                               and type T.stm = HppaInstr.T.stm
+   structure MilliCode : HPPA_MILLICODE (* where I = HppaInstr *)
+                         where type I.Constant.const = HppaInstr.Constant.const
+                           and type I.Region.region = HppaInstr.Region.region
+                           and type I.T.Basis.cond = HppaInstr.T.Basis.cond
+                           and type I.T.Basis.div_rounding_mode = HppaInstr.T.Basis.div_rounding_mode
+                           and type I.T.Basis.ext = HppaInstr.T.Basis.ext
+                           and type I.T.Basis.fcond = HppaInstr.T.Basis.fcond
+                           and type I.T.Basis.rounding_mode = HppaInstr.T.Basis.rounding_mode
+                           and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) HppaInstr.T.Extension.ccx
+                           and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) HppaInstr.T.Extension.fx
+                           and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) HppaInstr.T.Extension.rx
+                           and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) HppaInstr.T.Extension.sx
+                           and type I.T.I.div_rounding_mode = HppaInstr.T.I.div_rounding_mode
+                           and type I.T.ccexp = HppaInstr.T.ccexp
+                           and type I.T.fexp = HppaInstr.T.fexp
+                           (* and type I.T.labexp = HppaInstr.T.labexp *)
+                           and type I.T.mlrisc = HppaInstr.T.mlrisc
+                           and type I.T.oper = HppaInstr.T.oper
+                           and type I.T.rep = HppaInstr.T.rep
+                           and type I.T.rexp = HppaInstr.T.rexp
+                           and type I.T.stm = HppaInstr.T.stm
+                           and type I.addressing_mode = HppaInstr.addressing_mode
+                           and type I.arith = HppaInstr.arith
+                           and type I.arithi = HppaInstr.arithi
+                           and type I.bcond = HppaInstr.bcond
+                           and type I.bitcond = HppaInstr.bitcond
+                           and type I.cmp = HppaInstr.cmp
+                           and type I.cmpi = HppaInstr.cmpi
+                           and type I.ea = HppaInstr.ea
+                           and type I.farith = HppaInstr.farith
+                           and type I.fcnv = HppaInstr.fcnv
+                           and type I.fcond = HppaInstr.fcond
+                           and type I.field_selector = HppaInstr.field_selector
+                           and type I.fload = HppaInstr.fload
+                           and type I.floadx = HppaInstr.floadx
+                           and type I.fmt = HppaInstr.fmt
+                           and type I.fstore = HppaInstr.fstore
+                           and type I.fstorex = HppaInstr.fstorex
+                           and type I.funary = HppaInstr.funary
+                           and type I.instr = HppaInstr.instr
+                           and type I.instruction = HppaInstr.instruction
+                           and type I.load = HppaInstr.load
+                           and type I.loadi = HppaInstr.loadi
+                           and type I.operand = HppaInstr.operand
+                           and type I.scond = HppaInstr.scond
+                           and type I.shift = HppaInstr.shift
+                           and type I.shiftv = HppaInstr.shiftv
+                           and type I.store = HppaInstr.store
+   structure LabelComp : LABEL_COMP (* where I = HppaInstr and T = HppaInstr.T *)
+                         where type I.addressing_mode = HppaInstr.addressing_mode
+                           and type I.ea = HppaInstr.ea
+                           and type I.instr = HppaInstr.instr
+                           and type I.instruction = HppaInstr.instruction
+                           and type I.operand = HppaInstr.operand
+                         where type T.Basis.cond = HppaInstr.T.Basis.cond
+                           and type T.Basis.div_rounding_mode = HppaInstr.T.Basis.div_rounding_mode
+                           and type T.Basis.ext = HppaInstr.T.Basis.ext
+                           and type T.Basis.fcond = HppaInstr.T.Basis.fcond
+                           and type T.Basis.rounding_mode = HppaInstr.T.Basis.rounding_mode
+                           and type T.Constant.const = HppaInstr.T.Constant.const
+                           and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) HppaInstr.T.Extension.ccx
+                           and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) HppaInstr.T.Extension.fx
+                           and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) HppaInstr.T.Extension.rx
+                           and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) HppaInstr.T.Extension.sx
+                           and type T.I.div_rounding_mode = HppaInstr.T.I.div_rounding_mode
+                           and type T.Region.region = HppaInstr.T.Region.region
+                           and type T.ccexp = HppaInstr.T.ccexp
+                           and type T.fexp = HppaInstr.T.fexp
+                           (* and type T.labexp = HppaInstr.T.labexp *)
+                           and type T.mlrisc = HppaInstr.T.mlrisc
+                           and type T.oper = HppaInstr.T.oper
+                           and type T.rep = HppaInstr.T.rep
+                           and type T.rexp = HppaInstr.T.rexp
+                           and type T.stm = HppaInstr.T.stm
    val costOfMultiply : int ref
    val costOfDivision : int ref
   ) : MLTREECOMP =
@@ -52,24 +144,23 @@ struct
    fun mkfcopy{dst, src, tmp} =
        I.COPY{k=CB.FP, sz=64, dst=dst, src=src, tmp=tmp}
    structure W = Word32
-   functor Multiply32 = MLTreeMult
-    (structure I = I
-     structure T = T
-     structure CB = CB
-     val intTy = 32
-     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
-     type argi = {r:CB.cell,i:int,d:CB.cell}
-
-     fun mov{r,d} = mkcopy{dst=[d],src=[r],tmp=NONE}
-     fun add{r1,r2,d} = I.arith{a=I.ADD,r1=r1,r2=r2,t=d}
-     fun slli{r,i,d} = [I.shift{s=I.ZDEP,r=r,p=31-i,len=32-i,t=d}]
-     fun srli{r,i,d} = [I.shift{s=I.EXTRU,r=r,p=31-i,len=32-i,t=d}]
-     fun srai{r,i,d} = [I.shift{s=I.EXTRS,r=r,p=31-i,len=32-i,t=d}]
-    )
 
    (* signed, trapping version of multiply and divide *)
-   structure Mult32 = Multiply32
-    (val trapping = true
+   structure Mult32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CB
+     val intTy = 32
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d} = mkcopy{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r1=r1,r2=r2,t=d}
+     fun slli{r,i,d} = [I.shift{s=I.ZDEP,r=r,p=31-i,len=32-i,t=d}]
+     fun srli{r,i,d} = [I.shift{s=I.EXTRU,r=r,p=31-i,len=32-i,t=d}]
+     fun srai{r,i,d} = [I.shift{s=I.EXTRS,r=r,p=31-i,len=32-i,t=d}]
+
+     val trapping = true
      val multCost = costOfMultiply
      val divCost  = costOfDivision
      fun addv{r1,r2,d} = [I.arith{a=I.ADDO,r1=r1,r2=r2,t=d}]
@@ -77,12 +168,25 @@ struct
      val sh1addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH1ADDO,r1=r1,r2=r2,t=d}])
      val sh2addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH2ADDO,r1=r1,r2=r2,t=d}])
      val sh3addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH3ADDO,r1=r1,r2=r2,t=d}])
-    )
-    (val signed = true)
+
+     val signed = true)
 
    (* unsigned, non-trapping version of multiply and divide *)
-   structure Mulu32 = Multiply32
-    (val trapping = false
+   structure Mulu32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CB
+     val intTy = 32
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d} = mkcopy{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r1=r1,r2=r2,t=d}
+     fun slli{r,i,d} = [I.shift{s=I.ZDEP,r=r,p=31-i,len=32-i,t=d}]
+     fun srli{r,i,d} = [I.shift{s=I.EXTRU,r=r,p=31-i,len=32-i,t=d}]
+     fun srai{r,i,d} = [I.shift{s=I.EXTRS,r=r,p=31-i,len=32-i,t=d}]
+
+     val trapping = false
      val multCost = costOfMultiply
      val divCost  = costOfDivision
      fun addv{r1,r2,d} = [I.arith{a=I.ADD,r1=r1,r2=r2,t=d}]
@@ -90,12 +194,25 @@ struct
      val sh1addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH1ADDL,r1=r1,r2=r2,t=d}])
      val sh2addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH2ADDL,r1=r1,r2=r2,t=d}])
      val sh3addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH3ADDL,r1=r1,r2=r2,t=d}])
-    )
-    (val signed   = false)
+
+     val signed   = false)
 
    (* signed, non-trapping version of multiply and divide *)
-   structure Muls32 = Multiply32
-    (val trapping = false
+   structure Muls32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CB
+     val intTy = 32
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d} = mkcopy{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r1=r1,r2=r2,t=d}
+     fun slli{r,i,d} = [I.shift{s=I.ZDEP,r=r,p=31-i,len=32-i,t=d}]
+     fun srli{r,i,d} = [I.shift{s=I.EXTRU,r=r,p=31-i,len=32-i,t=d}]
+     fun srai{r,i,d} = [I.shift{s=I.EXTRS,r=r,p=31-i,len=32-i,t=d}]
+
+     val trapping = false
      val multCost = costOfMultiply
      val divCost  = costOfDivision
      fun addv{r1,r2,d} = [I.arith{a=I.ADD,r1=r1,r2=r2,t=d}]
@@ -103,8 +220,8 @@ struct
      val sh1addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH1ADDL,r1=r1,r2=r2,t=d}])
      val sh2addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH2ADDL,r1=r1,r2=r2,t=d}])
      val sh3addv = SOME(fn{r1,r2,d} => [I.arith{a=I.SH3ADDL,r1=r1,r2=r2,t=d}])
-    )
-    (val signed   = true)
+
+     val signed   = true)
 
    fun error msg = MLRiscErrorMsg.error("Hppa",msg)
 
diff --git a/hppa/mltree/hppaMillicode.sig b/hppa/mltree/hppaMillicode.sig
index 936dd90..d801996 100644
--- a/hppa/mltree/hppaMillicode.sig
+++ b/hppa/mltree/hppaMillicode.sig
@@ -1,6 +1,15 @@
 signature HPPA_MILLICODE = sig
   structure I : HPPAINSTR
-  structure CB : CELLS_BASIS =  CellsBasis
+  structure CB : CELLS_BASIS (* = CellsBasis *)
+                 where type CellSet.cellset = CellsBasis.CellSet.cellset
+                   and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                   and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                   and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                   and type cell = CellsBasis.cell
+                   and type cellColor = CellsBasis.cellColor
+                   and type cellkind = CellsBasis.cellkind
+                   and type cellkindDesc = CellsBasis.cellkindDesc
+                   and type cellkindInfo = CellsBasis.cellkindInfo
 
   val divu : {rs:CB.cell, rt:CB.cell, rd:CB.cell} -> I.instruction list
   val mulo : {rs:CB.cell, rt:CB.cell, rd:CB.cell} -> I.instruction list
diff --git a/instructions/insnProps.sig b/instructions/insnProps.sig
index 63fde27..29ed432 100644
--- a/instructions/insnProps.sig
+++ b/instructions/insnProps.sig
@@ -7,7 +7,7 @@ signature INSN_PROPERTIES =
 sig
    structure I : INSTRUCTIONS
    structure C : CELLS
-     sharing I.C = C
+     (* sharing I.C = C *)
 
       (* classify instructions *)
    datatype kind = IK_JUMP   (* branches, including returns *)
diff --git a/instructions/instructions.sig b/instructions/instructions.sig
index cbd007c..eb8a1b3 100644
--- a/instructions/instructions.sig
+++ b/instructions/instructions.sig
@@ -8,7 +8,16 @@
 signature INSTRUCTIONS =
 sig
    structure C   : CELLS
-   structure CB  :CELLS_BASIS = CellsBasis
+   structure CB  : CELLS_BASIS (* = CellsBasis *)
+                   where type CellSet.cellset = CellsBasis.CellSet.cellset
+                     and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                     and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                     and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                     and type cell = CellsBasis.cell
+                     and type cellColor = CellsBasis.cellColor
+                     and type cellkind = CellsBasis.cellkind
+                     and type cellkindDesc = CellsBasis.cellkindDesc
+                     and type cellkindInfo = CellsBasis.cellkindInfo
    type operand             (* operands supported by architecture *)
    type addressing_mode                        (* addressing mode *)
    type ea              (* effective address for accessing memory *)
diff --git a/instructions/mlriscAnnotations.sig b/instructions/mlriscAnnotations.sig
index 36c14af..39d87eb 100644
--- a/instructions/mlriscAnnotations.sig
+++ b/instructions/mlriscAnnotations.sig
@@ -15,7 +15,16 @@
 signature MLRISC_ANNOTATIONS =
 sig
 
-    structure C : CELLS_BASIS = CellsBasis
+    structure C : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
 
     (* 
      * The branch probability of conditional branches. 
diff --git a/library/dynamic-array.sml b/library/dynamic-array.sml
index 7733a6f..506581d 100644
--- a/library/dynamic-array.sml
+++ b/library/dynamic-array.sml
@@ -5,7 +5,33 @@
  *)
 
 structure DynArray : 
-  sig include ARRAY
+  sig type 'a array
+      type 'a vector
+
+      val all: ('a -> bool) -> 'a array -> bool
+      val app: ('a -> unit) -> 'a array -> unit
+      val appi: (int * 'a -> unit) -> 'a array -> unit
+      val array: int * 'a -> 'a array
+      val collate: ('a * 'a -> order) -> 'a array * 'a array -> order
+      val copy: {src: 'a array, dst: 'a array, di: int} -> unit
+      val copyVec: {src: 'a vector, dst: 'a array, di: int} -> unit
+      val exists: ('a -> bool) -> 'a array -> bool
+      val find: ('a -> bool) -> 'a array -> 'a option
+      val findi: (int * 'a -> bool) -> 'a array -> (int * 'a) option
+      val foldl: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
+      val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
+      val foldr: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
+      val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
+      val fromList: 'a list -> 'a array
+      val length: 'a array -> int
+      val maxLen: int
+      val modify: ('a -> 'a) -> 'a array -> unit
+      val modifyi: (int * 'a -> 'a) -> 'a array -> unit
+      val sub: 'a array * int -> 'a
+      val tabulate: int * (int -> 'a) -> 'a array
+      val update: 'a array * int * 'a -> unit
+      val vector: 'a array -> 'a vector
+
       val fromArray : 'a Array.array * 'a * int -> 'a array
       val baseArray : 'a array -> 'a Array.array
       val checkArray: 'a array * 'a Array.array -> unit
diff --git a/library/hash-array.sml b/library/hash-array.sml
index e50b34e..f11bc8a 100644
--- a/library/hash-array.sml
+++ b/library/hash-array.sml
@@ -5,7 +5,33 @@
  *)
 
 structure HashArray : 
-     sig include ARRAY
+     sig type 'a array
+         type 'a vector
+
+         val all: ('a -> bool) -> 'a array -> bool
+         val app: ('a -> unit) -> 'a array -> unit
+         val appi: (int * 'a -> unit) -> 'a array -> unit
+         val array: int * 'a -> 'a array
+         val collate: ('a * 'a -> order) -> 'a array * 'a array -> order
+         val copy: {src: 'a array, dst: 'a array, di: int} -> unit
+         val copyVec: {src: 'a vector, dst: 'a array, di: int} -> unit
+         val exists: ('a -> bool) -> 'a array -> bool
+         val find: ('a -> bool) -> 'a array -> 'a option
+         val findi: (int * 'a -> bool) -> 'a array -> (int * 'a) option
+         val foldl: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
+         val foldli: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
+         val foldr: ('a * 'b -> 'b) -> 'b -> 'a array -> 'b
+         val foldri: (int * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b
+         val fromList: 'a list -> 'a array
+         val length: 'a array -> int
+         val maxLen: int
+         val modify: ('a -> 'a) -> 'a array -> unit
+         val modifyi: (int * 'a -> 'a) -> 'a array -> unit
+         val sub: 'a array * int -> 'a
+         val tabulate: int * (int -> 'a) -> 'a array
+         val update: 'a array * int * 'a -> unit
+         val vector: 'a array -> 'a vector
+
          val array' : int * (int -> 'a) -> 'a array
          val array'': int * (int -> 'a) -> 'a array
          val clear  : 'a array -> unit 
diff --git a/mlb/ALPHA.mlb b/mlb/ALPHA.mlb
new file mode 100644
index 0000000..d1874c1
--- /dev/null
+++ b/mlb/ALPHA.mlb
@@ -0,0 +1,474 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l42 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l136 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l50 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l9 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = FREQUENCY_PROPERTIES
+   end
+   local
+      open l9
+   in
+      signature gs_1 = PROBABILITY
+      structure gs_2 = Probability
+   end
+   local
+      open l4
+   in
+      structure gs_3 = MLRiscAnnotations
+   end
+   local
+      open l4
+   in
+      signature gs_4 = REGION
+   end
+   local
+      open l4
+   in
+      signature gs_5 = CONSTANT
+   end
+   local
+      open l4
+   in
+      signature gs_6 = MLTREE
+   end
+   local
+      open l4
+   in
+      signature gs_7 = CELLS_BASIS
+   end
+   local
+      open l4
+   in
+      structure gs_8 = CellsBasis
+   end
+   local
+      open l4
+   in
+      structure gs_9 = Label
+   end
+   local
+      open l9
+   in
+      structure gs_10 = Annotations
+   end
+   local
+      open l4
+   in
+      functor gs_11 = Cells
+   end
+   local
+      open l42
+   in
+      structure gs_12 = Int
+   end
+   local
+      open l4
+   in
+      signature gs_13 = CELLS
+   end
+   local
+      open l50
+   in
+      signature gs_14 = MLRISC_ERROR_MSG
+      structure gs_15 = MLRiscErrorMsg
+   end
+   local
+      signature CELLS = gs_13
+      functor Cells = gs_11
+      structure CellsBasis = gs_8
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      ../alpha/instructions/alphaCells.sml
+   in
+      signature gs_16 = ALPHACELLS
+      structure gs_17 = AlphaCells
+   end
+   local
+      signature ALPHACELLS = gs_16
+      structure AlphaCells = gs_17
+      structure Annotations = gs_10
+      signature CELLS_BASIS = gs_7
+      signature CONSTANT = gs_5
+      structure CellsBasis = gs_8
+      structure Label = gs_9
+      signature MLTREE = gs_6
+      signature REGION = gs_4
+      ../alpha/instructions/alphaInstr.sml
+   in
+      signature gs_18 = ALPHAINSTR
+      functor gs_19 = AlphaInstr
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      functor AlphaInstr = gs_19
+      signature FREQUENCY_PROPERTIES = gs_0
+      structure MLRiscAnnotations = gs_3
+      signature PROBABILITY = gs_1
+      structure Probability = gs_2
+      ../alpha/instructions/alphaFreqProps.sml
+   in
+      functor gs_20 = AlphaFreqProps
+   end
+   local
+      open l4
+   in
+      signature gs_21 = INSN_PROPERTIES
+   end
+   local
+      open l42
+   in
+      structure gs_22 = Option
+   end
+   local
+      open l42
+   in
+      structure gs_23 = Word
+   end
+   local
+      open l4
+   in
+      signature gs_24 = MLTREE_EVAL
+   end
+   local
+      open l4
+   in
+      signature gs_25 = MLTREE_HASH
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      functor AlphaInstr = gs_19
+      structure CellsBasis = gs_8
+      signature INSN_PROPERTIES = gs_21
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_24
+      signature MLTREE_HASH = gs_25
+      structure Option = gs_22
+      structure Word = gs_23
+      ../alpha/instructions/alphaProps.sml
+   in
+      functor gs_26 = AlphaProps
+   end
+   local
+      open l4
+   in
+      signature gs_27 = SDI_JUMPS
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      functor AlphaInstr = gs_19
+      structure CellsBasis = gs_8
+      ../alpha/instructions/alphaShuffle.sig
+   in
+      signature gs_28 = ALPHASHUFFLE
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      signature ALPHASHUFFLE = gs_28
+      functor AlphaInstr = gs_19
+      structure CellsBasis = gs_8
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_24
+      structure Option = gs_22
+      signature SDI_JUMPS = gs_27
+      ../alpha/backpatch/alphaJumps.sml
+   in
+      functor gs_29 = AlphaJumps
+   end
+   local
+      open l4
+   in
+      signature gs_30 = INSTRUCTION_EMITTER
+   end
+   local
+      open l4
+   in
+      signature gs_31 = ASM_FORMAT_UTIL
+      structure gs_32 = AsmFormatUtil
+   end
+   local
+      open l4
+   in
+      signature gs_33 = ASM_STREAM
+      structure gs_34 = AsmStream
+   end
+   local
+      open l42
+   in
+      structure gs_35 = TextIO
+   end
+   local
+      open l42
+   in
+      structure gs_36 = String
+   end
+   local
+      open l4
+   in
+      structure gs_37 = AsmFlags
+   end
+   local
+      open l4
+   in
+      signature gs_38 = INSTRUCTION_STREAM
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      signature ALPHASHUFFLE = gs_28
+      signature ASM_FORMAT_UTIL = gs_31
+      signature ASM_STREAM = gs_33
+      functor AlphaInstr = gs_19
+      structure Annotations = gs_10
+      structure AsmFlags = gs_37
+      structure AsmFormatUtil = gs_32
+      structure AsmStream = gs_34
+      structure CellsBasis = gs_8
+      signature INSTRUCTION_EMITTER = gs_30
+      signature INSTRUCTION_STREAM = gs_38
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_24
+      structure String = gs_36
+      structure TextIO = gs_35
+      ../alpha/emit/alphaAsm.sml
+   in
+      functor gs_39 = AlphaAsmEmitter
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      functor AlphaInstr = gs_19
+      structure CellsBasis = gs_8
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      ../alpha/ra/alphaRewrite.sml
+   in
+      functor gs_40 = AlphaRewrite
+   end
+   local
+      open l4
+   in
+      signature gs_41 = PSEUDO_OPS_BASIS
+   end
+   local
+      open l4
+   in
+      functor gs_42 = GasPseudoOps
+   end
+   local
+      open l4
+   in
+      functor gs_43 = PseudoOpsLittle
+   end
+   local
+      open l136
+   in
+      structure gs_44 = Format
+   end
+   local
+      open l4
+   in
+      structure gs_45 = PseudoOpsBasisTyp
+   end
+   local
+      open l42
+   in
+      structure gs_46 = Word32
+   end
+   local
+      structure Format = gs_44
+      functor GasPseudoOps = gs_42
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE = gs_6
+      signature MLTREE_EVAL = gs_24
+      signature PSEUDO_OPS_BASIS = gs_41
+      structure PseudoOpsBasisTyp = gs_45
+      functor PseudoOpsLittle = gs_43
+      structure Word32 = gs_46
+      ../alpha/flowgraph/alphaGasPseudoOps.sml
+   in
+      functor gs_47 = AlphaGasPseudoOps
+   end
+   local
+      open l4
+   in
+      signature gs_48 = ARCH_SPILL_INSTR
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      signature ARCH_SPILL_INSTR = gs_48
+      functor AlphaInstr = gs_19
+      functor AlphaRewrite = gs_40
+      structure CellsBasis = gs_8
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      ../alpha/ra/alphaSpillInstr.sml
+   in
+      functor gs_49 = AlphaSpillInstr
+   end
+   local
+      open l4
+   in
+      functor gs_50 = MLTreeMult
+   end
+   local
+      open l4
+   in
+      functor gs_51 = MLTreeGen
+   end
+   local
+      open l42
+   in
+      structure gs_52 = IntInf
+   end
+   local
+      open l42
+   in
+      structure gs_53 = Int32
+   end
+   local
+      open l42
+   in
+      structure gs_54 = List
+   end
+   local
+      open l4
+   in
+      signature gs_55 = MLTREECOMP
+      signature gs_56 = MLTREE_EXTENSION_COMP
+   end
+   local
+      signature ALPHACELLS = gs_16
+      signature ALPHAINSTR = gs_18
+      structure AlphaCells = gs_17
+      functor AlphaInstr = gs_19
+      signature CELLS_BASIS = gs_7
+      structure CellsBasis = gs_8
+      signature MLTREE = gs_6
+      ../alpha/mltree/alphaPseudoInstr.sig
+   in
+      signature gs_57 = ALPHA_PSEUDO_INSTR
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      signature ALPHA_PSEUDO_INSTR = gs_57
+      functor AlphaInstr = gs_19
+      structure CellsBasis = gs_8
+      structure Int32 = gs_53
+      structure IntInf = gs_52
+      structure Label = gs_9
+      structure List = gs_54
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscAnnotations = gs_3
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREECOMP = gs_55
+      signature MLTREE_EXTENSION_COMP = gs_56
+      functor MLTreeGen = gs_51
+      functor MLTreeMult = gs_50
+      structure Word = gs_23
+      structure Word32 = gs_46
+      ../alpha/mltree/alpha.sml
+   in
+      functor gs_58 = Alpha
+   end
+   local
+      open l4
+   in
+      functor gs_59 = Shuffle
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      signature ALPHASHUFFLE = gs_28
+      functor AlphaInstr = gs_19
+      structure CellsBasis = gs_8
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      structure Option = gs_22
+      functor Shuffle = gs_59
+      ../alpha/instructions/alphaShuffle.sml
+   in
+      functor gs_60 = AlphaShuffle
+   end
+   local
+      open l42
+   in
+      structure gs_61 = Word8
+   end
+   local
+      open l4
+   in
+      signature gs_62 = CODE_STRING
+   end
+   local
+      signature ALPHAINSTR = gs_18
+      functor AlphaInstr = gs_19
+      signature CODE_STRING = gs_62
+      structure CellsBasis = gs_8
+      signature INSTRUCTION_EMITTER = gs_30
+      signature INSTRUCTION_STREAM = gs_38
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_24
+      structure Option = gs_22
+      structure Word32 = gs_46
+      structure Word8 = gs_61
+      ../alpha/emit/alphaMC.sml
+   in
+      functor gs_63 = AlphaMCEmitter
+   end
+in
+   signature ALPHACELLS = gs_16
+   signature ALPHAINSTR = gs_18
+   signature ALPHASHUFFLE = gs_28
+   signature ALPHA_PSEUDO_INSTR = gs_57
+   functor Alpha = gs_58
+   functor AlphaAsmEmitter = gs_39
+   structure AlphaCells = gs_17
+   functor AlphaFreqProps = gs_20
+   functor AlphaGasPseudoOps = gs_47
+   functor AlphaInstr = gs_19
+   functor AlphaJumps = gs_29
+   functor AlphaMCEmitter = gs_63
+   functor AlphaProps = gs_26
+   functor AlphaRewrite = gs_40
+   functor AlphaShuffle = gs_60
+   functor AlphaSpillInstr = gs_49
+end
+end
+
+end
diff --git a/mlb/AMD64-Peephole.mlb b/mlb/AMD64-Peephole.mlb
new file mode 100644
index 0000000..4a9607e
--- /dev/null
+++ b/mlb/AMD64-Peephole.mlb
@@ -0,0 +1,60 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l8 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l4 =
+    bas
+      (* $Peephole.cm(=(proxyLib.cm):.)/Peephole.cm =??=> *) Peephole.mlb
+    end
+  basis l16 =
+    bas
+      (* $AMD64.cm(=(proxyLib.cm):.)/AMD64.cm =??=> *) AMD64.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = PEEPHOLE
+   end
+   local
+      open l8
+   in
+      structure gs_1 = CellsBasis
+   end
+   local
+      open l8
+   in
+      signature gs_2 = MLTREE_EVAL
+   end
+   local
+      open l16
+   in
+      signature gs_3 = AMD64INSTR
+      functor gs_4 = AMD64Instr
+   end
+   local
+      signature AMD64INSTR = gs_3
+      functor AMD64Instr = gs_4
+      structure CellsBasis = gs_1
+      signature MLTREE_EVAL = gs_2
+      signature PEEPHOLE = gs_0
+      ../amd64/instructions/amd64Peephole.sml
+   in
+      functor gs_5 = AMD64Peephole
+   end
+in
+   functor AMD64Peephole = gs_5
+end
+end
+
+end
diff --git a/mlb/AMD64.mlb b/mlb/AMD64.mlb
new file mode 100644
index 0000000..1ebc214
--- /dev/null
+++ b/mlb/AMD64.mlb
@@ -0,0 +1,747 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l4 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l108 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l9 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l46 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l119 =
+    bas
+      (* $Graphs.cm(=(proxyLib.cm):.)/Graphs.cm =??=> *) Graphs.mlb
+    end
+  basis l34 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+  basis l145 =
+    bas
+      (* $MLTREE.cm(=(proxyLib.cm):.)/MLTREE.cm =??=> *) MLTREE.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = Int
+   end
+   local
+      open l9
+   in
+      signature gs_1 = REGION
+   end
+   local
+      open l9
+   in
+      signature gs_2 = CONSTANT
+   end
+   local
+      open l9
+   in
+      signature gs_3 = MLTREE
+   end
+   local
+      open l9
+   in
+      signature gs_4 = CELLS_BASIS
+   end
+   local
+      open l9
+   in
+      structure gs_5 = CellsBasis
+   end
+   local
+      open l9
+   in
+      structure gs_6 = Label
+   end
+   local
+      open l4
+   in
+      structure gs_7 = Int64
+   end
+   local
+      open l4
+   in
+      structure gs_8 = Int32
+   end
+   local
+      open l34
+   in
+      structure gs_9 = Annotations
+   end
+   local
+      open l9
+   in
+      functor gs_10 = Cells
+   end
+   local
+      open l9
+   in
+      signature gs_11 = CELLS
+   end
+   local
+      open l46
+   in
+      signature gs_12 = MLRISC_ERROR_MSG
+      structure gs_13 = MLRiscErrorMsg
+   end
+   local
+      signature CELLS = gs_11
+      functor Cells = gs_10
+      structure CellsBasis = gs_5
+      structure Int = gs_0
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      ../amd64/instructions/amd64Cells.sml
+   in
+      signature gs_14 = AMD64CELLS
+      structure gs_15 = AMD64Cells
+   end
+   local
+      signature AMD64CELLS = gs_14
+      structure AMD64Cells = gs_15
+      structure Annotations = gs_9
+      signature CELLS_BASIS = gs_4
+      signature CONSTANT = gs_2
+      structure CellsBasis = gs_5
+      structure Int32 = gs_8
+      structure Int64 = gs_7
+      structure Label = gs_6
+      signature MLTREE = gs_3
+      signature REGION = gs_1
+      ../amd64/instructions/amd64Instr.sml
+   in
+      signature gs_16 = AMD64INSTR
+      functor gs_17 = AMD64Instr
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      structure Int = gs_0
+      ../amd64/mltree/amd64-opcodes.sml
+   in
+      functor gs_18 = AMD64Opcodes
+   end
+   local
+      open l9
+   in
+      signature gs_19 = MC_EMIT
+   end
+   local
+      open l4
+   in
+      structure gs_20 = Word32
+   end
+   local
+      open l4
+   in
+      structure gs_21 = Word8
+   end
+   local
+      open l4
+   in
+      structure gs_22 = LargeWord
+   end
+   local
+      open l4
+   in
+      structure gs_23 = Word8Vector
+   end
+   local
+      open l4
+   in
+      structure gs_24 = Word
+   end
+   local
+      open l9
+   in
+      signature gs_25 = MLTREE_EVAL
+   end
+   local
+      open l9
+   in
+      functor gs_26 = Shuffle
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      structure CellsBasis = gs_5
+      functor Shuffle = gs_26
+      ../amd64/instructions/amd64Shuffle.sml
+   in
+      signature gs_27 = AMD64SHUFFLE
+      functor gs_28 = AMD64Shuffle
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      signature AMD64SHUFFLE = gs_27
+      functor AMD64Shuffle = gs_28
+      structure CellsBasis = gs_5
+      structure Int32 = gs_8
+      structure LargeWord = gs_22
+      signature MC_EMIT = gs_19
+      signature MLTREE_EVAL = gs_25
+      structure Word = gs_24
+      structure Word32 = gs_20
+      structure Word8 = gs_21
+      structure Word8Vector = gs_23
+      ../amd64/amd64MCFn.sml
+   in
+      functor gs_29 = AMD64MCFn
+   end
+   local
+      open l4
+   in
+      structure gs_30 = Word64
+   end
+   local
+      open l9
+   in
+      signature gs_31 = INSTRUCTION_EMITTER
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      signature AMD64SHUFFLE = gs_27
+      functor AMD64Shuffle = gs_28
+      structure CellsBasis = gs_5
+      signature INSTRUCTION_EMITTER = gs_31
+      structure Int = gs_0
+      structure Int32 = gs_8
+      structure Int64 = gs_7
+      structure LargeWord = gs_22
+      signature MC_EMIT = gs_19
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_25
+      structure Word = gs_24
+      structure Word32 = gs_20
+      structure Word64 = gs_30
+      structure Word8 = gs_21
+      structure Word8Vector = gs_23
+      ../amd64/amd64MC.sml
+   in
+      functor gs_32 = AMD64MCEmitter
+   end
+   local
+      open l9
+   in
+      signature gs_33 = OMIT_FRAME_POINTER
+   end
+   local
+      open l108
+   in
+      structure gs_34 = IntHashTable
+   end
+   local
+      open l46
+   in
+      signature gs_35 = MLRISC_CONTROL
+      structure gs_36 = MLRiscControl
+   end
+   local
+      open l9
+   in
+      structure gs_37 = MLRiscAnnotations
+   end
+   local
+      open l119
+   in
+      structure gs_38 = Graph
+   end
+   local
+      open l4
+   in
+      structure gs_39 = General
+   end
+   local
+      open l4
+   in
+      structure gs_40 = ListPair
+   end
+   local
+      open l4
+   in
+      structure gs_41 = Option
+   end
+   local
+      open l9
+   in
+      signature gs_42 = CONTROL_FLOW_GRAPH
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      signature CONTROL_FLOW_GRAPH = gs_42
+      structure CellsBasis = gs_5
+      structure General = gs_39
+      structure Graph = gs_38
+      structure Int = gs_0
+      structure Int32 = gs_8
+      structure IntHashTable = gs_34
+      structure ListPair = gs_40
+      signature MLRISC_CONTROL = gs_35
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscAnnotations = gs_37
+      structure MLRiscControl = gs_36
+      structure MLRiscErrorMsg = gs_13
+      signature OMIT_FRAME_POINTER = gs_33
+      structure Option = gs_41
+      ../amd64/omit-frameptr/amd64omit-frameptr.sml
+   in
+      functor gs_43 = AMD64OmitFramePointer
+   end
+   local
+      open l9
+   in
+      signature gs_44 = C_CALLS
+   end
+   local
+      open l9
+   in
+      structure gs_45 = CTypes
+   end
+   local
+      open l145
+   in
+      functor gs_46 = MLTreeUtils
+   end
+   local
+      open l4
+   in
+      structure gs_47 = IntInf
+   end
+   local
+      open l4
+   in
+      structure gs_48 = String
+   end
+   local
+      open l4
+   in
+      structure gs_49 = List
+   end
+   local
+      signature AMD64CELLS = gs_14
+      structure AMD64Cells = gs_15
+      structure CTypes = gs_45
+      signature C_CALLS = gs_44
+      structure CellsBasis = gs_5
+      structure Int = gs_0
+      structure Int32 = gs_8
+      structure IntInf = gs_47
+      structure List = gs_49
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscAnnotations = gs_37
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE = gs_3
+      functor MLTreeUtils = gs_46
+      structure String = gs_48
+      structure Word = gs_24
+      ../amd64/c-calls/amd64-svid.sml
+   in
+      functor gs_50 = AMD64SVID_CCalls
+   end
+   local
+      open l9
+   in
+      signature gs_51 = PSEUDO_OPS_BASIS
+   end
+   local
+      open l9
+   in
+      functor gs_52 = GasPseudoOps
+   end
+   local
+      open l9
+   in
+      functor gs_53 = PseudoOpsLittle
+   end
+   local
+      open l108
+   in
+      structure gs_54 = Format
+   end
+   local
+      open l9
+   in
+      structure gs_55 = PseudoOpsBasisTyp
+   end
+   local
+      structure Format = gs_54
+      functor GasPseudoOps = gs_52
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE = gs_3
+      signature MLTREE_EVAL = gs_25
+      signature PSEUDO_OPS_BASIS = gs_51
+      structure PseudoOpsBasisTyp = gs_55
+      functor PseudoOpsLittle = gs_53
+      structure Word32 = gs_20
+      ../amd64/flowgraph/amd64GasPseudoOps.sml
+   in
+      functor gs_56 = AMD64GasPseudoOps
+   end
+   local
+      open l9
+   in
+      signature gs_57 = MLTREE_HASH
+   end
+   local
+      open l9
+   in
+      signature gs_58 = INSN_PROPERTIES
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      structure CellsBasis = gs_5
+      signature INSN_PROPERTIES = gs_58
+      structure Int = gs_0
+      structure Int32 = gs_8
+      structure Int64 = gs_7
+      structure Label = gs_6
+      structure List = gs_49
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_25
+      signature MLTREE_HASH = gs_57
+      structure Word = gs_24
+      ../amd64/instructions/amd64Props.sml
+   in
+      signature gs_59 = AMD64INSN_PROPERTIES
+      functor gs_60 = AMD64Props
+   end
+   local
+      open l9
+   in
+      signature gs_61 = SDI_JUMPS
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      signature AMD64SHUFFLE = gs_27
+      functor AMD64Shuffle = gs_28
+      signature MC_EMIT = gs_19
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_25
+      signature SDI_JUMPS = gs_61
+      structure Word8Vector = gs_23
+      ../amd64/backpatch/amd64Jumps.sml
+   in
+      functor gs_62 = AMD64Jumps
+   end
+   local
+      open l9
+   in
+      signature gs_63 = MLTREE_STREAM
+   end
+   local
+      ../amd64/instructions/amd64InstrExt.sml
+   in
+      structure gs_64 = AMD64InstrExt
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      structure AMD64InstrExt = gs_64
+      signature CONTROL_FLOW_GRAPH = gs_42
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_STREAM = gs_63
+      ../amd64/instructions/amd64CompInstrExt.sml
+   in
+      signature gs_65 = AMD64COMP_INSTR_EXT
+      functor gs_66 = AMD64CompInstrExt
+   end
+   local
+      open l9
+   in
+      functor gs_67 = DarwinPseudoOps
+   end
+   local
+      functor DarwinPseudoOps = gs_67
+      structure Format = gs_54
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE = gs_3
+      signature MLTREE_EVAL = gs_25
+      signature PSEUDO_OPS_BASIS = gs_51
+      structure PseudoOpsBasisTyp = gs_55
+      functor PseudoOpsLittle = gs_53
+      structure Word32 = gs_20
+      ../amd64/flowgraph/amd64-darwin-pseudo-ops.sml
+   in
+      functor gs_68 = AMD64DarwinPseudoOps
+   end
+   local
+      open l9
+   in
+      signature gs_69 = ASM_FORMAT_UTIL
+      structure gs_70 = AsmFormatUtil
+   end
+   local
+      open l9
+   in
+      signature gs_71 = ASM_STREAM
+      structure gs_72 = AsmStream
+   end
+   local
+      open l4
+   in
+      structure gs_73 = TextIO
+   end
+   local
+      open l4
+   in
+      structure gs_74 = Char
+   end
+   local
+      open l9
+   in
+      structure gs_75 = AsmFlags
+   end
+   local
+      open l9
+   in
+      signature gs_76 = INSTRUCTION_STREAM
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      signature AMD64SHUFFLE = gs_27
+      functor AMD64Shuffle = gs_28
+      signature ASM_FORMAT_UTIL = gs_69
+      signature ASM_STREAM = gs_71
+      structure Annotations = gs_9
+      structure AsmFlags = gs_75
+      structure AsmFormatUtil = gs_70
+      structure AsmStream = gs_72
+      structure CellsBasis = gs_5
+      structure Char = gs_74
+      signature INSTRUCTION_EMITTER = gs_31
+      signature INSTRUCTION_STREAM = gs_76
+      structure Int = gs_0
+      structure Int32 = gs_8
+      structure Int64 = gs_7
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_25
+      structure String = gs_48
+      structure TextIO = gs_73
+      ../amd64/emit/amd64Asm.sml
+   in
+      functor gs_77 = AMD64AsmEmitter
+   end
+   local
+      open l9
+   in
+      signature gs_78 = CFG_OPTIMIZATION
+   end
+   local
+      open l9
+   in
+      functor gs_79 = GetReg
+   end
+   local
+      open l9
+   in
+      signature gs_80 = PRINT_FLOWGRAPH
+      functor gs_81 = PrintFlowgraph
+   end
+   local
+      open l9
+   in
+      functor gs_82 = RegisterAllocator
+   end
+   local
+      open l9
+   in
+      functor gs_83 = MemoryRA
+   end
+   local
+      open l9
+   in
+      functor gs_84 = RADeadCodeElim
+   end
+   local
+      open l9
+   in
+      functor gs_85 = ClusterRA
+   end
+   local
+      open l4
+   in
+      structure gs_86 = Vector
+   end
+   local
+      open l9
+   in
+      signature gs_87 = RA_SPILL
+   end
+   local
+      open l9
+   in
+      signature gs_88 = RA_SPILL_HEURISTICS
+   end
+   local
+      open l9
+   in
+      structure gs_89 = RAGraph
+   end
+   local
+      open l9
+   in
+      signature gs_90 = ARCH_SPILL_INSTR
+   end
+   local
+      signature AMD64INSN_PROPERTIES = gs_59
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      functor AMD64Props = gs_60
+      signature ARCH_SPILL_INSTR = gs_90
+      structure Annotations = gs_9
+      structure CellsBasis = gs_5
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscAnnotations = gs_37
+      structure MLRiscErrorMsg = gs_13
+      ../amd64/ra/amd64SpillInstr.sml
+   in
+      functor gs_91 = AMD64SpillInstr
+   end
+   local
+      signature AMD64INSN_PROPERTIES = gs_59
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      functor AMD64Props = gs_60
+      functor AMD64SpillInstr = gs_91
+      structure Annotations = gs_9
+      signature CFG_OPTIMIZATION = gs_78
+      signature CONTROL_FLOW_GRAPH = gs_42
+      structure CellsBasis = gs_5
+      functor ClusterRA = gs_85
+      functor GetReg = gs_79
+      structure Graph = gs_38
+      signature INSTRUCTION_EMITTER = gs_31
+      structure IntHashTable = gs_34
+      structure List = gs_49
+      signature MLRISC_CONTROL = gs_35
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscControl = gs_36
+      structure MLRiscErrorMsg = gs_13
+      functor MemoryRA = gs_83
+      structure Option = gs_41
+      signature PRINT_FLOWGRAPH = gs_80
+      functor PrintFlowgraph = gs_81
+      functor RADeadCodeElim = gs_84
+      structure RAGraph = gs_89
+      signature RA_SPILL = gs_87
+      signature RA_SPILL_HEURISTICS = gs_88
+      functor RegisterAllocator = gs_82
+      structure Vector = gs_86
+      ../amd64/ra/amd64RegAlloc.sml
+   in
+      functor gs_92 = AMD64RegAlloc
+   end
+   local
+      open l9
+   in
+      functor gs_93 = MLTreeGen
+   end
+   local
+      open l9
+   in
+      functor gs_94 = MLTreeSize
+   end
+   local
+      open l34
+   in
+      signature gs_95 = PROBABILITY
+      structure gs_96 = Probability
+   end
+   local
+      open l9
+   in
+      signature gs_97 = MLTREECOMP
+      signature gs_98 = MLTREE_EXTENSION_COMP
+   end
+   local
+      open l145
+   in
+      signature gs_99 = MLTREE_UTILS
+   end
+   local
+      signature AMD64INSTR = gs_16
+      functor AMD64Instr = gs_17
+      functor AMD64Opcodes = gs_18
+      structure CellsBasis = gs_5
+      structure Int32 = gs_8
+      structure Int64 = gs_7
+      structure IntInf = gs_47
+      structure Label = gs_6
+      structure List = gs_49
+      structure ListPair = gs_40
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscAnnotations = gs_37
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREECOMP = gs_97
+      signature MLTREE_EXTENSION_COMP = gs_98
+      signature MLTREE_UTILS = gs_99
+      functor MLTreeGen = gs_93
+      functor MLTreeSize = gs_94
+      signature PROBABILITY = gs_95
+      structure Probability = gs_96
+      functor Shuffle = gs_26
+      structure Word = gs_24
+      structure Word32 = gs_20
+      ../amd64/mltree/amd64-gen.sml
+   in
+      functor gs_100 = AMD64Gen
+   end
+in
+   functor AMD64AsmEmitter = gs_77
+   signature AMD64CELLS = gs_14
+   structure AMD64Cells = gs_15
+   functor AMD64CompInstrExt = gs_66
+   functor AMD64DarwinPseudoOps = gs_68
+   functor AMD64GasPseudoOps = gs_56
+   functor AMD64Gen = gs_100
+   signature AMD64INSN_PROPERTIES = gs_59
+   signature AMD64INSTR = gs_16
+   functor AMD64Instr = gs_17
+   structure AMD64InstrExt = gs_64
+   functor AMD64Jumps = gs_62
+   functor AMD64MCEmitter = gs_32
+   functor AMD64MCFn = gs_29
+   functor AMD64OmitFramePointer = gs_43
+   functor AMD64Opcodes = gs_18
+   functor AMD64Props = gs_60
+   functor AMD64RegAlloc = gs_92
+   signature AMD64SHUFFLE = gs_27
+   functor AMD64SVID_CCalls = gs_50
+   functor AMD64Shuffle = gs_28
+   functor AMD64SpillInstr = gs_91
+end
+end
+
+end
diff --git a/mlb/CCall-sparc.mlb b/mlb/CCall-sparc.mlb
new file mode 100644
index 0000000..2ed4349
--- /dev/null
+++ b/mlb/CCall-sparc.mlb
@@ -0,0 +1,118 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l29 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l33 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l8 =
+    bas
+      (* $StagedAlloc.cm(=(proxyLib.cm):.)/StagedAlloc.cm =??=> *) StagedAlloc.mlb
+    end
+  basis l4 =
+    bas
+      (* $CCall.cm(=(proxyLib.cm):.)/CCall.cm =??=> *) CCall.mlb
+    end
+  basis l19 =
+    bas
+      (* $SPARC.cm(=(proxyLib.cm):.)/SPARC.cm =??=> *) SPARC.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = C_CALL
+   end
+   local
+      open l8
+   in
+      functor gs_1 = SparcCConventionFn
+   end
+   local
+      open l4
+   in
+      functor gs_2 = CCallGenFn
+   end
+   local
+      open l8
+   in
+      functor gs_3 = StagedAllocationFn
+   end
+   local
+      open l19
+   in
+      signature gs_4 = SPARCCELLS
+      structure gs_5 = SparcCells
+   end
+   local
+      open l4
+   in
+      structure gs_6 = CType
+   end
+   local
+      open l8
+   in
+      structure gs_7 = CLocKind
+   end
+   local
+      open l29
+   in
+      structure gs_8 = List
+   end
+   local
+      open l33
+   in
+      signature gs_9 = MLTREE
+   end
+   local
+      open l19
+   in
+      structure gs_10 = SparcInstrExt
+   end
+   local
+      open l29
+   in
+      structure gs_11 = Int
+   end
+   local
+      structure CType = gs_6
+      structure Int = gs_11
+      ../c-call/archs/sparc-c-sizes.sml
+   in
+      structure gs_12 = SparcCSizes
+   end
+   local
+      functor CCallGenFn = gs_2
+      structure CLocKind = gs_7
+      structure CType = gs_6
+      signature C_CALL = gs_0
+      structure List = gs_8
+      signature MLTREE = gs_9
+      signature SPARCCELLS = gs_4
+      functor SparcCConventionFn = gs_1
+      structure SparcCSizes = gs_12
+      structure SparcCells = gs_5
+      structure SparcInstrExt = gs_10
+      functor StagedAllocationFn = gs_3
+      ../c-call/archs/sparc-c-call-fn.sml
+   in
+      functor gs_13 = SparcCCallFn
+   end
+in
+   functor SparcCCallFn = gs_13
+   structure SparcCSizes = gs_12
+end
+end
+
+end
diff --git a/mlb/CCall-x86-64.mlb b/mlb/CCall-x86-64.mlb
new file mode 100644
index 0000000..51fa89e
--- /dev/null
+++ b/mlb/CCall-x86-64.mlb
@@ -0,0 +1,125 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l8 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l29 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l19 =
+    bas
+      (* $StagedAlloc.cm(=(proxyLib.cm):.)/StagedAlloc.cm =??=> *) StagedAlloc.mlb
+    end
+  basis l4 =
+    bas
+      (* $CCall.cm(=(proxyLib.cm):.)/CCall.cm =??=> *) CCall.mlb
+    end
+  basis l34 =
+    bas
+      (* $AMD64.cm(=(proxyLib.cm):.)/AMD64.cm =??=> *) AMD64.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = CType
+   end
+   local
+      open l8
+   in
+      structure gs_1 = Word
+   end
+   local
+      open l8
+   in
+      structure gs_2 = Int
+   end
+   local
+      structure CType = gs_0
+      structure Int = gs_2
+      structure Word = gs_1
+      ../c-call/archs/x86-64-c-sizes.sml
+   in
+      structure gs_3 = CSizes
+   end
+   local
+      open l19
+   in
+      functor gs_4 = X86_64CConventionFn
+   end
+   local
+      open l4
+   in
+      functor gs_5 = CCallGenFn
+   end
+   local
+      open l19
+   in
+      functor gs_6 = StagedAllocationFn
+   end
+   local
+      open l29
+   in
+      structure gs_7 = CellsBasis
+   end
+   local
+      open l34
+   in
+      signature gs_8 = AMD64CELLS
+      structure gs_9 = AMD64Cells
+   end
+   local
+      open l19
+   in
+      structure gs_10 = CLocKind
+   end
+   local
+      open l8
+   in
+      structure gs_11 = String
+   end
+   local
+      open l8
+   in
+      structure gs_12 = List
+   end
+   local
+      open l29
+   in
+      signature gs_13 = MLTREE
+   end
+   local
+      signature AMD64CELLS = gs_8
+      structure AMD64Cells = gs_9
+      functor CCallGenFn = gs_5
+      structure CLocKind = gs_10
+      structure CSizes = gs_3
+      structure CType = gs_0
+      structure CellsBasis = gs_7
+      structure Int = gs_2
+      structure List = gs_12
+      signature MLTREE = gs_13
+      functor StagedAllocationFn = gs_6
+      structure String = gs_11
+      functor X86_64CConventionFn = gs_4
+      ../c-call/archs/x86-64-svid-fn.sml
+   in
+      functor gs_14 = X86_64SVIDFn
+   end
+in
+   structure CSizes = gs_3
+   functor X86_64SVIDFn = gs_14
+end
+end
+
+end
diff --git a/mlb/CCall-x86.mlb b/mlb/CCall-x86.mlb
new file mode 100644
index 0000000..4168bb1
--- /dev/null
+++ b/mlb/CCall-x86.mlb
@@ -0,0 +1,155 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l8 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l32 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l22 =
+    bas
+      (* $StagedAlloc.cm(=(proxyLib.cm):.)/StagedAlloc.cm =??=> *) StagedAlloc.mlb
+    end
+  basis l4 =
+    bas
+      (* $CCall.cm(=(proxyLib.cm):.)/CCall.cm =??=> *) CCall.mlb
+    end
+  basis l37 =
+    bas
+      (* $IA32.cm(=(proxyLib.cm):.)/IA32.cm =??=> *) IA32.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = CType
+   end
+   local
+      open l8
+   in
+      structure gs_1 = Word
+   end
+   local
+      open l8
+   in
+      structure gs_2 = Int
+   end
+   local
+      structure CType = gs_0
+      structure Int = gs_2
+      structure Word = gs_1
+      ../c-call/archs/x86-c-sizes.sml
+   in
+      structure gs_3 = X86CSizes
+   end
+   local
+      open l4
+   in
+      signature gs_4 = C_CALL
+   end
+   local
+      open l22
+   in
+      functor gs_5 = X86CConventionFn
+   end
+   local
+      open l4
+   in
+      functor gs_6 = CCallGenFn
+   end
+   local
+      open l22
+   in
+      functor gs_7 = StagedAllocationFn
+   end
+   local
+      open l32
+   in
+      structure gs_8 = CellsBasis
+   end
+   local
+      open l37
+   in
+      signature gs_9 = X86CELLS
+      structure gs_10 = X86Cells
+   end
+   local
+      open l22
+   in
+      structure gs_11 = CLocKind
+   end
+   local
+      open l8
+   in
+      structure gs_12 = IntInf
+   end
+   local
+      open l32
+   in
+      structure gs_13 = MLRiscAnnotations
+   end
+   local
+      open l8
+   in
+      structure gs_14 = Int32
+   end
+   local
+      open l8
+   in
+      structure gs_15 = String
+   end
+   local
+      open l8
+   in
+      structure gs_16 = List
+   end
+   local
+      open l32
+   in
+      signature gs_17 = MLTREE
+   end
+   local
+      open l37
+   in
+      structure gs_18 = X86InstrExt
+   end
+   local
+      functor CCallGenFn = gs_6
+      structure CLocKind = gs_11
+      structure CType = gs_0
+      signature C_CALL = gs_4
+      structure CellsBasis = gs_8
+      structure Int = gs_2
+      structure Int32 = gs_14
+      structure IntInf = gs_12
+      structure List = gs_16
+      structure MLRiscAnnotations = gs_13
+      signature MLTREE = gs_17
+      functor StagedAllocationFn = gs_7
+      structure String = gs_15
+      functor X86CConventionFn = gs_5
+      signature X86CELLS = gs_9
+      structure X86CSizes = gs_3
+      structure X86Cells = gs_10
+      structure X86InstrExt = gs_18
+      ../c-call/archs/x86-svid-fn.sml
+   in
+      functor gs_19 = X86SVIDFn
+   end
+in
+   structure X86CSizes = gs_3
+   functor X86SVIDFn = gs_19
+end
+end
+
+end
diff --git a/mlb/CCall.mlb b/mlb/CCall.mlb
new file mode 100644
index 0000000..02e5019
--- /dev/null
+++ b/mlb/CCall.mlb
@@ -0,0 +1,96 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l20 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l9 =
+    bas
+      (* $StagedAlloc.cm(=(proxyLib.cm):.)/StagedAlloc.cm =??=> *) StagedAlloc.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = MLTREE
+   end
+   local
+      open l9
+   in
+      signature gs_1 = STAGED_ALLOCATION
+   end
+   local
+      open l9
+   in
+      structure gs_2 = CLocKind
+   end
+   local
+      structure CLocKind = gs_2
+      signature MLTREE = gs_0
+      signature STAGED_ALLOCATION = gs_1
+      ../c-call/gen/c-call-gen-sig.sml
+   in
+      signature gs_3 = C_CALL_GEN
+   end
+   local
+      open l20
+   in
+      structure gs_4 = List
+   end
+   local
+      structure List = gs_4
+      ../c-call/gen/c-type.sml
+   in
+      structure gs_5 = CType
+   end
+   local
+      structure CType = gs_5
+      signature C_CALL_GEN = gs_3
+      signature MLTREE = gs_0
+      ../c-call/gen/c-call-sig.sml
+   in
+      signature gs_6 = C_CALL
+   end
+   local
+      open l20
+   in
+      structure gs_7 = ListPair
+   end
+   local
+      open l4
+   in
+      signature gs_8 = CELLS
+   end
+   local
+      signature CELLS = gs_8
+      structure CLocKind = gs_2
+      signature C_CALL_GEN = gs_3
+      structure List = gs_4
+      structure ListPair = gs_7
+      signature MLTREE = gs_0
+      signature STAGED_ALLOCATION = gs_1
+      ../c-call/gen/c-call-gen-fn.sml
+   in
+      functor gs_9 = CCallGenFn
+   end
+in
+   functor CCallGenFn = gs_9
+   structure CType = gs_5
+   signature C_CALL = gs_6
+   signature C_CALL_GEN = gs_3
+end
+end
+
+end
diff --git a/mlb/Control.mlb b/mlb/Control.mlb
new file mode 100644
index 0000000..1d8454e
--- /dev/null
+++ b/mlb/Control.mlb
@@ -0,0 +1,104 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l4 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l28 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l12 =
+    bas
+      (* $/controls-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Controls/controls-lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = Timer
+   end
+   local
+      open l4
+   in
+      structure gs_1 = Time
+   end
+   local
+      open l12
+   in
+      structure gs_2 = Controls
+   end
+   local
+      open l12
+   in
+      structure gs_3 = ControlUtil
+   end
+   local
+      open l12
+   in
+      structure gs_4 = ControlSet
+   end
+   local
+      open l12
+   in
+      structure gs_5 = ControlRegistry
+   end
+   local
+      open l4
+   in
+      structure gs_6 = TextIO
+   end
+   local
+      open l28
+   in
+      structure gs_7 = Atom
+   end
+   local
+      structure Atom = gs_7
+      structure ControlRegistry = gs_5
+      structure ControlSet = gs_4
+      structure ControlUtil = gs_3
+      structure Controls = gs_2
+      structure TextIO = gs_6
+      structure Time = gs_1
+      ../control/mlrisc-control.sml
+   in
+      signature gs_8 = MLRISC_CONTROL
+      structure gs_9 = MLRiscControl
+   end
+   local
+      signature MLRISC_CONTROL = gs_8
+      structure MLRiscControl = gs_9
+      structure Time = gs_1
+      structure Timer = gs_0
+      ../control/mlrisc-timing.sml
+   in
+      signature gs_10 = MLRISC_TIMING
+      structure gs_11 = MLRiscTiming
+   end
+   local
+      structure TextIO = gs_6
+      ../control/mlriscErrormsg.sml
+   in
+      signature gs_12 = MLRISC_ERROR_MSG
+      structure gs_13 = MLRiscErrorMsg
+   end
+in
+   signature MLRISC_CONTROL = gs_8
+   signature MLRISC_ERROR_MSG = gs_12
+   signature MLRISC_TIMING = gs_10
+   structure MLRiscControl = gs_9
+   structure MLRiscErrorMsg = gs_13
+   structure MLRiscTiming = gs_11
+end
+end
+
+end
diff --git a/mlb/Graphs.mlb b/mlb/Graphs.mlb
new file mode 100644
index 0000000..f667605
--- /dev/null
+++ b/mlb/Graphs.mlb
@@ -0,0 +1,708 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l8 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l4 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l29 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = ListMergeSort
+   end
+   local
+      open l8
+   in
+      structure gs_1 = Int
+   end
+   local
+      open l8
+   in
+      structure gs_2 = List
+   end
+   local
+      ../graphs/graph.sig
+   in
+      signature gs_3 = GRAPH
+   end
+   local
+      signature GRAPH = gs_3
+      structure List = gs_2
+      ../graphs/graph.sml
+   in
+      structure gs_4 = Graph
+   end
+   local
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure ListMergeSort = gs_0
+      ../graphs/uniongraph.sml
+   in
+      signature gs_5 = UNION_GRAPH_VIEW
+      structure gs_6 = UnionGraphView
+   end
+   local
+      open l29
+   in
+      signature gs_7 = CATNETABLE_LIST
+      structure gs_8 = CatnetableList
+   end
+   local
+      open l8
+   in
+      structure gs_9 = Array
+   end
+   local
+      ../graphs/group.sig
+   in
+      signature gs_10 = ABELIAN_GROUP
+      signature gs_11 = ABELIAN_GROUP_WITH_INF
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      structure Graph = gs_4
+      ../graphs/min-cut.sig
+   in
+      signature gs_12 = MIN_CUT
+   end
+   local
+      open l8
+   in
+      signature gs_13 = ARRAY
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/node-priqueue.sig
+   in
+      signature gs_14 = NODE_PRIORITY_QUEUE
+   end
+   local
+      signature ARRAY = gs_13
+      structure Graph = gs_4
+      signature NODE_PRIORITY_QUEUE = gs_14
+      ../graphs/node-priqueue.sml
+   in
+      functor gs_15 = NodePriorityQueue
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      structure Array = gs_9
+      signature CATNETABLE_LIST = gs_7
+      structure CatnetableList = gs_8
+      structure Graph = gs_4
+      signature MIN_CUT = gs_12
+      functor NodePriorityQueue = gs_15
+      ../graphs/min-cut.sml
+   in
+      functor gs_16 = MinCut
+   end
+   local
+      structure Graph = gs_4
+      structure List = gs_2
+      ../graphs/isograph.sml
+   in
+      signature gs_17 = ISOMORPHIC_GRAPH_VIEW
+      structure gs_18 = IsomorphicGraphView
+   end
+   local
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure List = gs_2
+      ../graphs/seme.sml
+   in
+      signature gs_19 = SINGLE_ENTRY_MULTIPLE_EXIT_VIEW
+      structure gs_20 = SingleEntryMultipleExit
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graph-comb.sig
+   in
+      signature gs_21 = GRAPH_COMBINATIONS
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/revgraph.sml
+   in
+      signature gs_22 = REVERSED_GRAPH_VIEW
+      structure gs_23 = ReversedGraphView
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/renamegraph.sml
+   in
+      signature gs_24 = RENAMED_GRAPH_VIEW
+      structure gs_25 = RenamedGraphView
+   end
+   local
+      signature GRAPH_COMBINATIONS = gs_21
+      structure Graph = gs_4
+      signature RENAMED_GRAPH_VIEW = gs_24
+      signature REVERSED_GRAPH_VIEW = gs_22
+      structure RenamedGraphView = gs_25
+      structure ReversedGraphView = gs_23
+      signature UNION_GRAPH_VIEW = gs_5
+      structure UnionGraphView = gs_6
+      ../graphs/graph-comb.sml
+   in
+      structure gs_26 = GraphCombinations
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/readonly.sml
+   in
+      signature gs_27 = READONLY_GRAPH_VIEW
+      structure gs_28 = ReadOnlyGraphView
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graphimpl.sig
+   in
+      signature gs_29 = GRAPH_IMPLEMENTATION
+   end
+   local
+      open l8
+   in
+      structure gs_30 = Word8Array
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graph-scc.sig
+   in
+      signature gs_31 = GRAPH_STRONGLY_CONNECTED_COMPONENTS
+   end
+   local
+      structure Array = gs_9
+      signature GRAPH_STRONGLY_CONNECTED_COMPONENTS = gs_31
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure Word8Array = gs_30
+      ../graphs/graph-scc.sml
+   in
+      structure gs_32 = GraphSCC
+   end
+   local
+      open l29
+   in
+      structure gs_33 = BitSet
+   end
+   local
+      structure Array = gs_9
+      structure Graph = gs_4
+      ../graphs/graph-dfs.sig
+   in
+      signature gs_34 = GRAPH_DEPTH_FIRST_SEARCH
+   end
+   local
+      structure Array = gs_9
+      structure BitSet = gs_33
+      signature GRAPH_DEPTH_FIRST_SEARCH = gs_34
+      structure Graph = gs_4
+      ../graphs/graph-dfs.sml
+   in
+      structure gs_35 = GraphDFS
+   end
+   local
+      structure Array = gs_9
+      structure Graph = gs_4
+      ../graphs/graph-bfs.sig
+   in
+      signature gs_36 = GRAPH_BREATH_FIRST_SEARCH
+   end
+   local
+      structure Array = gs_9
+      structure BitSet = gs_33
+      signature GRAPH_BREATH_FIRST_SEARCH = gs_36
+      structure Graph = gs_4
+      ../graphs/graph-bfs.sml
+   in
+      structure gs_37 = GraphBFS
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graph-bcc.sig
+   in
+      signature gs_38 = GRAPH_BICONNECTED_COMPONENTS
+   end
+   local
+      structure Array = gs_9
+      signature GRAPH_BICONNECTED_COMPONENTS = gs_38
+      structure Graph = gs_4
+      ../graphs/graph-bcc.sml
+   in
+      structure gs_39 = GraphBCC
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graph-topsort.sig
+   in
+      signature gs_40 = GRAPH_TOPOLOGICAL_SORT
+   end
+   local
+      open l8
+   in
+      structure gs_41 = String
+   end
+   local
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure List = gs_2
+      structure String = gs_41
+      ../graphs/printgraph.sml
+   in
+      signature gs_42 = PRINT_GRAPH
+      structure gs_43 = PrintGraph
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/no-exit.sml
+   in
+      signature gs_44 = NO_ENTRY_VIEW
+      signature gs_45 = NO_EXIT_VIEW
+      structure gs_46 = NoEntryView
+      structure gs_47 = NoExitView
+   end
+   local
+      open l29
+   in
+      structure gs_48 = PriorityQueue
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/spanning-tree.sig
+   in
+      signature gs_49 = MIN_COST_SPANNING_TREE
+   end
+   local
+      open l4
+   in
+      structure gs_50 = HashTable
+   end
+   local
+      open l4
+   in
+      structure gs_51 = URef
+   end
+   local
+      open l8
+   in
+      structure gs_52 = Word
+   end
+   local
+      structure Graph = gs_4
+      structure HashTable = gs_50
+      structure URef = gs_51
+      structure Word = gs_52
+      ../graphs/node-partition.sml
+   in
+      signature gs_53 = NODE_PARTITION
+      structure gs_54 = NodePartition
+   end
+   local
+      structure Graph = gs_4
+      signature MIN_COST_SPANNING_TREE = gs_49
+      signature NODE_PARTITION = gs_53
+      structure NodePartition = gs_54
+      structure PriorityQueue = gs_48
+      ../graphs/kruskal.sml
+   in
+      structure gs_55 = Kruskal
+   end
+   local
+      open l29
+   in
+      structure gs_56 = HashArray
+   end
+   local
+      structure Graph = gs_4
+      structure List = gs_2
+      ../graphs/subgraph-p.sml
+   in
+      signature gs_57 = SUBGRAPH_P_VIEW
+      structure gs_58 = Subgraph_P_View
+   end
+   local
+      structure Graph = gs_4
+      structure HashArray = gs_56
+      signature SUBGRAPH_P_VIEW = gs_57
+      structure Subgraph_P_View = gs_58
+      ../graphs/trace-graph.sml
+   in
+      signature gs_59 = TRACE_SUBGRAPH_VIEW
+      structure gs_60 = TraceView
+   end
+   local
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure List = gs_2
+      ../graphs/start-stop.sml
+   in
+      signature gs_61 = START_STOP_VIEW
+      structure gs_62 = StartStopView
+   end
+   local
+      signature GRAPH_IMPLEMENTATION = gs_29
+      structure Graph = gs_4
+      ../graphs/snap-shot.sml
+   in
+      signature gs_63 = GRAPH_SNAPSHOT
+      functor gs_64 = GraphSnapShot
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      structure Graph = gs_4
+      ../graphs/max-flow.sig
+   in
+      signature gs_65 = MAX_FLOW
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      structure Array = gs_9
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure List = gs_2
+      signature MAX_FLOW = gs_65
+      ../graphs/max-flow.sml
+   in
+      functor gs_66 = MaxFlow
+   end
+   local
+      open l8
+   in
+      structure gs_67 = Array2
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      structure Array = gs_9
+      structure Array2 = gs_67
+      structure Graph = gs_4
+      ../graphs/shortest-paths.sig
+   in
+      signature gs_68 = ALL_PAIRS_SHORTEST_PATHS
+      signature gs_69 = SINGLE_SOURCE_SHORTEST_PATHS
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      signature ALL_PAIRS_SHORTEST_PATHS = gs_68
+      structure Array2 = gs_67
+      structure Graph = gs_4
+      signature SINGLE_SOURCE_SHORTEST_PATHS = gs_69
+      ../graphs/floyd-warshall.sml
+   in
+      functor gs_70 = FloydWarshall
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graph-is-cyclic.sig
+   in
+      signature gs_71 = GRAPH_IS_CYCLIC
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/update-graph-info.sml
+   in
+      signature gs_72 = UPDATE_GRAPH_INFO
+      structure gs_73 = UpdateGraphInfo
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/graph-cycles.sig
+   in
+      signature gs_74 = GRAPH_SIMPLE_CYCLES
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      signature ALL_PAIRS_SHORTEST_PATHS = gs_68
+      structure Array = gs_9
+      structure Graph = gs_4
+      structure Int = gs_1
+      signature SINGLE_SOURCE_SHORTEST_PATHS = gs_69
+      ../graphs/bellman-ford.sml
+   in
+      functor gs_75 = BellmanFord
+   end
+   local
+      signature GRAPH_TOPOLOGICAL_SORT = gs_40
+      structure Graph = gs_4
+      structure Word8Array = gs_30
+      ../graphs/graph-topsort.sml
+   in
+      structure gs_76 = GraphTopsort
+   end
+   local
+      structure Array = gs_9
+      structure Graph = gs_4
+      structure GraphTopsort = gs_76
+      ../graphs/trans-closure.sml
+   in
+      signature gs_77 = TRANSITIVE_CLOSURE
+      structure gs_78 = TransitiveClosure
+   end
+   local
+      open l29
+   in
+      structure gs_79 = DynArray
+   end
+   local
+      structure DynArray = gs_79
+      signature GRAPH_IMPLEMENTATION = gs_29
+      structure Graph = gs_4
+      structure List = gs_2
+      ../graphs/digraph.sml
+   in
+      functor gs_80 = DirectedGraph
+      structure gs_81 = DirectedGraph
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/wrappers.sml
+   in
+      signature gs_82 = GRAPH_WRAPPERS
+      structure gs_83 = GraphWrappers
+   end
+   local
+      structure BitSet = gs_33
+      signature GRAPH_IS_CYCLIC = gs_71
+      structure Graph = gs_4
+      ../graphs/graph-is-cyclic.sml
+   in
+      structure gs_84 = GraphIsCyclic
+   end
+   local
+      open l4
+   in
+      structure gs_85 = IntHashTable
+   end
+   local
+      structure Graph = gs_4
+      structure IntHashTable = gs_85
+      structure List = gs_2
+      ../graphs/subgraph.sml
+   in
+      signature gs_86 = SUBGRAPH_VIEW
+      structure gs_87 = SubgraphView
+   end
+   local
+      structure Graph = gs_4
+      structure Int = gs_1
+      structure ListMergeSort = gs_0
+      ../graphs/ugraph.sml
+   in
+      signature gs_88 = UNDIRECTED_GRAPH_VIEW
+      structure gs_89 = UndirectedGraphView
+   end
+   local
+      structure Graph = gs_4
+      structure HashArray = gs_56
+      structure List = gs_2
+      structure URef = gs_51
+      ../graphs/graph-minor.sml
+   in
+      signature gs_90 = GRAPH_MINOR_VIEW
+      structure gs_91 = GraphMinorView
+   end
+   local
+      signature ARRAY = gs_13
+      signature GRAPH_IMPLEMENTATION = gs_29
+      structure Graph = gs_4
+      structure List = gs_2
+      ../graphs/udgraph.sml
+   in
+      functor gs_92 = UndirectedGraph
+   end
+   local
+      signature GRAPH = gs_3
+      ../graphs/bigraph.sig
+   in
+      signature gs_93 = BIPARTITE_GRAPH
+   end
+   local
+      structure Graph = gs_4
+      structure HashArray = gs_56
+      signature SUBGRAPH_P_VIEW = gs_57
+      structure Subgraph_P_View = gs_58
+      ../graphs/acyclic-graph.sml
+   in
+      signature gs_94 = ACYCLIC_SUBGRAPH_VIEW
+      structure gs_95 = AcyclicSubgraphView
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/singleton.sml
+   in
+      signature gs_96 = SINGLETON_GRAPH_VIEW
+      structure gs_97 = SingletonGraphView
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      signature ALL_PAIRS_SHORTEST_PATHS = gs_68
+      structure Array = gs_9
+      structure Graph = gs_4
+      functor NodePriorityQueue = gs_15
+      signature SINGLE_SOURCE_SHORTEST_PATHS = gs_69
+      ../graphs/dijkstra.sml
+   in
+      functor gs_98 = Dijkstra
+   end
+   local
+      signature ABELIAN_GROUP = gs_10
+      signature ABELIAN_GROUP_WITH_INF = gs_11
+      signature ALL_PAIRS_SHORTEST_PATHS = gs_68
+      structure Array = gs_9
+      structure Array2 = gs_67
+      functor BellmanFord = gs_75
+      functor Dijkstra = gs_98
+      functor DirectedGraph = gs_80
+      structure DirectedGraph = gs_81
+      structure Graph = gs_4
+      structure HashArray = gs_56
+      signature SINGLE_SOURCE_SHORTEST_PATHS = gs_69
+      signature UNION_GRAPH_VIEW = gs_5
+      structure UnionGraphView = gs_6
+      ../graphs/johnson.sml
+   in
+      functor gs_99 = Johnson
+   end
+   local
+      structure Graph = gs_4
+      ../graphs/matching.sig
+   in
+      signature gs_100 = BIPARTITE_MATCHING
+   end
+   local
+      structure Array = gs_9
+      signature GRAPH_SIMPLE_CYCLES = gs_74
+      structure Graph = gs_4
+      structure GraphSCC = gs_32
+      ../graphs/graph-cycles.sml
+   in
+      structure gs_101 = GraphCycles
+   end
+   local
+      structure Array = gs_9
+      signature BIPARTITE_MATCHING = gs_100
+      structure Graph = gs_4
+      structure List = gs_2
+      ../graphs/matching.sml
+   in
+      structure gs_102 = BipartiteMatching
+   end
+   local
+      ../graphs/closed-semi-ring.sig
+   in
+      signature gs_103 = CLOSED_SEMI_RING
+   end
+in
+   signature ABELIAN_GROUP = gs_10
+   signature ABELIAN_GROUP_WITH_INF = gs_11
+   signature ACYCLIC_SUBGRAPH_VIEW = gs_94
+   signature ALL_PAIRS_SHORTEST_PATHS = gs_68
+   structure AcyclicSubgraphView = gs_95
+   signature BIPARTITE_GRAPH = gs_93
+   signature BIPARTITE_MATCHING = gs_100
+   functor BellmanFord = gs_75
+   structure BipartiteMatching = gs_102
+   signature CLOSED_SEMI_RING = gs_103
+   functor Dijkstra = gs_98
+   functor DirectedGraph = gs_80
+   structure DirectedGraph = gs_81
+   functor FloydWarshall = gs_70
+   signature GRAPH = gs_3
+   signature GRAPH_BICONNECTED_COMPONENTS = gs_38
+   signature GRAPH_BREATH_FIRST_SEARCH = gs_36
+   signature GRAPH_COMBINATIONS = gs_21
+   signature GRAPH_DEPTH_FIRST_SEARCH = gs_34
+   signature GRAPH_IMPLEMENTATION = gs_29
+   signature GRAPH_IS_CYCLIC = gs_71
+   signature GRAPH_MINOR_VIEW = gs_90
+   signature GRAPH_SIMPLE_CYCLES = gs_74
+   signature GRAPH_SNAPSHOT = gs_63
+   signature GRAPH_STRONGLY_CONNECTED_COMPONENTS = gs_31
+   signature GRAPH_TOPOLOGICAL_SORT = gs_40
+   signature GRAPH_WRAPPERS = gs_82
+   structure Graph = gs_4
+   structure GraphBCC = gs_39
+   structure GraphBFS = gs_37
+   structure GraphCombinations = gs_26
+   structure GraphCycles = gs_101
+   structure GraphDFS = gs_35
+   structure GraphIsCyclic = gs_84
+   structure GraphMinorView = gs_91
+   structure GraphSCC = gs_32
+   functor GraphSnapShot = gs_64
+   structure GraphTopsort = gs_76
+   structure GraphWrappers = gs_83
+   signature ISOMORPHIC_GRAPH_VIEW = gs_17
+   structure IsomorphicGraphView = gs_18
+   functor Johnson = gs_99
+   structure Kruskal = gs_55
+   signature MAX_FLOW = gs_65
+   signature MIN_COST_SPANNING_TREE = gs_49
+   signature MIN_CUT = gs_12
+   functor MaxFlow = gs_66
+   functor MinCut = gs_16
+   signature NODE_PARTITION = gs_53
+   signature NODE_PRIORITY_QUEUE = gs_14
+   signature NO_ENTRY_VIEW = gs_44
+   signature NO_EXIT_VIEW = gs_45
+   structure NoEntryView = gs_46
+   structure NoExitView = gs_47
+   structure NodePartition = gs_54
+   functor NodePriorityQueue = gs_15
+   signature PRINT_GRAPH = gs_42
+   structure PrintGraph = gs_43
+   signature READONLY_GRAPH_VIEW = gs_27
+   signature RENAMED_GRAPH_VIEW = gs_24
+   signature REVERSED_GRAPH_VIEW = gs_22
+   structure ReadOnlyGraphView = gs_28
+   structure RenamedGraphView = gs_25
+   structure ReversedGraphView = gs_23
+   signature SINGLETON_GRAPH_VIEW = gs_96
+   signature SINGLE_ENTRY_MULTIPLE_EXIT_VIEW = gs_19
+   signature SINGLE_SOURCE_SHORTEST_PATHS = gs_69
+   signature START_STOP_VIEW = gs_61
+   signature SUBGRAPH_P_VIEW = gs_57
+   signature SUBGRAPH_VIEW = gs_86
+   structure SingleEntryMultipleExit = gs_20
+   structure SingletonGraphView = gs_97
+   structure StartStopView = gs_62
+   structure SubgraphView = gs_87
+   structure Subgraph_P_View = gs_58
+   signature TRACE_SUBGRAPH_VIEW = gs_59
+   signature TRANSITIVE_CLOSURE = gs_77
+   structure TraceView = gs_60
+   structure TransitiveClosure = gs_78
+   signature UNDIRECTED_GRAPH_VIEW = gs_88
+   signature UNION_GRAPH_VIEW = gs_5
+   signature UPDATE_GRAPH_INFO = gs_72
+   functor UndirectedGraph = gs_92
+   structure UndirectedGraphView = gs_89
+   structure UnionGraphView = gs_6
+   structure UpdateGraphInfo = gs_73
+end
+end
+
+end
diff --git a/mlb/HPPA.mlb b/mlb/HPPA.mlb
new file mode 100644
index 0000000..f803709
--- /dev/null
+++ b/mlb/HPPA.mlb
@@ -0,0 +1,492 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l11 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l157 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l16 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l37 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = CellsBasis
+   end
+   local
+      open l4
+   in
+      functor gs_1 = Shuffle
+   end
+   local
+      open l11
+   in
+      structure gs_2 = Option
+   end
+   local
+      open l16
+   in
+      signature gs_3 = MLRISC_ERROR_MSG
+      structure gs_4 = MLRiscErrorMsg
+   end
+   local
+      open l4
+   in
+      signature gs_5 = REGION
+   end
+   local
+      open l4
+   in
+      signature gs_6 = CONSTANT
+   end
+   local
+      open l4
+   in
+      signature gs_7 = MLTREE
+   end
+   local
+      open l4
+   in
+      signature gs_8 = CELLS_BASIS
+   end
+   local
+      open l4
+   in
+      structure gs_9 = Label
+   end
+   local
+      open l37
+   in
+      structure gs_10 = Annotations
+   end
+   local
+      open l4
+   in
+      functor gs_11 = Cells
+   end
+   local
+      open l11
+   in
+      structure gs_12 = Int
+   end
+   local
+      open l4
+   in
+      signature gs_13 = CELLS
+   end
+   local
+      signature CELLS = gs_13
+      functor Cells = gs_11
+      structure CellsBasis = gs_0
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      ../hppa/instructions/hppaCells.sml
+   in
+      signature gs_14 = HPPACELLS
+      structure gs_15 = HppaCells
+   end
+   local
+      structure Annotations = gs_10
+      signature CELLS_BASIS = gs_8
+      signature CONSTANT = gs_6
+      structure CellsBasis = gs_0
+      signature HPPACELLS = gs_14
+      structure HppaCells = gs_15
+      structure Label = gs_9
+      signature MLTREE = gs_7
+      signature REGION = gs_5
+      ../hppa/instructions/hppaInstr.sml
+   in
+      signature gs_16 = HPPAINSTR
+      functor gs_17 = HppaInstr
+   end
+   local
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      ../hppa/instructions/hppaShuffle.sig
+   in
+      signature gs_18 = HPPASHUFFLE
+   end
+   local
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      signature HPPASHUFFLE = gs_18
+      functor HppaInstr = gs_17
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      structure Option = gs_2
+      functor Shuffle = gs_1
+      ../hppa/instructions/hppaShuffle.sml
+   in
+      functor gs_19 = HppaShuffle
+   end
+   local
+      open l4
+   in
+      signature gs_20 = INSTRUCTION_EMITTER
+   end
+   local
+      open l11
+   in
+      structure gs_21 = IntInf
+   end
+   local
+      open l11
+   in
+      structure gs_22 = Word8
+   end
+   local
+      open l11
+   in
+      structure gs_23 = Word32
+   end
+   local
+      open l4
+   in
+      signature gs_24 = CODE_STRING
+   end
+   local
+      open l4
+   in
+      signature gs_25 = INSTRUCTION_STREAM
+   end
+   local
+      open l4
+   in
+      signature gs_26 = MLTREE_EVAL
+   end
+   local
+      signature CODE_STRING = gs_24
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      signature INSTRUCTION_EMITTER = gs_20
+      signature INSTRUCTION_STREAM = gs_25
+      structure IntInf = gs_21
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      signature MLTREE_EVAL = gs_26
+      structure Option = gs_2
+      structure Word32 = gs_23
+      structure Word8 = gs_22
+      ../hppa/emit/hppaMC.sml
+   in
+      functor gs_27 = HppaMCEmitter
+   end
+   local
+      signature CELLS_BASIS = gs_8
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      ../hppa/mltree/hppaMillicode.sig
+   in
+      signature gs_28 = HPPA_MILLICODE
+   end
+   local
+      open l4
+   in
+      signature gs_29 = ASM_FORMAT_UTIL
+      structure gs_30 = AsmFormatUtil
+   end
+   local
+      open l4
+   in
+      signature gs_31 = ASM_STREAM
+      structure gs_32 = AsmStream
+   end
+   local
+      open l11
+   in
+      structure gs_33 = TextIO
+   end
+   local
+      open l11
+   in
+      structure gs_34 = String
+   end
+   local
+      open l4
+   in
+      structure gs_35 = AsmFlags
+   end
+   local
+      signature ASM_FORMAT_UTIL = gs_29
+      signature ASM_STREAM = gs_31
+      structure Annotations = gs_10
+      structure AsmFlags = gs_35
+      structure AsmFormatUtil = gs_30
+      structure AsmStream = gs_32
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      signature HPPASHUFFLE = gs_18
+      functor HppaInstr = gs_17
+      signature INSTRUCTION_EMITTER = gs_20
+      signature INSTRUCTION_STREAM = gs_25
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      signature MLTREE_EVAL = gs_26
+      structure String = gs_34
+      structure TextIO = gs_33
+      ../hppa/emit/hppaAsm.sml
+   in
+      functor gs_36 = HppaAsmEmitter
+   end
+   local
+      open l4
+   in
+      signature gs_37 = INSTRUCTIONS
+   end
+   local
+      structure CellsBasis = gs_0
+      signature INSTRUCTIONS = gs_37
+      signature MLTREE = gs_7
+      ../hppa/mltree/hppaLabelComp.sig
+   in
+      signature gs_38 = LABEL_COMP
+   end
+   local
+      open l4
+   in
+      signature gs_39 = ARCH_SPILL_INSTR
+   end
+   local
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      ../hppa/ra/hppaRewrite.sml
+   in
+      functor gs_40 = HppaRewrite
+   end
+   local
+      signature ARCH_SPILL_INSTR = gs_39
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      functor HppaRewrite = gs_40
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      ../hppa/ra/hppaSpillInstr.sml
+   in
+      functor gs_41 = HppaSpillInstr
+   end
+   local
+      open l4
+   in
+      signature gs_42 = FREQUENCY_PROPERTIES
+   end
+   local
+      open l37
+   in
+      signature gs_43 = PROBABILITY
+      structure gs_44 = Probability
+   end
+   local
+      open l4
+   in
+      structure gs_45 = MLRiscAnnotations
+   end
+   local
+      signature FREQUENCY_PROPERTIES = gs_42
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      structure MLRiscAnnotations = gs_45
+      signature PROBABILITY = gs_43
+      structure Probability = gs_44
+      ../hppa/instructions/hppaFreqProps.sml
+   in
+      functor gs_46 = HppaFreqProps
+   end
+   local
+      open l4
+   in
+      signature gs_47 = PSEUDO_OPS_BASIS
+   end
+   local
+      open l4
+   in
+      functor gs_48 = GasPseudoOps
+   end
+   local
+      open l4
+   in
+      functor gs_49 = PseudoOpsBig
+   end
+   local
+      open l157
+   in
+      structure gs_50 = Format
+   end
+   local
+      open l4
+   in
+      structure gs_51 = PseudoOpsBasisTyp
+   end
+   local
+      structure Format = gs_50
+      functor GasPseudoOps = gs_48
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      signature MLTREE = gs_7
+      signature MLTREE_EVAL = gs_26
+      signature PSEUDO_OPS_BASIS = gs_47
+      structure PseudoOpsBasisTyp = gs_51
+      functor PseudoOpsBig = gs_49
+      structure Word32 = gs_23
+      ../hppa/flowgraph/hppaGasPseudoOps.sml
+   in
+      functor gs_52 = HppaGasPseudoOps
+   end
+   local
+      open l4
+   in
+      signature gs_53 = DELAY_SLOT_PROPERTIES
+   end
+   local
+      open l4
+   in
+      signature gs_54 = INSN_PROPERTIES
+   end
+   local
+      structure CellsBasis = gs_0
+      signature DELAY_SLOT_PROPERTIES = gs_53
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      signature INSN_PROPERTIES = gs_54
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      structure Option = gs_2
+      ../hppa/backpatch/hppaDelaySlotProps.sml
+   in
+      functor gs_55 = HppaDelaySlots
+   end
+   local
+      open l11
+   in
+      structure gs_56 = Word
+   end
+   local
+      open l4
+   in
+      signature gs_57 = MLTREE_HASH
+   end
+   local
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      functor HppaInstr = gs_17
+      signature INSN_PROPERTIES = gs_54
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      signature MLTREE_EVAL = gs_26
+      signature MLTREE_HASH = gs_57
+      structure Option = gs_2
+      structure Word = gs_56
+      ../hppa/instructions/hppaProps.sml
+   in
+      functor gs_58 = HppaProps
+   end
+   local
+      open l4
+   in
+      signature gs_59 = SDI_JUMPS
+   end
+   local
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      signature HPPASHUFFLE = gs_18
+      functor HppaInstr = gs_17
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscErrorMsg = gs_4
+      signature MLTREE_EVAL = gs_26
+      signature SDI_JUMPS = gs_59
+      structure Word = gs_56
+      ../hppa/backpatch/hppaJumps.sml
+   in
+      functor gs_60 = HppaJumps
+   end
+   local
+      open l4
+   in
+      functor gs_61 = MLTreeMult
+   end
+   local
+      open l4
+   in
+      functor gs_62 = MLTreeGen
+   end
+   local
+      open l4
+   in
+      signature gs_63 = MLTREECOMP
+      signature gs_64 = MLTREE_EXTENSION_COMP
+   end
+   local
+      structure CellsBasis = gs_0
+      signature HPPAINSTR = gs_16
+      signature HPPA_MILLICODE = gs_28
+      functor HppaInstr = gs_17
+      signature LABEL_COMP = gs_38
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_3
+      structure MLRiscAnnotations = gs_45
+      structure MLRiscErrorMsg = gs_4
+      signature MLTREECOMP = gs_63
+      signature MLTREE_EXTENSION_COMP = gs_64
+      functor MLTreeGen = gs_62
+      functor MLTreeMult = gs_61
+      structure Word32 = gs_23
+      ../hppa/mltree/hppa.sml
+   in
+      functor gs_65 = Hppa
+   end
+in
+   signature HPPACELLS = gs_14
+   signature HPPAINSTR = gs_16
+   signature HPPASHUFFLE = gs_18
+   signature HPPA_MILLICODE = gs_28
+   functor Hppa = gs_65
+   functor HppaAsmEmitter = gs_36
+   structure HppaCells = gs_15
+   functor HppaDelaySlots = gs_55
+   functor HppaFreqProps = gs_46
+   functor HppaGasPseudoOps = gs_52
+   functor HppaInstr = gs_17
+   functor HppaJumps = gs_60
+   functor HppaMCEmitter = gs_27
+   functor HppaProps = gs_58
+   functor HppaRewrite = gs_40
+   functor HppaShuffle = gs_19
+   functor HppaSpillInstr = gs_41
+   signature LABEL_COMP = gs_38
+end
+end
+
+end
diff --git a/mlb/IA32-Peephole.mlb b/mlb/IA32-Peephole.mlb
new file mode 100644
index 0000000..078990a
--- /dev/null
+++ b/mlb/IA32-Peephole.mlb
@@ -0,0 +1,60 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l8 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l4 =
+    bas
+      (* $Peephole.cm(=(proxyLib.cm):.)/Peephole.cm =??=> *) Peephole.mlb
+    end
+  basis l16 =
+    bas
+      (* $IA32.cm(=(proxyLib.cm):.)/IA32.cm =??=> *) IA32.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = PEEPHOLE
+   end
+   local
+      open l8
+   in
+      structure gs_1 = CellsBasis
+   end
+   local
+      open l8
+   in
+      signature gs_2 = MLTREE_EVAL
+   end
+   local
+      open l16
+   in
+      signature gs_3 = X86INSTR
+      functor gs_4 = X86Instr
+   end
+   local
+      structure CellsBasis = gs_1
+      signature MLTREE_EVAL = gs_2
+      signature PEEPHOLE = gs_0
+      signature X86INSTR = gs_3
+      functor X86Instr = gs_4
+      ../x86/instructions/x86Peephole.sml
+   in
+      functor gs_5 = X86Peephole
+   end
+in
+   functor X86Peephole = gs_5
+end
+end
+
+end
diff --git a/mlb/IA32.mlb b/mlb/IA32.mlb
new file mode 100644
index 0000000..50731cd
--- /dev/null
+++ b/mlb/IA32.mlb
@@ -0,0 +1,800 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l35 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l112 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l12 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l236 =
+    bas
+      (* $Graphs.cm(=(proxyLib.cm):.)/Graphs.cm =??=> *) Graphs.mlb
+    end
+  basis l39 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+  basis l317 =
+    bas
+      (* $MLTREE.cm(=(proxyLib.cm):.)/MLTREE.cm =??=> *) MLTREE.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = ARCH_SPILL_INSTR
+   end
+   local
+      open l4
+   in
+      structure gs_1 = CellsBasis
+   end
+   local
+      open l12
+   in
+      signature gs_2 = MLRISC_ERROR_MSG
+      structure gs_3 = MLRiscErrorMsg
+   end
+   local
+      open l4
+   in
+      signature gs_4 = INSN_PROPERTIES
+   end
+   local
+      open l4
+   in
+      signature gs_5 = REGION
+   end
+   local
+      open l4
+   in
+      signature gs_6 = CONSTANT
+   end
+   local
+      open l4
+   in
+      signature gs_7 = MLTREE
+   end
+   local
+      open l4
+   in
+      signature gs_8 = CELLS_BASIS
+   end
+   local
+      open l4
+   in
+      structure gs_9 = Label
+   end
+   local
+      open l35
+   in
+      structure gs_10 = Int32
+   end
+   local
+      open l39
+   in
+      structure gs_11 = Annotations
+   end
+   local
+      open l4
+   in
+      functor gs_12 = Cells
+   end
+   local
+      open l35
+   in
+      structure gs_13 = Int
+   end
+   local
+      open l4
+   in
+      signature gs_14 = CELLS
+   end
+   local
+      signature CELLS = gs_14
+      functor Cells = gs_12
+      structure CellsBasis = gs_1
+      structure Int = gs_13
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      ../x86/instructions/x86Cells.sml
+   in
+      signature gs_15 = X86CELLS
+      structure gs_16 = X86Cells
+   end
+   local
+      structure Annotations = gs_11
+      signature CELLS_BASIS = gs_8
+      signature CONSTANT = gs_6
+      structure CellsBasis = gs_1
+      structure Int32 = gs_10
+      structure Label = gs_9
+      signature MLTREE = gs_7
+      signature REGION = gs_5
+      signature X86CELLS = gs_15
+      structure X86Cells = gs_16
+      ../x86/instructions/x86Instr.sml
+   in
+      signature gs_17 = X86INSTR
+      functor gs_18 = X86Instr
+   end
+   local
+      signature ARCH_SPILL_INSTR = gs_0
+      structure CellsBasis = gs_1
+      signature INSN_PROPERTIES = gs_4
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/ra/x86SpillInstr.sml
+   in
+      functor gs_19 = X86SpillInstr
+   end
+   local
+      structure CellsBasis = gs_1
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/instructions/x86MemRegs.sig
+   in
+      signature gs_20 = MEMORY_REGISTERS
+   end
+   local
+      open l4
+   in
+      signature gs_21 = MC_EMIT
+   end
+   local
+      open l35
+   in
+      structure gs_22 = Word32
+   end
+   local
+      open l35
+   in
+      structure gs_23 = Word8
+   end
+   local
+      open l35
+   in
+      structure gs_24 = LargeWord
+   end
+   local
+      open l35
+   in
+      structure gs_25 = Word8Vector
+   end
+   local
+      open l35
+   in
+      structure gs_26 = Option
+   end
+   local
+      open l35
+   in
+      structure gs_27 = Word
+   end
+   local
+      open l4
+   in
+      signature gs_28 = INSTRUCTION_EMITTER
+   end
+   local
+      open l4
+   in
+      signature gs_29 = MLTREE_EVAL
+   end
+   local
+      structure CellsBasis = gs_1
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/instructions/x86Shuffle.sig
+   in
+      signature gs_30 = X86SHUFFLE
+   end
+   local
+      structure CellsBasis = gs_1
+      signature INSTRUCTION_EMITTER = gs_28
+      structure Int32 = gs_10
+      structure LargeWord = gs_24
+      signature MC_EMIT = gs_21
+      signature MEMORY_REGISTERS = gs_20
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE_EVAL = gs_29
+      structure Option = gs_26
+      structure Word = gs_27
+      structure Word32 = gs_22
+      structure Word8 = gs_23
+      structure Word8Vector = gs_25
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      signature X86SHUFFLE = gs_30
+      ../x86/x86MC.sml
+   in
+      functor gs_31 = X86MCEmitter
+   end
+   local
+      open l4
+   in
+      signature gs_32 = PSEUDO_OPS_BASIS
+   end
+   local
+      open l4
+   in
+      functor gs_33 = DarwinPseudoOps
+   end
+   local
+      open l4
+   in
+      functor gs_34 = PseudoOpsLittle
+   end
+   local
+      open l112
+   in
+      structure gs_35 = Format
+   end
+   local
+      open l4
+   in
+      structure gs_36 = PseudoOpsBasisTyp
+   end
+   local
+      functor DarwinPseudoOps = gs_33
+      structure Format = gs_35
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE = gs_7
+      signature MLTREE_EVAL = gs_29
+      signature PSEUDO_OPS_BASIS = gs_32
+      structure PseudoOpsBasisTyp = gs_36
+      functor PseudoOpsLittle = gs_34
+      structure Word32 = gs_22
+      ../x86/flowgraph/x86-darwin-pseudo-ops.sml
+   in
+      functor gs_37 = X86DarwinPseudoOps
+   end
+   local
+      open l4
+   in
+      functor gs_38 = Shuffle
+   end
+   local
+      open l35
+   in
+      structure gs_39 = List
+   end
+   local
+      structure CellsBasis = gs_1
+      structure List = gs_39
+      functor Shuffle = gs_38
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      signature X86SHUFFLE = gs_30
+      ../x86/instructions/x86Shuffle.sml
+   in
+      functor gs_40 = X86Shuffle
+   end
+   local
+      open l4
+   in
+      signature gs_41 = CONTROL_FLOW_GRAPH
+   end
+   local
+      open l4
+   in
+      signature gs_42 = MLTREE_STREAM
+   end
+   local
+      ../x86/instructions/x86instr-ext.sml
+   in
+      structure gs_43 = X86InstrExt
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_41
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE_STREAM = gs_42
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      structure X86InstrExt = gs_43
+      ../x86/instructions/x86comp-instr-ext.sml
+   in
+      signature gs_44 = X86COMP_INSTR_EXT
+      functor gs_45 = X86CompInstrExt
+   end
+   local
+      open l4
+   in
+      functor gs_46 = GasPseudoOps
+   end
+   local
+      structure Format = gs_35
+      functor GasPseudoOps = gs_46
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE = gs_7
+      signature MLTREE_EVAL = gs_29
+      signature PSEUDO_OPS_BASIS = gs_32
+      structure PseudoOpsBasisTyp = gs_36
+      functor PseudoOpsLittle = gs_34
+      structure Word32 = gs_22
+      ../x86/flowgraph/x86GasPseudoOps.sml
+   in
+      functor gs_47 = X86GasPseudoOps
+   end
+   local
+      open l4
+   in
+      signature gs_48 = C_CALLS
+   end
+   local
+      open l4
+   in
+      structure gs_49 = CTypes
+   end
+   local
+      open l35
+   in
+      structure gs_50 = IntInf
+   end
+   local
+      open l4
+   in
+      structure gs_51 = MLRiscAnnotations
+   end
+   local
+      open l35
+   in
+      structure gs_52 = String
+   end
+   local
+      structure CTypes = gs_49
+      signature C_CALLS = gs_48
+      structure Int = gs_13
+      structure Int32 = gs_10
+      structure IntInf = gs_50
+      structure List = gs_39
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscAnnotations = gs_51
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE = gs_7
+      structure String = gs_52
+      structure Word = gs_27
+      signature X86CELLS = gs_15
+      structure X86Cells = gs_16
+      structure X86InstrExt = gs_43
+      ../x86/c-calls/ia32-svid.sml
+   in
+      functor gs_53 = IA32SVID_CCalls
+   end
+   local
+      open l4
+   in
+      signature gs_54 = FREQUENCY_PROPERTIES
+   end
+   local
+      open l39
+   in
+      signature gs_55 = PROBABILITY
+      structure gs_56 = Probability
+   end
+   local
+      signature FREQUENCY_PROPERTIES = gs_54
+      structure MLRiscAnnotations = gs_51
+      signature PROBABILITY = gs_55
+      structure Probability = gs_56
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/instructions/x86FreqProps.sml
+   in
+      functor gs_57 = X86FreqProps
+   end
+   local
+      open l4
+   in
+      signature gs_58 = MLTREE_HASH
+   end
+   local
+      structure CellsBasis = gs_1
+      signature INSN_PROPERTIES = gs_4
+      structure Int = gs_13
+      structure Int32 = gs_10
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE_EVAL = gs_29
+      signature MLTREE_HASH = gs_58
+      structure Word = gs_27
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/instructions/x86Props.sml
+   in
+      functor gs_59 = X86Props
+   end
+   local
+      open l4
+   in
+      signature gs_60 = SDI_JUMPS
+   end
+   local
+      signature MC_EMIT = gs_21
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE_EVAL = gs_29
+      signature SDI_JUMPS = gs_60
+      structure Word8Vector = gs_25
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      signature X86SHUFFLE = gs_30
+      ../x86/backpatch/x86Jumps.sml
+   in
+      functor gs_61 = X86Jumps
+   end
+   local
+      signature CELLS_BASIS = gs_8
+      structure CellsBasis = gs_1
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/ra/x86Rewrite.sig
+   in
+      signature gs_62 = X86REWRITE
+   end
+   local
+      open l4
+   in
+      signature gs_63 = CFG_OPTIMIZATION
+   end
+   local
+      open l4
+   in
+      functor gs_64 = GetReg
+   end
+   local
+      open l4
+   in
+      functor gs_65 = RegisterAllocator
+   end
+   local
+      open l4
+   in
+      functor gs_66 = MemoryRA
+   end
+   local
+      open l4
+   in
+      functor gs_67 = RADeadCodeElim
+   end
+   local
+      open l4
+   in
+      functor gs_68 = ClusterRA
+   end
+   local
+      open l4
+   in
+      signature gs_69 = LIVENESS
+      functor gs_70 = Liveness
+   end
+   local
+      open l4
+   in
+      signature gs_71 = PRINT_FLOWGRAPH
+      functor gs_72 = PrintFlowgraph
+   end
+   local
+      open l112
+   in
+      structure gs_73 = IntHashTable
+   end
+   local
+      open l12
+   in
+      signature gs_74 = MLRISC_CONTROL
+      structure gs_75 = MLRiscControl
+   end
+   local
+      open l236
+   in
+      structure gs_76 = Graph
+   end
+   local
+      open l35
+   in
+      structure gs_77 = Array
+   end
+   local
+      open l4
+   in
+      signature gs_78 = RA_SPILL
+   end
+   local
+      open l4
+   in
+      signature gs_79 = RA_SPILL_HEURISTICS
+   end
+   local
+      open l4
+   in
+      structure gs_80 = RAGraph
+   end
+   local
+      open l112
+   in
+      structure gs_81 = IntRedBlackMap
+   end
+   local
+      open l39
+   in
+      structure gs_82 = StringOutStream
+   end
+   local
+      open l4
+   in
+      signature gs_83 = ASM_STREAM
+      structure gs_84 = AsmStream
+   end
+   local
+      open l112
+   in
+      structure gs_85 = ListMergeSort
+   end
+   local
+      open l35
+   in
+      structure gs_86 = TextIO
+   end
+   local
+      open l35
+   in
+      structure gs_87 = ListPair
+   end
+   local
+      signature ASM_STREAM = gs_83
+      structure Annotations = gs_11
+      structure Array = gs_77
+      structure AsmStream = gs_84
+      signature CFG_OPTIMIZATION = gs_63
+      signature CONTROL_FLOW_GRAPH = gs_41
+      structure CellsBasis = gs_1
+      structure Graph = gs_76
+      signature INSN_PROPERTIES = gs_4
+      signature INSTRUCTION_EMITTER = gs_28
+      structure Int = gs_13
+      structure IntHashTable = gs_73
+      structure IntRedBlackMap = gs_81
+      signature LIVENESS = gs_69
+      structure Label = gs_9
+      structure List = gs_39
+      structure ListMergeSort = gs_85
+      structure ListPair = gs_87
+      functor Liveness = gs_70
+      signature MLRISC_CONTROL = gs_74
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscAnnotations = gs_51
+      structure MLRiscControl = gs_75
+      structure MLRiscErrorMsg = gs_3
+      structure String = gs_52
+      structure StringOutStream = gs_82
+      structure TextIO = gs_86
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/mltree/x86-fp.sml
+   in
+      functor gs_88 = X86FP
+   end
+   local
+      structure Annotations = gs_11
+      structure Array = gs_77
+      signature CFG_OPTIMIZATION = gs_63
+      signature CONTROL_FLOW_GRAPH = gs_41
+      structure CellsBasis = gs_1
+      functor ClusterRA = gs_68
+      functor GetReg = gs_64
+      structure Graph = gs_76
+      signature INSN_PROPERTIES = gs_4
+      signature INSTRUCTION_EMITTER = gs_28
+      structure IntHashTable = gs_73
+      signature LIVENESS = gs_69
+      structure List = gs_39
+      functor Liveness = gs_70
+      signature MLRISC_CONTROL = gs_74
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscControl = gs_75
+      structure MLRiscErrorMsg = gs_3
+      functor MemoryRA = gs_66
+      signature PRINT_FLOWGRAPH = gs_71
+      functor PrintFlowgraph = gs_72
+      functor RADeadCodeElim = gs_67
+      structure RAGraph = gs_80
+      signature RA_SPILL = gs_78
+      signature RA_SPILL_HEURISTICS = gs_79
+      functor RegisterAllocator = gs_65
+      functor X86FP = gs_88
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      functor X86SpillInstr = gs_19
+      ../x86/ra/x86RA.sml
+   in
+      functor gs_89 = X86RA
+   end
+   local
+      open l4
+   in
+      signature gs_90 = OMIT_FRAME_POINTER
+   end
+   local
+      open l35
+   in
+      structure gs_91 = General
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_41
+      structure CellsBasis = gs_1
+      structure General = gs_91
+      structure Graph = gs_76
+      structure Int32 = gs_10
+      structure IntHashTable = gs_73
+      structure ListPair = gs_87
+      signature MEMORY_REGISTERS = gs_20
+      signature MLRISC_CONTROL = gs_74
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscAnnotations = gs_51
+      structure MLRiscControl = gs_75
+      structure MLRiscErrorMsg = gs_3
+      signature OMIT_FRAME_POINTER = gs_90
+      structure Option = gs_26
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/omit-frameptr/x86omit-frameptr.sml
+   in
+      functor gs_92 = X86OmitFramePointer
+   end
+   local
+      open l4
+   in
+      signature gs_93 = ASM_FORMAT_UTIL
+      structure gs_94 = AsmFormatUtil
+   end
+   local
+      open l35
+   in
+      structure gs_95 = Char
+   end
+   local
+      open l4
+   in
+      structure gs_96 = AsmFlags
+   end
+   local
+      open l4
+   in
+      signature gs_97 = INSTRUCTION_STREAM
+   end
+   local
+      signature ASM_FORMAT_UTIL = gs_93
+      signature ASM_STREAM = gs_83
+      structure Annotations = gs_11
+      structure AsmFlags = gs_96
+      structure AsmFormatUtil = gs_94
+      structure AsmStream = gs_84
+      structure CellsBasis = gs_1
+      structure Char = gs_95
+      signature INSTRUCTION_EMITTER = gs_28
+      signature INSTRUCTION_STREAM = gs_97
+      structure Int = gs_13
+      structure Int32 = gs_10
+      signature MEMORY_REGISTERS = gs_20
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREE_EVAL = gs_29
+      structure Option = gs_26
+      structure String = gs_52
+      structure TextIO = gs_86
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      signature X86SHUFFLE = gs_30
+      ../x86/emit/x86Asm.sml
+   in
+      functor gs_98 = X86AsmEmitter
+   end
+   local
+      structure CellsBasis = gs_1
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscErrorMsg = gs_3
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      signature X86REWRITE = gs_62
+      ../x86/ra/x86Rewrite.sml
+   in
+      functor gs_99 = X86Rewrite
+   end
+   local
+      open l4
+   in
+      functor gs_100 = MLTreeGen
+   end
+   local
+      open l4
+   in
+      signature gs_101 = MLTREECOMP
+      signature gs_102 = MLTREE_EXTENSION_COMP
+   end
+   local
+      open l317
+   in
+      signature gs_103 = MLTREE_UTILS
+   end
+   local
+      structure Annotations = gs_11
+      structure CellsBasis = gs_1
+      structure Int = gs_13
+      structure Int32 = gs_10
+      structure Label = gs_9
+      structure List = gs_39
+      signature MLRISC_ERROR_MSG = gs_2
+      structure MLRiscAnnotations = gs_51
+      structure MLRiscErrorMsg = gs_3
+      signature MLTREECOMP = gs_101
+      signature MLTREE_EXTENSION_COMP = gs_102
+      signature MLTREE_STREAM = gs_42
+      signature MLTREE_UTILS = gs_103
+      functor MLTreeGen = gs_100
+      signature PROBABILITY = gs_55
+      structure Probability = gs_56
+      functor Shuffle = gs_38
+      structure Word = gs_27
+      structure Word32 = gs_22
+      signature X86INSTR = gs_17
+      functor X86Instr = gs_18
+      ../x86/mltree/x86.sml
+   in
+      functor gs_104 = X86
+   end
+in
+   functor IA32SVID_CCalls = gs_53
+   signature MEMORY_REGISTERS = gs_20
+   functor X86 = gs_104
+   functor X86AsmEmitter = gs_98
+   signature X86CELLS = gs_15
+   signature X86COMP_INSTR_EXT = gs_44
+   structure X86Cells = gs_16
+   functor X86CompInstrExt = gs_45
+   functor X86DarwinPseudoOps = gs_37
+   functor X86FP = gs_88
+   functor X86FreqProps = gs_57
+   functor X86GasPseudoOps = gs_47
+   signature X86INSTR = gs_17
+   functor X86Instr = gs_18
+   structure X86InstrExt = gs_43
+   functor X86Jumps = gs_61
+   functor X86MCEmitter = gs_31
+   functor X86OmitFramePointer = gs_92
+   functor X86Props = gs_59
+   functor X86RA = gs_89
+   signature X86REWRITE = gs_62
+   functor X86Rewrite = gs_99
+   signature X86SHUFFLE = gs_30
+   functor X86Shuffle = gs_40
+   functor X86SpillInstr = gs_19
+end
+end
+
+end
diff --git a/mlb/Lib.mlb b/mlb/Lib.mlb
new file mode 100644
index 0000000..1f20ce2
--- /dev/null
+++ b/mlb/Lib.mlb
@@ -0,0 +1,263 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l4 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      structure gs_0 = ArraySlice
+   end
+   local
+      open l4
+   in
+      structure gs_1 = Array
+   end
+   local
+      open l4
+   in
+      structure gs_2 = Vector
+   end
+   local
+      open l4
+   in
+      structure gs_3 = General
+   end
+   local
+      open l4
+   in
+      structure gs_4 = List
+   end
+   local
+      open l4
+   in
+      structure gs_5 = Int
+   end
+   local
+      structure Array = gs_1
+      structure ArraySlice = gs_0
+      structure General = gs_3
+      structure Int = gs_5
+      structure List = gs_4
+      structure Vector = gs_2
+      ../library/dynamic-array.sml
+   in
+      structure gs_6 = DynArray
+   end
+   local
+      open l4
+   in
+      structure gs_7 = String
+   end
+   local
+      open l4
+   in
+      structure gs_8 = Word
+   end
+   local
+      open l4
+   in
+      structure gs_9 = Word8
+   end
+   local
+      open l4
+   in
+      structure gs_10 = Word8Array
+   end
+   local
+      ../library/bitset.sig
+   in
+      signature gs_11 = BITSET
+   end
+   local
+      signature BITSET = gs_11
+      structure String = gs_7
+      structure Word = gs_8
+      structure Word8 = gs_9
+      structure Word8Array = gs_10
+      ../library/bitset.sml
+   in
+      structure gs_12 = BitSet
+   end
+   local
+      open l4
+   in
+      structure gs_13 = TextIO
+   end
+   local
+      structure TextIO = gs_13
+      ../library/stringOutStream.sig
+   in
+      signature gs_14 = STRING_OUTSTREAM
+   end
+   local
+      structure String = gs_7
+      ../library/line-break.sml
+   in
+      signature gs_15 = LINE_BREAK
+      structure gs_16 = LineBreak
+   end
+   local
+      open l4
+   in
+      structure gs_17 = Real
+   end
+   local
+      open l4
+   in
+      structure gs_18 = IntInf
+   end
+   local
+      structure Int = gs_5
+      structure IntInf = gs_18
+      structure List = gs_4
+      structure Real = gs_17
+      ../library/probability.sml
+   in
+      signature gs_19 = PROBABILITY
+      structure gs_20 = Probability
+   end
+   local
+      open l4
+   in
+      structure gs_21 = TextPrimIO
+   end
+   local
+      open l4
+   in
+      structure gs_22 = CharArraySlice
+   end
+   local
+      open l4
+   in
+      structure gs_23 = CharVectorSlice
+   end
+   local
+      open l4
+   in
+      structure gs_24 = IO
+   end
+   local
+      structure CharArraySlice = gs_22
+      structure CharVectorSlice = gs_23
+      structure IO = gs_24
+      structure List = gs_4
+      signature STRING_OUTSTREAM = gs_14
+      structure String = gs_7
+      structure TextIO = gs_13
+      structure TextPrimIO = gs_21
+      ../library/stringOutStream.sml
+   in
+      structure gs_25 = StringOutStream
+   end
+   local
+      ../library/catlist.sml
+   in
+      signature gs_26 = CATNETABLE_LIST
+      structure gs_27 = CatnetableList
+   end
+   local
+      ../library/priQueue.sig
+   in
+      signature gs_28 = PRIORITY_QUEUE
+   end
+   local
+      structure Array = gs_1
+      signature PRIORITY_QUEUE = gs_28
+      ../library/heap.sml
+   in
+      structure gs_29 = PriorityHeap
+   end
+   local
+      ../library/annotations.sig
+   in
+      signature gs_30 = ANNOTATIONS
+   end
+   local
+      signature ANNOTATIONS = gs_30
+      ../library/annotations.sml
+   in
+      structure gs_31 = Annotations
+   end
+   local
+      structure Array = gs_1
+      structure List = gs_4
+      structure Vector = gs_2
+      structure Word = gs_8
+      ../library/hash-array.sml
+   in
+      structure gs_32 = HashArray
+   end
+   local
+      ../library/cache.sml
+   in
+      signature gs_33 = CACHE_REF
+      structure gs_34 = CacheRef
+   end
+   local
+      ../library/sortedlist.sml
+   in
+      structure gs_35 = SortedList
+   end
+   local
+      structure Int = gs_5
+      signature PRIORITY_QUEUE = gs_28
+      ../library/priQueue.sml
+   in
+      structure gs_36 = PriorityQueue
+   end
+   local
+      open l4
+   in
+      signature gs_37 = INTEGER
+   end
+   local
+      signature INTEGER = gs_37
+      ../library/freq.sig
+   in
+      signature gs_38 = FREQ
+   end
+   local
+      signature FREQ = gs_38
+      structure Int = gs_5
+      ../library/freq.sml
+   in
+      structure gs_39 = Freq
+   end
+in
+   signature ANNOTATIONS = gs_30
+   structure Annotations = gs_31
+   signature BITSET = gs_11
+   structure BitSet = gs_12
+   signature CACHE_REF = gs_33
+   signature CATNETABLE_LIST = gs_26
+   structure CacheRef = gs_34
+   structure CatnetableList = gs_27
+   structure DynArray = gs_6
+   signature FREQ = gs_38
+   structure Freq = gs_39
+   structure HashArray = gs_32
+   signature LINE_BREAK = gs_15
+   structure LineBreak = gs_16
+   signature PRIORITY_QUEUE = gs_28
+   signature PROBABILITY = gs_19
+   structure PriorityHeap = gs_29
+   structure PriorityQueue = gs_36
+   structure Probability = gs_20
+   signature STRING_OUTSTREAM = gs_14
+   structure SortedList = gs_35
+   structure StringOutStream = gs_25
+end
+end
+
+end
diff --git a/mlb/MLRISC.mlb b/mlb/MLRISC.mlb
new file mode 100644
index 0000000..1018698
--- /dev/null
+++ b/mlb/MLRISC.mlb
@@ -0,0 +1,1746 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l13 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l19 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l44 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l5 =
+    bas
+      (* $Graphs.cm(=(proxyLib.cm):.)/Graphs.cm =??=> *) Graphs.mlb
+    end
+  basis l9 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l5
+   in
+      structure gs_0 = Graph
+   end
+   local
+      open l9
+   in
+      structure gs_1 = Annotations
+   end
+   local
+      open l13
+   in
+      structure gs_2 = TextIO
+   end
+   local
+      open l19
+   in
+      signature gs_3 = MONO_HASH_TABLE
+   end
+   local
+      open l13
+   in
+      structure gs_4 = Array
+   end
+   local
+      structure Annotations = gs_1
+      structure Array = gs_4
+      signature MONO_HASH_TABLE = gs_3
+      ../instructions/cells-basis.sig
+   in
+      signature gs_5 = CELLS_BASIS
+   end
+   local
+      open l19
+   in
+      functor gs_6 = HashTableFn
+   end
+   local
+      open l13
+   in
+      structure gs_7 = String
+   end
+   local
+      open l13
+   in
+      structure gs_8 = Word
+   end
+   local
+      open l13
+   in
+      structure gs_9 = List
+   end
+   local
+      open l44
+   in
+      signature gs_10 = MLRISC_ERROR_MSG
+      structure gs_11 = MLRiscErrorMsg
+   end
+   local
+      open l13
+   in
+      structure gs_12 = Int
+   end
+   local
+      structure Annotations = gs_1
+      structure Array = gs_4
+      signature CELLS_BASIS = gs_5
+      functor HashTableFn = gs_6
+      structure Int = gs_12
+      structure List = gs_9
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      structure String = gs_7
+      structure Word = gs_8
+      ../instructions/cells-basis.sml
+   in
+      structure gs_13 = CellsBasis
+   end
+   local
+      structure CellsBasis = gs_13
+      ../instructions/cells.sig
+   in
+      signature gs_14 = CELLS
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS = gs_14
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      ../instructions/instructions.sig
+   in
+      signature gs_15 = INSTRUCTIONS
+   end
+   local
+      open l13
+   in
+      structure gs_16 = Word8
+   end
+   local
+      open l13
+   in
+      structure gs_17 = Int32
+   end
+   local
+      open l13
+   in
+      structure gs_18 = IntInf
+   end
+   local
+      open l13
+   in
+      structure gs_19 = Int64
+   end
+   local
+      open l13
+   in
+      structure gs_20 = Word32
+   end
+   local
+      structure Int32 = gs_17
+      structure Int64 = gs_19
+      structure IntInf = gs_18
+      structure Word32 = gs_20
+      ../mltree/machine-int.sig
+   in
+      signature gs_21 = MACHINE_INT
+   end
+   local
+      ../mltree/mltree-extension.sig
+   in
+      signature gs_22 = MLTREE_EXTENSION
+   end
+   local
+      ../mltree/mltree-basis.sig
+   in
+      signature gs_23 = MLTREE_BASIS
+   end
+   local
+      ../instructions/region.sig
+   in
+      signature gs_24 = REGION
+   end
+   local
+      ../instructions/constant.sig
+   in
+      signature gs_25 = CONSTANT
+   end
+   local
+      ../instructions/label-sig.sml
+   in
+      signature gs_26 = LABEL
+   end
+   local
+      signature LABEL = gs_26
+      structure Word = gs_8
+      ../instructions/label.sml
+   in
+      structure gs_27 = Label
+   end
+   local
+      structure Annotations = gs_1
+      signature CONSTANT = gs_25
+      structure CellsBasis = gs_13
+      structure Int32 = gs_17
+      structure Label = gs_27
+      signature MACHINE_INT = gs_21
+      signature MLTREE_BASIS = gs_23
+      signature MLTREE_EXTENSION = gs_22
+      signature REGION = gs_24
+      ../mltree/mltree.sig
+   in
+      signature gs_28 = MLTREE
+   end
+   local
+      open l19
+   in
+      structure gs_29 = Atom
+   end
+   local
+      structure Atom = gs_29
+      structure Label = gs_27
+      ../flowgraph/pseudo-ops-basis-typ.sml
+   in
+      structure gs_30 = PseudoOpsBasisTyp
+   end
+   local
+      structure Label = gs_27
+      signature MLTREE = gs_28
+      structure PseudoOpsBasisTyp = gs_30
+      structure Word8 = gs_16
+      ../flowgraph/pseudo-ops-basis.sig
+   in
+      signature gs_31 = PSEUDO_OPS_BASIS
+   end
+   local
+      signature PSEUDO_OPS_BASIS = gs_31
+      structure Word8 = gs_16
+      ../flowgraph/client-pseudo-ops.sig
+   in
+      signature gs_32 = CLIENT_PSEUDO_OPS
+   end
+   local
+      signature CLIENT_PSEUDO_OPS = gs_32
+      signature MLTREE = gs_28
+      structure PseudoOpsBasisTyp = gs_30
+      structure Word8 = gs_16
+      ../flowgraph/pseudo-ops.sig
+   in
+      signature gs_33 = PSEUDO_OPS
+   end
+   local
+      structure Annotations = gs_1
+      structure Graph = gs_0
+      signature INSTRUCTIONS = gs_15
+      structure Label = gs_27
+      signature PSEUDO_OPS = gs_33
+      structure TextIO = gs_2
+      ../flowgraph/cfg.sig
+   in
+      signature gs_34 = CONTROL_FLOW_GRAPH
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      ../emit/asmEmit.sig
+   in
+      signature gs_35 = ASSEMBLY_EMITTER
+   end
+   local
+      structure List = gs_9
+      signature MLTREE = gs_28
+      ../mltree/mltree-check-ty.sml
+   in
+      functor gs_36 = MLTreeCheckTy
+   end
+   local
+      open l5
+   in
+      signature gs_37 = GRAPH_IMPLEMENTATION
+   end
+   local
+      structure Array = gs_4
+      signature GRAPH_IMPLEMENTATION = gs_37
+      structure Graph = gs_0
+      ../ir-archive/dominator.sig
+   in
+      signature gs_38 = DOMINATOR_TREE
+   end
+   local
+      structure Array = gs_4
+      signature DOMINATOR_TREE = gs_38
+      signature GRAPH_IMPLEMENTATION = gs_37
+      structure Graph = gs_0
+      ../ir-archive/loop-structure.sig
+   in
+      signature gs_39 = LOOP_STRUCTURE
+   end
+   local
+      open l9
+   in
+      structure gs_40 = BitSet
+   end
+   local
+      open l5
+   in
+      signature gs_41 = REVERSED_GRAPH_VIEW
+      structure gs_42 = ReversedGraphView
+   end
+   local
+      structure Array = gs_4
+      structure BitSet = gs_40
+      signature DOMINATOR_TREE = gs_38
+      signature GRAPH_IMPLEMENTATION = gs_37
+      structure Graph = gs_0
+      structure List = gs_9
+      signature REVERSED_GRAPH_VIEW = gs_41
+      structure ReversedGraphView = gs_42
+      ../ir-archive/dominator.sml
+   in
+      functor gs_43 = DominatorTree
+   end
+   local
+      structure Annotations = gs_1
+      structure Label = gs_27
+      signature PSEUDO_OPS = gs_33
+      ../instructions/stream.sig
+   in
+      signature gs_44 = INSTRUCTION_STREAM
+   end
+   local
+      structure Annotations = gs_1
+      signature INSTRUCTION_STREAM = gs_44
+      structure Label = gs_27
+      signature PSEUDO_OPS = gs_33
+      ../instructions/stream.sml
+   in
+      functor gs_45 = InstructionStream
+   end
+   local
+      signature MLTREE = gs_28
+      ../mltree/mltree-size.sig
+   in
+      signature gs_46 = MLTREE_SIZE
+   end
+   local
+      structure Annotations = gs_1
+      structure CellsBasis = gs_13
+      signature MLTREE = gs_28
+      signature MLTREE_SIZE = gs_46
+      ../mltree/mltree-gen.sig
+   in
+      signature gs_47 = MLTREEGEN
+   end
+   local
+      signature INSTRUCTION_STREAM = gs_44
+      signature MLTREE = gs_28
+      ../mltree/mltree-stream.sig
+   in
+      signature gs_48 = MLTREE_STREAM
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      signature MLTREE = gs_28
+      signature MLTREEGEN = gs_47
+      signature MLTREE_STREAM = gs_48
+      ../mltree/mltreecomp.sig
+   in
+      signature gs_49 = MLTREECOMP
+      signature gs_50 = MLTREE_EXTENSION_COMP
+   end
+   local
+      open l19
+   in
+      structure gs_51 = Format
+   end
+   local
+      structure TextIO = gs_2
+      ../emit/asmStream.sml
+   in
+      signature gs_52 = ASM_STREAM
+      structure gs_53 = AsmStream
+   end
+   local
+      structure Annotations = gs_1
+      signature INSTRUCTIONS = gs_15
+      signature INSTRUCTION_STREAM = gs_44
+      ../emit/instruction-emitter.sig
+   in
+      signature gs_54 = INSTRUCTION_EMITTER
+   end
+   local
+      signature ASM_STREAM = gs_52
+      structure AsmStream = gs_53
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Format = gs_51
+      structure Graph = gs_0
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Int = gs_12
+      structure List = gs_9
+      structure TextIO = gs_2
+      ../flowgraph/printFlowgraph.sml
+   in
+      signature gs_55 = PRINT_FLOWGRAPH
+      functor gs_56 = PrintFlowgraph
+   end
+   local
+      structure Array = gs_4
+      ../ra/getreg.sig
+   in
+      signature gs_57 = GETREG
+   end
+   local
+      structure Array = gs_4
+      signature GETREG = gs_57
+      ../ra/getreg.sml
+   in
+      functor gs_58 = GetReg
+   end
+   local
+      signature INSTRUCTIONS = gs_15
+      structure Label = gs_27
+      ../backpatch/delaySlotProps.sig
+   in
+      signature gs_59 = DELAY_SLOT_PROPERTIES
+   end
+   local
+      structure List = gs_9
+      ../c-calls/c-types.sml
+   in
+      structure gs_60 = CTypes
+   end
+   local
+      structure CTypes = gs_60
+      signature MLTREE = gs_28
+      ../c-calls/c-calls.sig
+   in
+      signature gs_61 = C_CALLS
+   end
+   local
+      signature C_CALLS = gs_61
+      signature MLTREE = gs_28
+      ../c-calls/unimplemented-c-calls.sml
+   in
+      functor gs_62 = UnimplementedCCallsFn
+   end
+   local
+      open l44
+   in
+      signature gs_63 = MLRISC_CONTROL
+      structure gs_64 = MLRiscControl
+   end
+   local
+      open l19
+   in
+      structure gs_65 = ListMergeSort
+   end
+   local
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      ../aliasing/pointsTo.sig
+   in
+      signature gs_66 = POINTS_TO
+   end
+   local
+      structure CellsBasis = gs_13
+      structure Int = gs_12
+      structure ListMergeSort = gs_65
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      signature POINTS_TO = gs_66
+      ../aliasing/pointsTo.sml
+   in
+      structure gs_67 = PointsTo
+   end
+   local
+      open l13
+   in
+      structure gs_68 = Char
+   end
+   local
+      signature MLTREE = gs_28
+      structure PseudoOpsBasisTyp = gs_30
+      structure Word8 = gs_16
+      ../flowgraph/pseudo-ops-endian.sig
+   in
+      signature gs_69 = PSEUDO_OPS_ENDIAN
+   end
+   local
+      structure IntInf = gs_18
+      structure Label = gs_27
+      signature MLTREE = gs_28
+      ../mltree/mltree-eval.sig
+   in
+      signature gs_70 = MLTREE_EVAL
+   end
+   local
+      structure Char = gs_68
+      structure Int = gs_12
+      structure IntInf = gs_18
+      structure Label = gs_27
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      signature MLTREE_EVAL = gs_70
+      signature PSEUDO_OPS_ENDIAN = gs_69
+      structure PseudoOpsBasisTyp = gs_30
+      structure String = gs_7
+      structure Word = gs_8
+      structure Word32 = gs_20
+      structure Word8 = gs_16
+      ../flowgraph/pseudo-ops-big.sml
+   in
+      functor gs_71 = PseudoOpsBig
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      ../backpatch/bbsched.sig
+   in
+      signature gs_72 = BBSCHED
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure Label = gs_27
+      ../instructions/insnProps.sig
+   in
+      signature gs_73 = INSN_PROPERTIES
+   end
+   local
+      signature CELLS = gs_14
+      signature INSTRUCTIONS = gs_15
+      structure Label = gs_27
+      ../backpatch/sdi-jumps.sig
+   in
+      signature gs_74 = SDI_JUMPS
+   end
+   local
+      structure Array = gs_4
+      signature BBSCHED = gs_72
+      signature CONTROL_FLOW_GRAPH = gs_34
+      signature DELAY_SLOT_PROPERTIES = gs_59
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Label = gs_27
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      signature SDI_JUMPS = gs_74
+      ../backpatch/spanDep.sml
+   in
+      functor gs_75 = SpanDependencyResolution
+   end
+   local
+      structure Label = gs_27
+      signature MLTREE = gs_28
+      structure PseudoOpsBasisTyp = gs_30
+      ../flowgraph/as-pseudo-ops.sig
+   in
+      signature gs_76 = AS_PSEUDO_OPS
+   end
+   local
+      signature AS_PSEUDO_OPS = gs_76
+      structure Atom = gs_29
+      structure Format = gs_51
+      structure Int = gs_12
+      structure IntInf = gs_18
+      structure Label = gs_27
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      structure PseudoOpsBasisTyp = gs_30
+      structure String = gs_7
+      ../flowgraph/darwin-pseudo-ops.sml
+   in
+      functor gs_77 = DarwinPseudoOps
+   end
+   local
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      ../ra/ra-flowgraph-part.sig
+   in
+      signature gs_78 = RA_FLOWGRAPH_PARTITIONER
+   end
+   local
+      structure Word8 = gs_16
+      ../emit/code-string.sig
+   in
+      signature gs_79 = CODE_STRING
+   end
+   local
+      open l9
+   in
+      signature gs_80 = PROBABILITY
+      structure gs_81 = Probability
+   end
+   local
+      open l13
+   in
+      structure gs_82 = Real
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      ../frequencies/compute-execution-freqs.sig
+   in
+      signature gs_83 = COMPUTE_EXECUTION_FREQUENCIES
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      ../instructions/mlriscAnnotations.sig
+   in
+      signature gs_84 = MLRISC_ANNOTATIONS
+   end
+   local
+      structure Annotations = gs_1
+      structure CellsBasis = gs_13
+      structure Int = gs_12
+      signature MLRISC_ANNOTATIONS = gs_84
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      ../instructions/mlriscAnnotations.sml
+   in
+      structure gs_85 = MLRiscAnnotations
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscAnnotations = gs_85
+      structure MLRiscControl = gs_64
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      ../frequencies/complete-probs-fn.sml
+   in
+      functor gs_86 = CompleteProbsFn
+   end
+   local
+      structure Array = gs_4
+      signature COMPUTE_EXECUTION_FREQUENCIES = gs_83
+      signature CONTROL_FLOW_GRAPH = gs_34
+      functor CompleteProbsFn = gs_86
+      structure Format = gs_51
+      structure Graph = gs_0
+      structure Int = gs_12
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscControl = gs_64
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      structure Real = gs_82
+      structure TextIO = gs_2
+      ../frequencies/compute-freqs-fn.sml
+   in
+      functor gs_87 = ComputeFreqsFn
+   end
+   local
+      signature MLTREE = gs_28
+      ../mltree/mltree-hash.sig
+   in
+      signature gs_88 = MLTREE_HASH
+   end
+   local
+      ../aliasing/mlriscRegion.sig
+   in
+      signature gs_89 = MLRISC_REGION
+   end
+   local
+      ../instructions/mlriscOptimization.sig
+   in
+      signature gs_90 = MLRISC_OPTIMIZATION
+   end
+   local
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      ../instructions/shuffle.sig
+   in
+      signature gs_91 = SHUFFLE
+   end
+   local
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      ../ra/arch-spill-instr.sig
+   in
+      signature gs_92 = ARCH_SPILL_INSTR
+   end
+   local
+      signature AS_PSEUDO_OPS = gs_76
+      structure Atom = gs_29
+      structure Format = gs_51
+      structure Int = gs_12
+      structure IntInf = gs_18
+      structure Label = gs_27
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      structure PseudoOpsBasisTyp = gs_30
+      structure String = gs_7
+      ../flowgraph/gasPseudoOps.sml
+   in
+      functor gs_93 = GasPseudoOps
+   end
+   local
+      structure Array = gs_4
+      ../ra/ra-bitmatrix.sig
+   in
+      signature gs_94 = RA_BITMATRIX
+   end
+   local
+      ../ra/ra-priqueue.sig
+   in
+      signature gs_95 = RA_PRIORITY_QUEUE
+   end
+   local
+      open l13
+   in
+      structure gs_96 = Unsafe
+   end
+   local
+      structure Array = gs_4
+      signature RA_BITMATRIX = gs_94
+      structure Unsafe = gs_96
+      structure Word = gs_8
+      ../ra/raBitmatrix.sml
+   in
+      structure gs_97 = RaBitmatrix
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      structure Label = gs_27
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure TextIO = gs_2
+      ../block-placement/jump-chain-elim-fn.sml
+   in
+      functor gs_98 = JumpChainElimFn
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      ../flowgraph/cfg-optimization.sig
+   in
+      signature gs_99 = CFG_OPTIMIZATION
+   end
+   local
+      signature CFG_OPTIMIZATION = gs_99
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      structure Graph = gs_0
+      structure List = gs_9
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature SHUFFLE = gs_91
+      ../flowgraph/cfgExpandCopies.sml
+   in
+      functor gs_100 = CFGExpandCopies
+   end
+   local
+      signature INSTRUCTION_STREAM = gs_44
+      signature MLTREE = gs_28
+      signature MLTREE_STREAM = gs_48
+      ../mltree/mltree-stream.sml
+   in
+      functor gs_101 = MLTreeStream
+   end
+   local
+      structure Char = gs_68
+      structure Int = gs_12
+      structure IntInf = gs_18
+      structure Label = gs_27
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      signature MLTREE_EVAL = gs_70
+      signature PSEUDO_OPS_ENDIAN = gs_69
+      structure PseudoOpsBasisTyp = gs_30
+      structure String = gs_7
+      structure Word = gs_8
+      structure Word32 = gs_20
+      structure Word8 = gs_16
+      ../flowgraph/pseudo-ops-little.sml
+   in
+      functor gs_102 = PseudoOpsLittle
+   end
+   local
+      signature MLTREE = gs_28
+      signature MLTREE_SIZE = gs_46
+      ../mltree/mltree-size.sml
+   in
+      functor gs_103 = MLTreeSize
+   end
+   local
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      structure Int = gs_12
+      structure Label = gs_27
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      signature MLTREEGEN = gs_47
+      functor MLTreeSize = gs_103
+      ../mltree/mltree-gen.sml
+   in
+      functor gs_104 = MLTreeGen
+   end
+   local
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE_BASIS = gs_23
+      ../mltree/mltree-basis.sml
+   in
+      structure gs_105 = MLTreeBasis
+   end
+   local
+      signature CLIENT_PSEUDO_OPS = gs_32
+      signature PSEUDO_OPS = gs_33
+      structure PseudoOpsBasisTyp = gs_30
+      ../flowgraph/pseudo-ops.sml
+   in
+      functor gs_106 = PseudoOps
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      ../block-placement/block-placement.sig
+   in
+      signature gs_107 = BLOCK_PLACEMENT
+   end
+   local
+      open l19
+   in
+      structure gs_108 = IntHashTable
+   end
+   local
+      structure Array = gs_4
+      signature CELLS_BASIS = gs_5
+      structure IntHashTable = gs_108
+      signature MONO_HASH_TABLE = gs_3
+      signature RA_BITMATRIX = gs_94
+      structure RaBitmatrix = gs_97
+      ../ra/ra-graph.sig
+   in
+      signature gs_109 = RA_GRAPH
+   end
+   local
+      structure Array = gs_4
+      structure CellsBasis = gs_13
+      functor HashTableFn = gs_6
+      structure IntHashTable = gs_108
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature RA_GRAPH = gs_109
+      structure RaBitmatrix = gs_97
+      structure Word = gs_8
+      ../ra/ra-graph.sml
+   in
+      structure gs_110 = RAGraph
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS = gs_14
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure RAGraph = gs_110
+      signature RA_GRAPH = gs_109
+      ../ra/ra-spill.sig
+   in
+      signature gs_111 = RA_SPILL
+   end
+   local
+      signature INSTRUCTIONS = gs_15
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      ../instructions/freqProps.sig
+   in
+      signature gs_112 = FREQUENCY_PROPERTIES
+   end
+   local
+      signature FREQUENCY_PROPERTIES = gs_112
+      signature INSN_PROPERTIES = gs_73
+      structure MLRiscAnnotations = gs_85
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      ../instructions/freqProps.sml
+   in
+      functor gs_113 = FreqProps
+   end
+   local
+      structure Annotations = gs_1
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Format = gs_51
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTIONS = gs_15
+      signature INSTRUCTION_STREAM = gs_44
+      structure IntHashTable = gs_108
+      structure Label = gs_27
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscAnnotations = gs_85
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      signature PSEUDO_OPS = gs_33
+      structure PseudoOpsBasisTyp = gs_30
+      structure Word = gs_8
+      ../flowgraph/buildFlowgraph.sml
+   in
+      functor gs_114 = BuildFlowgraph
+      signature gs_115 = CONTROL_FLOWGRAPH_GEN
+   end
+   local
+      structure RAGraph = gs_110
+      signature RA_GRAPH = gs_109
+      ../ra/ra-spillheur.sig
+   in
+      signature gs_116 = RA_SPILL_HEURISTICS
+   end
+   local
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscControl = gs_64
+      ../emit/asm-flags.sml
+   in
+      structure gs_117 = AsmFlags
+   end
+   local
+      structure Annotations = gs_1
+      structure IntInf = gs_18
+      ../gc-safety/gc-type.sig
+   in
+      signature gs_118 = GC_TYPE
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS = gs_14
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      signature GC_TYPE = gs_118
+      ../gc-safety/gc-cells.sig
+   in
+      signature gs_119 = GC_CELLS
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure RAGraph = gs_110
+      signature RA_GRAPH = gs_109
+      signature RA_SPILL = gs_111
+      structure TextIO = gs_2
+      ../ra/ra-flowgraph.sig
+   in
+      signature gs_120 = RA_FLOWGRAPH
+   end
+   local
+      structure Array = gs_4
+      signature CELLS = gs_14
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure RAGraph = gs_110
+      signature RA_FLOWGRAPH = gs_120
+      ../ra/ra.sig
+   in
+      signature gs_121 = RA
+   end
+   local
+      open l13
+   in
+      structure gs_122 = Word8Array
+   end
+   local
+      structure RAGraph = gs_110
+      signature RA_BITMATRIX = gs_94
+      signature RA_GRAPH = gs_109
+      signature RA_PRIORITY_QUEUE = gs_95
+      structure TextIO = gs_2
+      ../ra/ra-core.sig
+   in
+      signature gs_123 = RA_CORE
+   end
+   local
+      signature RA_PRIORITY_QUEUE = gs_95
+      ../ra/raPriQueue.sml
+   in
+      functor gs_124 = RaPriQueue
+   end
+   local
+      structure Array = gs_4
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      structure List = gs_9
+      structure ListMergeSort = gs_65
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure RAGraph = gs_110
+      signature RA_CORE = gs_123
+      functor RaPriQueue = gs_124
+      structure Real = gs_82
+      structure TextIO = gs_2
+      structure Unsafe = gs_96
+      structure Word = gs_8
+      structure Word8 = gs_16
+      structure Word8Array = gs_122
+      ../ra/ra-core.sml
+   in
+      structure gs_125 = RACore
+   end
+   local
+      structure Array = gs_4
+      structure CellsBasis = gs_13
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      signature RA = gs_121
+      structure RACore = gs_125
+      signature RA_FLOWGRAPH = gs_120
+      signature RA_SPILL_HEURISTICS = gs_116
+      structure Real = gs_82
+      structure TextIO = gs_2
+      structure Word = gs_8
+      ../ra/ra.sml
+   in
+      functor gs_126 = RegisterAllocator
+   end
+   local
+      structure CellsBasis = gs_13
+      structure IntHashTable = gs_108
+      structure RACore = gs_125
+      signature RA_FLOWGRAPH = gs_120
+      structure Word = gs_8
+      ../ra/ra-deadCodeE.sml
+   in
+      functor gs_127 = RADeadCodeElim
+   end
+   local
+      open l19
+   in
+      structure gs_128 = URef
+   end
+   local
+      structure Array = gs_4
+      signature DOMINATOR_TREE = gs_38
+      signature GRAPH_IMPLEMENTATION = gs_37
+      structure Graph = gs_0
+      signature LOOP_STRUCTURE = gs_39
+      structure List = gs_9
+      structure URef = gs_128
+      ../ir-archive/loop-structure.sml
+   in
+      functor gs_129 = LoopStructure
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Label = gs_27
+      structure List = gs_9
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature SDI_JUMPS = gs_74
+      ../backpatch/backpatch.sml
+   in
+      functor gs_130 = BBSched2
+   end
+   local
+      structure Array = gs_4
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      structure List = gs_9
+      structure ListMergeSort = gs_65
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure RACore = gs_125
+      structure RAGraph = gs_110
+      signature RA_FLOWGRAPH = gs_120
+      signature RA_SPILL = gs_111
+      structure TextIO = gs_2
+      structure Unsafe = gs_96
+      structure Word = gs_8
+      ../ra/cluster-ra.sml
+   in
+      functor gs_131 = ClusterRA
+   end
+   local
+      structure RACore = gs_125
+      structure RAGraph = gs_110
+      signature RA_SPILL_HEURISTICS = gs_116
+      ../ra/chaitin-spillheur.sml
+   in
+      structure gs_132 = ChaitinSpillHeur
+   end
+   local
+      open l19
+   in
+      functor gs_133 = LeftPriorityQFn
+   end
+   local
+      signature BLOCK_PLACEMENT = gs_107
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      functor LeftPriorityQFn = gs_133
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscControl = gs_64
+      structure Real = gs_82
+      structure TextIO = gs_2
+      structure URef = gs_128
+      ../block-placement/weighted-block-placement-fn.sml
+   in
+      functor gs_134 = WeightedBlockPlacementFn
+   end
+   local
+      structure Array = gs_4
+      signature BLOCK_PLACEMENT = gs_107
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      structure Int = gs_12
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure TextIO = gs_2
+      ../block-placement/default-block-placement.sml
+   in
+      functor gs_135 = DefaultBlockPlacement
+   end
+   local
+      signature BLOCK_PLACEMENT = gs_107
+      signature CONTROL_FLOW_GRAPH = gs_34
+      functor DefaultBlockPlacement = gs_135
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscControl = gs_64
+      functor WeightedBlockPlacementFn = gs_134
+      ../block-placement/block-placement.sml
+   in
+      functor gs_136 = BlockPlacement
+   end
+   local
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      signature MLTREE = gs_28
+      ../mltree/mltree-mult.sig
+   in
+      signature gs_137 = MLTREE_MULT_DIV
+   end
+   local
+      structure Array = gs_4
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      signature MLTREE_MULT_DIV = gs_137
+      structure Word = gs_8
+      ../mltree/mltree-mult.sml
+   in
+      functor gs_138 = MLTreeMult
+   end
+   local
+      structure CellsBasis = gs_13
+      structure Char = gs_68
+      structure Int = gs_12
+      structure Label = gs_27
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      signature MLTREE = gs_28
+      signature MLTREE_HASH = gs_88
+      structure String = gs_7
+      structure Word = gs_8
+      ../mltree/mltree-hash.sml
+   in
+      functor gs_139 = MLTreeHash
+   end
+   local
+      structure CellsBasis = gs_13
+      structure IntInf = gs_18
+      structure Label = gs_27
+      signature MLTREE = gs_28
+      signature MLTREE_EVAL = gs_70
+      ../mltree/mltree-eval.sml
+   in
+      functor gs_140 = MLTreeEval
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      signature GC_CELLS = gs_119
+      signature GC_TYPE = gs_118
+      ../gc-safety/gc-cells.sml
+   in
+      functor gs_141 = GCCells
+   end
+   local
+      structure Array = gs_4
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      structure Int = gs_12
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure TextIO = gs_2
+      ../block-placement/check-placement-fn.sml
+   in
+      functor gs_142 = CheckPlacementFn
+   end
+   local
+      structure Array = gs_4
+      signature CELLS = gs_14
+      structure CellsBasis = gs_13
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      ../instructions/cells.sml
+   in
+      functor gs_143 = Cells
+   end
+   local
+      signature DELAY_SLOT_PROPERTIES = gs_59
+      signature INSTRUCTIONS = gs_15
+      ../backpatch/noDelaySlots.sml
+   in
+      functor gs_144 = NoDelaySlots
+   end
+   local
+      structure Annotations = gs_1
+      signature CELLS_BASIS = gs_5
+      structure CellsBasis = gs_13
+      structure Label = gs_27
+      structure List = gs_9
+      structure MLRiscAnnotations = gs_85
+      ../emit/asmUtil.sml
+   in
+      signature gs_145 = ASM_FORMAT_UTIL
+      structure gs_146 = AsmFormatUtil
+   end
+   local
+      open l13
+   in
+      structure gs_147 = ListPair
+   end
+   local
+      open l13
+   in
+      structure gs_148 = Option
+   end
+   local
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure List = gs_9
+      structure ListPair = gs_147
+      structure Option = gs_148
+      ../instructions/shuffle.sml
+   in
+      functor gs_149 = Shuffle
+   end
+   local
+      open l5
+   in
+      functor gs_150 = DirectedGraph
+      structure gs_151 = DirectedGraph
+   end
+   local
+      structure Annotations = gs_1
+      signature CONTROL_FLOW_GRAPH = gs_34
+      functor DirectedGraph = gs_150
+      structure DirectedGraph = gs_151
+      functor DominatorTree = gs_43
+      structure Graph = gs_0
+      structure List = gs_9
+      functor LoopStructure = gs_129
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscAnnotations = gs_85
+      structure MLRiscControl = gs_64
+      signature PROBABILITY = gs_80
+      structure Probability = gs_81
+      ../frequencies/estimate-loop-probs-fn.sml
+   in
+      functor gs_152 = EstimateLoopProbsFn
+   end
+   local
+      open l13
+   in
+      structure gs_153 = StringCvt
+   end
+   local
+      structure Array = gs_4
+      structure Int32 = gs_17
+      structure Int64 = gs_19
+      structure IntInf = gs_18
+      signature MACHINE_INT = gs_21
+      structure String = gs_7
+      structure StringCvt = gs_153
+      structure Word = gs_8
+      structure Word32 = gs_20
+      ../mltree/machine-int.sml
+   in
+      structure gs_154 = MachineInt
+   end
+   local
+      structure Array = gs_4
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure RACore = gs_125
+      structure RAGraph = gs_110
+      signature RA_FLOWGRAPH = gs_120
+      structure Real = gs_82
+      structure Word = gs_8
+      ../ra/mem-ra.sml
+   in
+      functor gs_155 = MemoryRA
+   end
+   local
+      structure Annotations = gs_1
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure RAGraph = gs_110
+      ../ra/ra-spill-types.sml
+   in
+      functor gs_156 = RASpillTypes
+   end
+   local
+      open l13
+   in
+      structure gs_157 = Word8Vector
+   end
+   local
+      signature INSTRUCTIONS = gs_15
+      structure Word8Vector = gs_157
+      ../emit/mc-emit.sig
+   in
+      signature gs_158 = MC_EMIT
+   end
+   local
+      signature CODE_STRING = gs_79
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Label = gs_27
+      structure List = gs_9
+      signature MC_EMIT = gs_158
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      signature SDI_JUMPS = gs_74
+      structure Word8 = gs_16
+      structure Word8Vector = gs_157
+      ../backpatch/vlBackPatch.sml
+   in
+      functor gs_159 = BackPatch
+   end
+   local
+      open l9
+   in
+      structure gs_160 = PriorityHeap
+   end
+   local
+      structure IntHashTable = gs_108
+      structure Option = gs_148
+      structure PriorityHeap = gs_160
+      structure RACore = gs_125
+      structure RAGraph = gs_110
+      signature RA_SPILL_HEURISTICS = gs_116
+      structure Real = gs_82
+      ../ra/chow-hennessy-spillheur.sml
+   in
+      structure gs_161 = ChowHennessySpillHeur
+   end
+   local
+      open l9
+   in
+      signature gs_162 = LINE_BREAK
+      structure gs_163 = LineBreak
+   end
+   local
+      open l9
+   in
+      structure gs_164 = StringOutStream
+   end
+   local
+      open l5
+   in
+      signature gs_165 = UPDATE_GRAPH_INFO
+      structure gs_166 = UpdateGraphInfo
+   end
+   local
+      open l13
+   in
+      structure gs_167 = Bool
+   end
+   local
+      signature ASM_STREAM = gs_52
+      structure Annotations = gs_1
+      structure Array = gs_4
+      structure AsmStream = gs_53
+      structure Bool = gs_167
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      structure Char = gs_68
+      structure Format = gs_51
+      signature GRAPH_IMPLEMENTATION = gs_37
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTIONS = gs_15
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      signature LINE_BREAK = gs_162
+      structure Label = gs_27
+      structure LineBreak = gs_163
+      structure List = gs_9
+      structure ListMergeSort = gs_65
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      structure Real = gs_82
+      structure String = gs_7
+      structure StringOutStream = gs_164
+      structure TextIO = gs_2
+      signature UPDATE_GRAPH_INFO = gs_165
+      structure UpdateGraphInfo = gs_166
+      ../flowgraph/cfg.sml
+   in
+      functor gs_168 = ControlFlowGraph
+   end
+   local
+      structure Annotations = gs_1
+      signature CONSTANT = gs_25
+      structure CellsBasis = gs_13
+      structure Int32 = gs_17
+      structure Label = gs_27
+      signature MLTREE = gs_28
+      signature MLTREE_EXTENSION = gs_22
+      structure MLTreeBasis = gs_105
+      structure MachineInt = gs_154
+      signature REGION = gs_24
+      ../mltree/mltree.sml
+   in
+      functor gs_169 = MLTreeF
+   end
+   local
+      open l13
+   in
+      structure gs_170 = General
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      structure General = gs_170
+      structure Graph = gs_0
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscErrorMsg = gs_11
+      ../ra/liveness.sml
+   in
+      signature gs_171 = LIVENESS
+      functor gs_172 = Liveness
+   end
+   local
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      ../instructions/rewrite.sig
+   in
+      signature gs_173 = REWRITE_INSTRUCTIONS
+   end
+   local
+      signature ARCH_SPILL_INSTR = gs_92
+      structure Annotations = gs_1
+      structure Array = gs_4
+      signature CFG_OPTIMIZATION = gs_99
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      functor ClusterRA = gs_131
+      functor GetReg = gs_58
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTIONS = gs_15
+      signature INSTRUCTION_EMITTER = gs_54
+      structure List = gs_9
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure RAGraph = gs_110
+      signature RA_SPILL = gs_111
+      signature RA_SPILL_HEURISTICS = gs_116
+      signature REWRITE_INSTRUCTIONS = gs_173
+      functor RegisterAllocator = gs_126
+      structure Word = gs_8
+      ../ra/risc-ra.sml
+   in
+      functor gs_174 = RISC_RA
+   end
+   local
+      signature CFG_OPTIMIZATION = gs_99
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSN_PROPERTIES = gs_73
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscControl = gs_64
+      signature SDI_JUMPS = gs_74
+      ../flowgraph/cfgCountCopies.sml
+   in
+      functor gs_175 = CFGCountCopies
+   end
+   local
+      signature ASSEMBLY_EMITTER = gs_35
+      structure Annotations = gs_1
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure Graph = gs_0
+      signature INSTRUCTION_EMITTER = gs_54
+      structure List = gs_9
+      structure PseudoOpsBasisTyp = gs_30
+      ../emit/cfgEmit.sml
+   in
+      functor gs_176 = CFGEmit
+   end
+   local
+      structure Array = gs_4
+      signature GETREG = gs_57
+      ../ra/getreg2.sml
+   in
+      functor gs_177 = GetReg2
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_34
+      structure CellsBasis = gs_13
+      signature INSTRUCTIONS = gs_15
+      structure Int32 = gs_17
+      ../omit-frameptr/omit-frame-pointer.sig
+   in
+      signature gs_178 = OMIT_FRAME_POINTER
+   end
+   local
+      signature MLRISC_CONTROL = gs_63
+      structure MLRiscControl = gs_64
+      signature RA = gs_121
+      structure RACore = gs_125
+      signature RA_FLOWGRAPH_PARTITIONER = gs_78
+      ../ra/region-based-ra.sml
+   in
+      functor gs_179 = RegionBasedRA
+   end
+   local
+      signature MLRISC_REGION = gs_89
+      structure String = gs_7
+      ../aliasing/mlriscRegion.sml
+   in
+      structure gs_180 = MLRiscRegion
+   end
+   local
+      structure CellsBasis = gs_13
+      signature INSN_PROPERTIES = gs_73
+      signature INSTRUCTION_EMITTER = gs_54
+      structure Int = gs_12
+      structure IntHashTable = gs_108
+      signature MLRISC_CONTROL = gs_63
+      signature MLRISC_ERROR_MSG = gs_10
+      structure MLRiscControl = gs_64
+      structure MLRiscErrorMsg = gs_11
+      structure RACore = gs_125
+      functor RASpillTypes = gs_156
+      signature RA_SPILL = gs_111
+      structure Word = gs_8
+      ../ra/ra-spill.sml
+   in
+      functor gs_181 = RASpill
+   end
+in
+   signature ARCH_SPILL_INSTR = gs_92
+   signature ASM_FORMAT_UTIL = gs_145
+   signature ASM_STREAM = gs_52
+   signature ASSEMBLY_EMITTER = gs_35
+   signature AS_PSEUDO_OPS = gs_76
+   structure AsmFlags = gs_117
+   structure AsmFormatUtil = gs_146
+   structure AsmStream = gs_53
+   signature BBSCHED = gs_72
+   functor BBSched2 = gs_130
+   signature BLOCK_PLACEMENT = gs_107
+   functor BackPatch = gs_159
+   functor BlockPlacement = gs_136
+   functor BuildFlowgraph = gs_114
+   signature CELLS = gs_14
+   signature CELLS_BASIS = gs_5
+   functor CFGCountCopies = gs_175
+   functor CFGEmit = gs_176
+   functor CFGExpandCopies = gs_100
+   signature CFG_OPTIMIZATION = gs_99
+   signature CLIENT_PSEUDO_OPS = gs_32
+   signature CODE_STRING = gs_79
+   signature COMPUTE_EXECUTION_FREQUENCIES = gs_83
+   signature CONSTANT = gs_25
+   signature CONTROL_FLOWGRAPH_GEN = gs_115
+   signature CONTROL_FLOW_GRAPH = gs_34
+   structure CTypes = gs_60
+   signature C_CALLS = gs_61
+   functor Cells = gs_143
+   structure CellsBasis = gs_13
+   structure ChaitinSpillHeur = gs_132
+   functor CheckPlacementFn = gs_142
+   structure ChowHennessySpillHeur = gs_161
+   functor ClusterRA = gs_131
+   functor CompleteProbsFn = gs_86
+   functor ComputeFreqsFn = gs_87
+   functor ControlFlowGraph = gs_168
+   signature DELAY_SLOT_PROPERTIES = gs_59
+   signature DOMINATOR_TREE = gs_38
+   functor DarwinPseudoOps = gs_77
+   functor DefaultBlockPlacement = gs_135
+   functor DominatorTree = gs_43
+   functor EstimateLoopProbsFn = gs_152
+   signature FREQUENCY_PROPERTIES = gs_112
+   functor FreqProps = gs_113
+   functor GCCells = gs_141
+   signature GC_CELLS = gs_119
+   signature GC_TYPE = gs_118
+   signature GETREG = gs_57
+   functor GasPseudoOps = gs_93
+   functor GetReg = gs_58
+   functor GetReg2 = gs_177
+   signature INSN_PROPERTIES = gs_73
+   signature INSTRUCTIONS = gs_15
+   signature INSTRUCTION_EMITTER = gs_54
+   signature INSTRUCTION_STREAM = gs_44
+   functor InstructionStream = gs_45
+   functor JumpChainElimFn = gs_98
+   signature LABEL = gs_26
+   signature LIVENESS = gs_171
+   signature LOOP_STRUCTURE = gs_39
+   structure Label = gs_27
+   functor Liveness = gs_172
+   functor LoopStructure = gs_129
+   signature MACHINE_INT = gs_21
+   signature MC_EMIT = gs_158
+   signature MLRISC_ANNOTATIONS = gs_84
+   signature MLRISC_OPTIMIZATION = gs_90
+   signature MLRISC_REGION = gs_89
+   structure MLRiscAnnotations = gs_85
+   structure MLRiscRegion = gs_180
+   signature MLTREE = gs_28
+   signature MLTREECOMP = gs_49
+   signature MLTREEGEN = gs_47
+   signature MLTREE_BASIS = gs_23
+   signature MLTREE_EVAL = gs_70
+   signature MLTREE_EXTENSION = gs_22
+   signature MLTREE_EXTENSION_COMP = gs_50
+   signature MLTREE_HASH = gs_88
+   signature MLTREE_MULT_DIV = gs_137
+   signature MLTREE_SIZE = gs_46
+   signature MLTREE_STREAM = gs_48
+   structure MLTreeBasis = gs_105
+   functor MLTreeCheckTy = gs_36
+   functor MLTreeEval = gs_140
+   functor MLTreeF = gs_169
+   functor MLTreeGen = gs_104
+   functor MLTreeHash = gs_139
+   functor MLTreeMult = gs_138
+   functor MLTreeSize = gs_103
+   functor MLTreeStream = gs_101
+   structure MachineInt = gs_154
+   functor MemoryRA = gs_155
+   functor NoDelaySlots = gs_144
+   signature OMIT_FRAME_POINTER = gs_178
+   signature POINTS_TO = gs_66
+   signature PRINT_FLOWGRAPH = gs_55
+   signature PSEUDO_OPS = gs_33
+   signature PSEUDO_OPS_BASIS = gs_31
+   signature PSEUDO_OPS_ENDIAN = gs_69
+   structure PointsTo = gs_67
+   functor PrintFlowgraph = gs_56
+   functor PseudoOps = gs_106
+   structure PseudoOpsBasisTyp = gs_30
+   functor PseudoOpsBig = gs_71
+   functor PseudoOpsLittle = gs_102
+   signature RA = gs_121
+   structure RACore = gs_125
+   functor RADeadCodeElim = gs_127
+   structure RAGraph = gs_110
+   functor RASpill = gs_181
+   functor RASpillTypes = gs_156
+   signature RA_BITMATRIX = gs_94
+   signature RA_CORE = gs_123
+   signature RA_FLOWGRAPH = gs_120
+   signature RA_FLOWGRAPH_PARTITIONER = gs_78
+   signature RA_GRAPH = gs_109
+   signature RA_PRIORITY_QUEUE = gs_95
+   signature RA_SPILL = gs_111
+   signature RA_SPILL_HEURISTICS = gs_116
+   signature REGION = gs_24
+   signature REWRITE_INSTRUCTIONS = gs_173
+   functor RISC_RA = gs_174
+   structure RaBitmatrix = gs_97
+   functor RaPriQueue = gs_124
+   functor RegionBasedRA = gs_179
+   functor RegisterAllocator = gs_126
+   signature SDI_JUMPS = gs_74
+   signature SHUFFLE = gs_91
+   functor Shuffle = gs_149
+   functor SpanDependencyResolution = gs_75
+   functor UnimplementedCCallsFn = gs_62
+   functor WeightedBlockPlacementFn = gs_134
+end
+end
+
+end
diff --git a/mlb/MLTREE.mlb b/mlb/MLTREE.mlb
new file mode 100644
index 0000000..167f3b4
--- /dev/null
+++ b/mlb/MLTREE.mlb
@@ -0,0 +1,209 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l18 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l41 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l67 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = MLTREE
+   end
+   local
+      signature MLTREE = gs_0
+      ../mltree/mltree-rewrite.sig
+   in
+      signature gs_1 = MLTREE_REWRITE
+   end
+   local
+      signature MLTREE = gs_0
+      signature MLTREE_REWRITE = gs_1
+      ../mltree/mltree-rewrite.sml
+   in
+      functor gs_2 = MLTreeRewrite
+   end
+   local
+      signature MLTREE = gs_0
+      ../mltree/mltree-fold.sig
+   in
+      signature gs_3 = MLTREE_FOLD
+   end
+   local
+      open l18
+   in
+      structure gs_4 = Word
+   end
+   local
+      open l4
+   in
+      structure gs_5 = CellsBasis
+   end
+   local
+      open l18
+   in
+      structure gs_6 = IntInf
+   end
+   local
+      open l4
+   in
+      structure gs_7 = Label
+   end
+   local
+      open l18
+   in
+      structure gs_8 = String
+   end
+   local
+      open l18
+   in
+      structure gs_9 = List
+   end
+   local
+      open l18
+   in
+      structure gs_10 = Char
+   end
+   local
+      open l41
+   in
+      signature gs_11 = MLRISC_ERROR_MSG
+      structure gs_12 = MLRiscErrorMsg
+   end
+   local
+      open l18
+   in
+      structure gs_13 = Int
+   end
+   local
+      signature MLTREE = gs_0
+      ../mltree/mltree-utils.sig
+   in
+      signature gs_14 = MLTREE_UTILS
+   end
+   local
+      structure CellsBasis = gs_5
+      structure Char = gs_10
+      structure Int = gs_13
+      structure IntInf = gs_6
+      structure Label = gs_7
+      structure List = gs_9
+      signature MLRISC_ERROR_MSG = gs_11
+      structure MLRiscErrorMsg = gs_12
+      signature MLTREE = gs_0
+      signature MLTREE_UTILS = gs_14
+      structure String = gs_8
+      structure Word = gs_4
+      ../mltree/mltree-utils.sml
+   in
+      functor gs_15 = MLTreeUtils
+   end
+   local
+      open l4
+   in
+      signature gs_16 = CONTROL_FLOW_GRAPH
+   end
+   local
+      open l4
+   in
+      signature gs_17 = INSTRUCTION_STREAM
+   end
+   local
+      open l4
+   in
+      signature gs_18 = INSTRUCTIONS
+   end
+   local
+      open l4
+   in
+      signature gs_19 = CELLS
+   end
+   local
+      open l67
+   in
+      structure gs_20 = Annotations
+   end
+   local
+      structure Annotations = gs_20
+      signature CELLS = gs_19
+      signature CONTROL_FLOW_GRAPH = gs_16
+      signature INSTRUCTIONS = gs_18
+      signature INSTRUCTION_STREAM = gs_17
+      ../mltree/instr-gen.sig
+   in
+      signature gs_21 = INSTR_GEN
+   end
+   local
+      signature MLTREE = gs_0
+      signature MLTREE_FOLD = gs_3
+      ../mltree/mltree-fold.sml
+   in
+      functor gs_22 = MLTreeFold
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_16
+      signature INSTRUCTIONS = gs_18
+      signature INSTRUCTION_STREAM = gs_17
+      signature INSTR_GEN = gs_21
+      signature MLRISC_ERROR_MSG = gs_11
+      structure MLRiscErrorMsg = gs_12
+      ../mltree/instr-gen.sml
+   in
+      functor gs_23 = InstrGen
+   end
+   local
+      signature MLTREE = gs_0
+      ../mltree/mltree-simplify.sig
+   in
+      signature gs_24 = MLTREE_SIMPLIFIER
+   end
+   local
+      open l4
+   in
+      signature gs_25 = MLTREE_SIZE
+   end
+   local
+      structure IntInf = gs_6
+      signature MLTREE = gs_0
+      signature MLTREE_SIMPLIFIER = gs_24
+      signature MLTREE_SIZE = gs_25
+      functor MLTreeRewrite = gs_2
+      ../mltree/mltree-simplify.sml
+   in
+      functor gs_26 = MLTreeSimplifier
+   end
+in
+   signature INSTR_GEN = gs_21
+   functor InstrGen = gs_23
+   signature MLTREE_FOLD = gs_3
+   signature MLTREE_REWRITE = gs_1
+   signature MLTREE_SIMPLIFIER = gs_24
+   signature MLTREE_UTILS = gs_14
+   functor MLTreeFold = gs_22
+   functor MLTreeRewrite = gs_2
+   functor MLTreeSimplifier = gs_26
+   functor MLTreeUtils = gs_15
+end
+end
+
+end
diff --git a/mlb/PPC.mlb b/mlb/PPC.mlb
new file mode 100644
index 0000000..65d3f05
--- /dev/null
+++ b/mlb/PPC.mlb
@@ -0,0 +1,573 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l42 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l116 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l50 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l9 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = FREQUENCY_PROPERTIES
+   end
+   local
+      open l9
+   in
+      signature gs_1 = PROBABILITY
+      structure gs_2 = Probability
+   end
+   local
+      open l4
+   in
+      structure gs_3 = MLRiscAnnotations
+   end
+   local
+      open l4
+   in
+      signature gs_4 = REGION
+   end
+   local
+      open l4
+   in
+      signature gs_5 = CONSTANT
+   end
+   local
+      open l4
+   in
+      signature gs_6 = MLTREE
+   end
+   local
+      open l4
+   in
+      signature gs_7 = CELLS_BASIS
+   end
+   local
+      open l4
+   in
+      structure gs_8 = CellsBasis
+   end
+   local
+      open l4
+   in
+      structure gs_9 = Label
+   end
+   local
+      open l9
+   in
+      structure gs_10 = Annotations
+   end
+   local
+      open l4
+   in
+      functor gs_11 = Cells
+   end
+   local
+      open l42
+   in
+      structure gs_12 = Int
+   end
+   local
+      open l4
+   in
+      signature gs_13 = CELLS
+   end
+   local
+      open l50
+   in
+      signature gs_14 = MLRISC_ERROR_MSG
+      structure gs_15 = MLRiscErrorMsg
+   end
+   local
+      open l50
+   in
+      signature gs_16 = MLRISC_CONTROL
+      structure gs_17 = MLRiscControl
+   end
+   local
+      signature MLRISC_CONTROL = gs_16
+      structure MLRiscControl = gs_17
+      ../ppc/emit/ppcAsmSyntax.sml
+   in
+      structure gs_18 = PPCAsmSyntax
+   end
+   local
+      signature CELLS = gs_13
+      functor Cells = gs_11
+      structure CellsBasis = gs_8
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      structure PPCAsmSyntax = gs_18
+      ../ppc/instructions/ppcCells.sml
+   in
+      signature gs_19 = PPCCELLS
+      structure gs_20 = PPCCells
+   end
+   local
+      structure Annotations = gs_10
+      signature CELLS_BASIS = gs_7
+      signature CONSTANT = gs_5
+      structure CellsBasis = gs_8
+      structure Label = gs_9
+      signature MLTREE = gs_6
+      signature PPCCELLS = gs_19
+      structure PPCCells = gs_20
+      signature REGION = gs_4
+      ../ppc/instructions/ppcInstr.sml
+   in
+      signature gs_21 = PPCINSTR
+      functor gs_22 = PPCInstr
+   end
+   local
+      signature FREQUENCY_PROPERTIES = gs_0
+      structure MLRiscAnnotations = gs_3
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      signature PROBABILITY = gs_1
+      structure Probability = gs_2
+      ../ppc/instructions/ppcFreqProps.sml
+   in
+      functor gs_23 = PPCFreqProps
+   end
+   local
+      open l4
+   in
+      signature gs_24 = INSTRUCTION_EMITTER
+   end
+   local
+      open l4
+   in
+      signature gs_25 = ASM_FORMAT_UTIL
+      structure gs_26 = AsmFormatUtil
+   end
+   local
+      open l4
+   in
+      signature gs_27 = ASM_STREAM
+      structure gs_28 = AsmStream
+   end
+   local
+      open l42
+   in
+      structure gs_29 = TextIO
+   end
+   local
+      open l42
+   in
+      structure gs_30 = String
+   end
+   local
+      open l4
+   in
+      structure gs_31 = AsmFlags
+   end
+   local
+      open l4
+   in
+      signature gs_32 = MLTREE_EVAL
+   end
+   local
+      open l4
+   in
+      signature gs_33 = INSTRUCTION_STREAM
+   end
+   local
+      structure CellsBasis = gs_8
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      ../ppc/instructions/ppcShuffle.sig
+   in
+      signature gs_34 = PPCSHUFFLE
+   end
+   local
+      signature ASM_FORMAT_UTIL = gs_25
+      signature ASM_STREAM = gs_27
+      structure Annotations = gs_10
+      structure AsmFlags = gs_31
+      structure AsmFormatUtil = gs_26
+      structure AsmStream = gs_28
+      structure CellsBasis = gs_8
+      signature INSTRUCTION_EMITTER = gs_24
+      signature INSTRUCTION_STREAM = gs_33
+      structure Int = gs_12
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_32
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      signature PPCSHUFFLE = gs_34
+      structure String = gs_30
+      structure TextIO = gs_29
+      ../ppc/emit/ppcAsm.sml
+   in
+      functor gs_35 = PPCAsmEmitter
+   end
+   local
+      structure CellsBasis = gs_8
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      ../ppc/mltree/ppcPseudoInstr.sig
+   in
+      signature gs_36 = PPC_PSEUDO_INSTR
+   end
+   local
+      open l4
+   in
+      signature gs_37 = PSEUDO_OPS_BASIS
+   end
+   local
+      open l4
+   in
+      functor gs_38 = PseudoOpsBig
+   end
+   local
+      open l116
+   in
+      structure gs_39 = Format
+   end
+   local
+      open l4
+   in
+      structure gs_40 = PseudoOpsBasisTyp
+   end
+   local
+      open l42
+   in
+      structure gs_41 = IntInf
+   end
+   local
+      open l42
+   in
+      structure gs_42 = Word32
+   end
+   local
+      open l116
+   in
+      structure gs_43 = Atom
+   end
+   local
+      structure Atom = gs_43
+      structure Format = gs_39
+      structure Int = gs_12
+      structure IntInf = gs_41
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE = gs_6
+      signature MLTREE_EVAL = gs_32
+      signature PSEUDO_OPS_BASIS = gs_37
+      structure PseudoOpsBasisTyp = gs_40
+      functor PseudoOpsBig = gs_38
+      structure String = gs_30
+      structure Word32 = gs_42
+      ../ppc/flowgraph/ppcDarwinPseudoOps.sml
+   in
+      functor gs_44 = PPCDarwinPseudoOps
+   end
+   local
+      open l4
+   in
+      signature gs_45 = ARCH_SPILL_INSTR
+   end
+   local
+      structure CellsBasis = gs_8
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      ../ppc/ra/ppcRewrite.sml
+   in
+      functor gs_46 = PPCRewrite
+   end
+   local
+      signature ARCH_SPILL_INSTR = gs_45
+      structure CellsBasis = gs_8
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      functor PPCRewrite = gs_46
+      ../ppc/ra/ppcSpillInstr.sml
+   in
+      functor gs_47 = PPCSpillInstr
+   end
+   local
+      open l4
+   in
+      functor gs_48 = GasPseudoOps
+   end
+   local
+      structure Format = gs_39
+      functor GasPseudoOps = gs_48
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE = gs_6
+      signature MLTREE_EVAL = gs_32
+      signature PSEUDO_OPS_BASIS = gs_37
+      structure PseudoOpsBasisTyp = gs_40
+      functor PseudoOpsBig = gs_38
+      structure Word32 = gs_42
+      ../ppc/flowgraph/ppcGasPseudoOps.sml
+   in
+      functor gs_49 = PPCGasPseudoOps
+   end
+   local
+      open l4
+   in
+      signature gs_50 = INSN_PROPERTIES
+   end
+   local
+      open l42
+   in
+      structure gs_51 = Word
+   end
+   local
+      open l4
+   in
+      signature gs_52 = MLTREE_HASH
+   end
+   local
+      structure CellsBasis = gs_8
+      signature INSN_PROPERTIES = gs_50
+      structure IntInf = gs_41
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_32
+      signature MLTREE_HASH = gs_52
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      structure Word = gs_51
+      ../ppc/instructions/ppcProps.sml
+   in
+      functor gs_53 = PPCProps
+   end
+   local
+      open l4
+   in
+      signature gs_54 = SDI_JUMPS
+   end
+   local
+      structure CellsBasis = gs_8
+      signature MLRISC_CONTROL = gs_16
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscControl = gs_17
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_32
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      signature PPCSHUFFLE = gs_34
+      signature SDI_JUMPS = gs_54
+      structure Word = gs_51
+      ../ppc/backpatch/ppcJumps.sml
+   in
+      functor gs_55 = PPCJumps
+   end
+   local
+      ../ppc/instructions/ppcInstrExt.sml
+   in
+      structure gs_56 = PPCInstrExt
+   end
+   local
+      open l4
+   in
+      signature gs_57 = CONTROL_FLOW_GRAPH
+   end
+   local
+      open l4
+   in
+      signature gs_58 = MLTREE_STREAM
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_57
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_STREAM = gs_58
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      structure PPCInstrExt = gs_56
+      ../ppc/instructions/ppcCompInstrExt.sml
+   in
+      signature gs_59 = PPCCOMP_INSTR_EXT
+      functor gs_60 = PPCCompInstrExt
+   end
+   local
+      open l4
+   in
+      signature gs_61 = DELAY_SLOT_PROPERTIES
+   end
+   local
+      signature DELAY_SLOT_PROPERTIES = gs_61
+      signature INSN_PROPERTIES = gs_50
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      ../ppc/backpatch/ppcDelaySlots.sml
+   in
+      functor gs_62 = PPCDelaySlots
+   end
+   local
+      open l4
+   in
+      structure gs_63 = CTypes
+   end
+   local
+      open l42
+   in
+      structure gs_64 = List
+   end
+   local
+      open l4
+   in
+      signature gs_65 = C_CALLS
+   end
+   local
+      structure CTypes = gs_63
+      signature C_CALLS = gs_65
+      structure Int = gs_12
+      structure IntInf = gs_41
+      structure List = gs_64
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscAnnotations = gs_3
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE = gs_6
+      signature PPCCELLS = gs_19
+      structure PPCCells = gs_20
+      structure String = gs_30
+      structure Word = gs_51
+      ../ppc/c-calls/ppc-macosx.sml
+   in
+      functor gs_66 = PPCMacOSX_CCalls
+      signature gs_67 = PPC_MACOSX_C_CALLS
+   end
+   local
+      open l4
+   in
+      functor gs_68 = Shuffle
+   end
+   local
+      structure CellsBasis = gs_8
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      functor Shuffle = gs_68
+      ../ppc/instructions/ppcShuffle.sml
+   in
+      functor gs_69 = PPCShuffle
+   end
+   local
+      open l42
+   in
+      structure gs_70 = Word8
+   end
+   local
+      open l4
+   in
+      signature gs_71 = CODE_STRING
+   end
+   local
+      signature CODE_STRING = gs_71
+      structure CellsBasis = gs_8
+      signature INSTRUCTION_EMITTER = gs_24
+      signature INSTRUCTION_STREAM = gs_33
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREE_EVAL = gs_32
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      structure Word32 = gs_42
+      structure Word8 = gs_70
+      ../ppc/emit/ppcMC.sml
+   in
+      functor gs_72 = PPCMCEmitter
+   end
+   local
+      open l4
+   in
+      functor gs_73 = MLTreeMult
+   end
+   local
+      open l4
+   in
+      functor gs_74 = MLTreeGen
+   end
+   local
+      open l4
+   in
+      signature gs_75 = MLTREECOMP
+      signature gs_76 = MLTREE_EXTENSION_COMP
+   end
+   local
+      structure CellsBasis = gs_8
+      structure Int = gs_12
+      structure Label = gs_9
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscAnnotations = gs_3
+      structure MLRiscErrorMsg = gs_15
+      signature MLTREECOMP = gs_75
+      signature MLTREE_EXTENSION_COMP = gs_76
+      functor MLTreeGen = gs_74
+      functor MLTreeMult = gs_73
+      signature PPCINSTR = gs_21
+      functor PPCInstr = gs_22
+      signature PPC_PSEUDO_INSTR = gs_36
+      structure Word32 = gs_42
+      ../ppc/mltree/ppc.sml
+   in
+      functor gs_77 = PPC
+   end
+in
+   functor PPC = gs_77
+   functor PPCAsmEmitter = gs_35
+   structure PPCAsmSyntax = gs_18
+   signature PPCCELLS = gs_19
+   signature PPCCOMP_INSTR_EXT = gs_59
+   structure PPCCells = gs_20
+   functor PPCCompInstrExt = gs_60
+   functor PPCDarwinPseudoOps = gs_44
+   functor PPCDelaySlots = gs_62
+   functor PPCFreqProps = gs_23
+   functor PPCGasPseudoOps = gs_49
+   signature PPCINSTR = gs_21
+   functor PPCInstr = gs_22
+   structure PPCInstrExt = gs_56
+   functor PPCJumps = gs_55
+   functor PPCMCEmitter = gs_72
+   functor PPCMacOSX_CCalls = gs_66
+   functor PPCProps = gs_53
+   functor PPCRewrite = gs_46
+   signature PPCSHUFFLE = gs_34
+   functor PPCShuffle = gs_69
+   functor PPCSpillInstr = gs_47
+   signature PPC_PSEUDO_INSTR = gs_36
+end
+end
+
+end
diff --git a/mlb/Peephole.mlb b/mlb/Peephole.mlb
new file mode 100644
index 0000000..800b311
--- /dev/null
+++ b/mlb/Peephole.mlb
@@ -0,0 +1,61 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l14 =
+    bas
+      (* $Graphs.cm(=(proxyLib.cm):.)/Graphs.cm =??=> *) Graphs.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = INSTRUCTIONS
+   end
+   local
+      signature INSTRUCTIONS = gs_0
+      ../instructions/peephole.sig
+   in
+      signature gs_1 = PEEPHOLE
+   end
+   local
+      open l4
+   in
+      signature gs_2 = CFG_OPTIMIZATION
+   end
+   local
+      open l14
+   in
+      structure gs_3 = Graph
+   end
+   local
+      open l4
+   in
+      signature gs_4 = CONTROL_FLOW_GRAPH
+   end
+   local
+      signature CFG_OPTIMIZATION = gs_2
+      signature CONTROL_FLOW_GRAPH = gs_4
+      structure Graph = gs_3
+      signature PEEPHOLE = gs_1
+      ../flowgraph/cfgPeephole.sml
+   in
+      functor gs_5 = CFGPeephole
+   end
+in
+   functor CFGPeephole = gs_5
+   signature PEEPHOLE = gs_1
+end
+end
+
+end
diff --git a/mlb/RA.mlb b/mlb/RA.mlb
new file mode 100644
index 0000000..d089254
--- /dev/null
+++ b/mlb/RA.mlb
@@ -0,0 +1,152 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l11 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l22 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l53 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l29 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = RA_SPILL_HEURISTICS
+   end
+   local
+      open l4
+   in
+      structure gs_1 = RACore
+   end
+   local
+      open l11
+   in
+      structure gs_2 = Real
+   end
+   local
+      open l4
+   in
+      structure gs_3 = RAGraph
+   end
+   local
+      structure RACore = gs_1
+      structure RAGraph = gs_3
+      signature RA_SPILL_HEURISTICS = gs_0
+      structure Real = gs_2
+      ../ra/chaitin-spillheur2.sml
+   in
+      functor gs_4 = ImprovedChaitinSpillHeur
+   end
+   local
+      open l22
+   in
+      structure gs_5 = IntHashTable
+   end
+   local
+      open l11
+   in
+      structure gs_6 = Option
+   end
+   local
+      open l29
+   in
+      structure gs_7 = PriorityHeap
+   end
+   local
+      structure IntHashTable = gs_5
+      structure Option = gs_6
+      structure PriorityHeap = gs_7
+      structure RACore = gs_1
+      structure RAGraph = gs_3
+      signature RA_SPILL_HEURISTICS = gs_0
+      structure Real = gs_2
+      ../ra/chow-hennessy-spillheur2.sml
+   in
+      functor gs_8 = ImprovedChowHennessySpillHeur
+   end
+   local
+      open l4
+   in
+      signature gs_9 = RA_SPILL
+   end
+   local
+      open l11
+   in
+      structure gs_10 = Int
+   end
+   local
+      open l4
+   in
+      functor gs_11 = RASpillTypes
+   end
+   local
+      open l4
+   in
+      structure gs_12 = CellsBasis
+   end
+   local
+      open l11
+   in
+      structure gs_13 = Word
+   end
+   local
+      open l53
+   in
+      signature gs_14 = MLRISC_ERROR_MSG
+      structure gs_15 = MLRiscErrorMsg
+   end
+   local
+      open l4
+   in
+      signature gs_16 = INSTRUCTION_EMITTER
+   end
+   local
+      open l4
+   in
+      signature gs_17 = INSN_PROPERTIES
+   end
+   local
+      structure CellsBasis = gs_12
+      signature INSN_PROPERTIES = gs_17
+      signature INSTRUCTION_EMITTER = gs_16
+      structure Int = gs_10
+      structure IntHashTable = gs_5
+      signature MLRISC_ERROR_MSG = gs_14
+      structure MLRiscErrorMsg = gs_15
+      structure RACore = gs_1
+      functor RASpillTypes = gs_11
+      signature RA_SPILL = gs_9
+      structure Word = gs_13
+      ../ra/ra-spill-with-renaming.sml
+   in
+      functor gs_18 = RASpillWithRenaming
+   end
+in
+   functor ImprovedChaitinSpillHeur = gs_4
+   functor ImprovedChowHennessySpillHeur = gs_8
+   functor RASpillWithRenaming = gs_18
+end
+end
+
+end
diff --git a/mlb/SPARC.mlb b/mlb/SPARC.mlb
new file mode 100644
index 0000000..1b14d64
--- /dev/null
+++ b/mlb/SPARC.mlb
@@ -0,0 +1,538 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l38 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l136 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+  basis l4 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+  basis l46 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l30 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l4
+   in
+      signature gs_0 = CONTROL_FLOW_GRAPH
+   end
+   local
+      open l4
+   in
+      signature gs_1 = MLTREE_STREAM
+   end
+   local
+      open l4
+   in
+      signature gs_2 = MLTREE
+   end
+   local
+      open l4
+   in
+      signature gs_3 = REGION
+   end
+   local
+      open l4
+   in
+      signature gs_4 = CONSTANT
+   end
+   local
+      open l4
+   in
+      signature gs_5 = CELLS_BASIS
+   end
+   local
+      open l4
+   in
+      structure gs_6 = CellsBasis
+   end
+   local
+      open l4
+   in
+      structure gs_7 = Label
+   end
+   local
+      open l30
+   in
+      structure gs_8 = Annotations
+   end
+   local
+      open l4
+   in
+      functor gs_9 = Cells
+   end
+   local
+      open l38
+   in
+      structure gs_10 = Int
+   end
+   local
+      open l4
+   in
+      signature gs_11 = CELLS
+   end
+   local
+      open l46
+   in
+      signature gs_12 = MLRISC_ERROR_MSG
+      structure gs_13 = MLRiscErrorMsg
+   end
+   local
+      signature CELLS = gs_11
+      functor Cells = gs_9
+      structure CellsBasis = gs_6
+      structure Int = gs_10
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      ../sparc/instructions/sparcCells.sml
+   in
+      signature gs_14 = SPARCCELLS
+      structure gs_15 = SparcCells
+   end
+   local
+      structure Annotations = gs_8
+      signature CELLS_BASIS = gs_5
+      signature CONSTANT = gs_4
+      structure CellsBasis = gs_6
+      structure Label = gs_7
+      signature MLTREE = gs_2
+      signature REGION = gs_3
+      signature SPARCCELLS = gs_14
+      structure SparcCells = gs_15
+      ../sparc/instructions/sparcInstr.sml
+   in
+      signature gs_16 = SPARCINSTR
+      functor gs_17 = SparcInstr
+   end
+   local
+      ../sparc/instructions/sparcinstr-ext.sml
+   in
+      structure gs_18 = SparcInstrExt
+   end
+   local
+      signature CONTROL_FLOW_GRAPH = gs_0
+      signature MLTREE = gs_2
+      signature MLTREE_STREAM = gs_1
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      structure SparcInstrExt = gs_18
+      ../sparc/instructions/sparccomp-instr-ext.sml
+   in
+      signature gs_19 = SPARCCOMP_INSTR_EXT
+      functor gs_20 = SparcCompInstrExt
+   end
+   local
+      open l4
+   in
+      signature gs_21 = INSTRUCTION_EMITTER
+   end
+   local
+      open l38
+   in
+      structure gs_22 = Word8
+   end
+   local
+      open l38
+   in
+      structure gs_23 = Word32
+   end
+   local
+      open l4
+   in
+      signature gs_24 = CODE_STRING
+   end
+   local
+      open l4
+   in
+      signature gs_25 = INSTRUCTION_STREAM
+   end
+   local
+      open l4
+   in
+      signature gs_26 = MLTREE_EVAL
+   end
+   local
+      signature CODE_STRING = gs_24
+      structure CellsBasis = gs_6
+      signature INSTRUCTION_EMITTER = gs_21
+      signature INSTRUCTION_STREAM = gs_25
+      structure Label = gs_7
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_26
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      structure Word32 = gs_23
+      structure Word8 = gs_22
+      ../sparc/emit/sparcMC.sml
+   in
+      functor gs_27 = SparcMCEmitter
+   end
+   local
+      open l4
+   in
+      functor gs_28 = Shuffle
+   end
+   local
+      open l38
+   in
+      structure gs_29 = Option
+   end
+   local
+      structure CellsBasis = gs_6
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      ../sparc/instructions/sparcShuffle.sig
+   in
+      signature gs_30 = SPARCSHUFFLE
+   end
+   local
+      structure CellsBasis = gs_6
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      structure Option = gs_29
+      signature SPARCINSTR = gs_16
+      signature SPARCSHUFFLE = gs_30
+      functor Shuffle = gs_28
+      functor SparcInstr = gs_17
+      structure Word32 = gs_23
+      ../sparc/instructions/sparcShuffle.sml
+   in
+      functor gs_31 = SparcShuffle
+   end
+   local
+      open l4
+   in
+      signature gs_32 = DELAY_SLOT_PROPERTIES
+   end
+   local
+      open l4
+   in
+      signature gs_33 = INSN_PROPERTIES
+   end
+   local
+      structure CellsBasis = gs_6
+      signature DELAY_SLOT_PROPERTIES = gs_32
+      signature INSN_PROPERTIES = gs_33
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      structure Option = gs_29
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      ../sparc/backpatch/sparcDelaySlotProps.sml
+   in
+      functor gs_34 = SparcDelaySlots
+   end
+   local
+      open l4
+   in
+      signature gs_35 = FREQUENCY_PROPERTIES
+   end
+   local
+      open l30
+   in
+      signature gs_36 = PROBABILITY
+      structure gs_37 = Probability
+   end
+   local
+      open l4
+   in
+      structure gs_38 = MLRiscAnnotations
+   end
+   local
+      signature FREQUENCY_PROPERTIES = gs_35
+      structure MLRiscAnnotations = gs_38
+      signature PROBABILITY = gs_36
+      structure Probability = gs_37
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      ../sparc/instructions/sparcFreqProps.sml
+   in
+      functor gs_39 = SparcFreqProps
+   end
+   local
+      open l4
+   in
+      signature gs_40 = PSEUDO_OPS_BASIS
+   end
+   local
+      open l4
+   in
+      functor gs_41 = GasPseudoOps
+   end
+   local
+      open l4
+   in
+      functor gs_42 = PseudoOpsBig
+   end
+   local
+      open l136
+   in
+      structure gs_43 = Format
+   end
+   local
+      open l4
+   in
+      structure gs_44 = PseudoOpsBasisTyp
+   end
+   local
+      structure Format = gs_43
+      functor GasPseudoOps = gs_41
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE = gs_2
+      signature MLTREE_EVAL = gs_26
+      signature PSEUDO_OPS_BASIS = gs_40
+      structure PseudoOpsBasisTyp = gs_44
+      functor PseudoOpsBig = gs_42
+      structure Word32 = gs_23
+      ../sparc/flowgraph/sparcGasPseudoOps.sml
+   in
+      functor gs_45 = SparcGasPseudoOps
+   end
+   local
+      open l4
+   in
+      functor gs_46 = MLTreeMult
+   end
+   local
+      open l4
+   in
+      functor gs_47 = MLTreeGen
+   end
+   local
+      open l4
+   in
+      signature gs_48 = MLTREECOMP
+      signature gs_49 = MLTREE_EXTENSION_COMP
+   end
+   local
+      structure CellsBasis = gs_6
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      ../sparc/mltree/sparcPseudoInstr.sig
+   in
+      signature gs_50 = SPARC_PSEUDO_INSTR
+   end
+   local
+      structure CellsBasis = gs_6
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscAnnotations = gs_38
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREECOMP = gs_48
+      signature MLTREE_EXTENSION_COMP = gs_49
+      functor MLTreeGen = gs_47
+      functor MLTreeMult = gs_46
+      signature SPARCINSTR = gs_16
+      signature SPARC_PSEUDO_INSTR = gs_50
+      functor SparcInstr = gs_17
+      structure Word32 = gs_23
+      ../sparc/mltree/sparc.sml
+   in
+      functor gs_51 = Sparc
+   end
+   local
+      open l38
+   in
+      structure gs_52 = IntInf
+   end
+   local
+      open l38
+   in
+      structure gs_53 = Word
+   end
+   local
+      open l4
+   in
+      signature gs_54 = MLTREE_HASH
+   end
+   local
+      structure CellsBasis = gs_6
+      signature INSN_PROPERTIES = gs_33
+      structure IntInf = gs_52
+      structure Label = gs_7
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_26
+      signature MLTREE_HASH = gs_54
+      structure Option = gs_29
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      structure Word = gs_53
+      ../sparc/instructions/sparcProps.sml
+   in
+      functor gs_55 = SparcProps
+   end
+   local
+      open l4
+   in
+      signature gs_56 = SDI_JUMPS
+   end
+   local
+      structure CellsBasis = gs_6
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_26
+      signature SDI_JUMPS = gs_56
+      signature SPARCINSTR = gs_16
+      signature SPARCSHUFFLE = gs_30
+      functor SparcInstr = gs_17
+      structure Word32 = gs_23
+      ../sparc/backpatch/sparcJumps.sml
+   in
+      functor gs_57 = SparcJumps
+   end
+   local
+      open l4
+   in
+      signature gs_58 = C_CALLS
+   end
+   local
+      open l4
+   in
+      structure gs_59 = CTypes
+   end
+   local
+      open l38
+   in
+      structure gs_60 = String
+   end
+   local
+      open l38
+   in
+      structure gs_61 = List
+   end
+   local
+      structure CTypes = gs_59
+      signature C_CALLS = gs_58
+      structure Int = gs_10
+      structure List = gs_61
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscAnnotations = gs_38
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE = gs_2
+      signature SPARCCELLS = gs_14
+      structure SparcCells = gs_15
+      structure SparcInstrExt = gs_18
+      structure String = gs_60
+      ../sparc/c-calls/sparc-c-calls.sml
+   in
+      functor gs_62 = Sparc_CCalls
+   end
+   local
+      open l4
+   in
+      signature gs_63 = ASM_FORMAT_UTIL
+      structure gs_64 = AsmFormatUtil
+   end
+   local
+      open l4
+   in
+      signature gs_65 = ASM_STREAM
+      structure gs_66 = AsmStream
+   end
+   local
+      open l38
+   in
+      structure gs_67 = TextIO
+   end
+   local
+      open l4
+   in
+      structure gs_68 = AsmFlags
+   end
+   local
+      signature ASM_FORMAT_UTIL = gs_63
+      signature ASM_STREAM = gs_65
+      structure Annotations = gs_8
+      structure AsmFlags = gs_68
+      structure AsmFormatUtil = gs_64
+      structure AsmStream = gs_66
+      structure CellsBasis = gs_6
+      signature INSTRUCTION_EMITTER = gs_21
+      signature INSTRUCTION_STREAM = gs_25
+      structure Int = gs_10
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature MLTREE_EVAL = gs_26
+      signature SPARCINSTR = gs_16
+      signature SPARCSHUFFLE = gs_30
+      functor SparcInstr = gs_17
+      structure String = gs_60
+      structure TextIO = gs_67
+      structure Word32 = gs_23
+      ../sparc/emit/sparcAsm.sml
+   in
+      functor gs_69 = SparcAsmEmitter
+   end
+   local
+      structure CellsBasis = gs_6
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      ../sparc/ra/sparcRewrite.sml
+   in
+      functor gs_70 = SparcRewrite
+   end
+   local
+      open l4
+   in
+      signature gs_71 = ARCH_SPILL_INSTR
+   end
+   local
+      signature ARCH_SPILL_INSTR = gs_71
+      structure CellsBasis = gs_6
+      signature MLRISC_ERROR_MSG = gs_12
+      structure MLRiscErrorMsg = gs_13
+      signature SPARCINSTR = gs_16
+      functor SparcInstr = gs_17
+      functor SparcRewrite = gs_70
+      ../sparc/ra/sparcSpillInstr.sml
+   in
+      functor gs_72 = SparcSpillInstr
+   end
+in
+   signature SPARCCELLS = gs_14
+   signature SPARCCOMP_INSTR_EXT = gs_19
+   signature SPARCINSTR = gs_16
+   signature SPARCSHUFFLE = gs_30
+   signature SPARC_PSEUDO_INSTR = gs_50
+   functor Sparc = gs_51
+   functor SparcAsmEmitter = gs_69
+   structure SparcCells = gs_15
+   functor SparcCompInstrExt = gs_20
+   functor SparcDelaySlots = gs_34
+   functor SparcFreqProps = gs_39
+   functor SparcGasPseudoOps = gs_45
+   functor SparcInstr = gs_17
+   structure SparcInstrExt = gs_18
+   functor SparcJumps = gs_57
+   functor SparcMCEmitter = gs_27
+   functor SparcProps = gs_55
+   functor SparcRewrite = gs_70
+   functor SparcShuffle = gs_31
+   functor SparcSpillInstr = gs_72
+   functor Sparc_CCalls = gs_62
+end
+end
+
+end
diff --git a/mlb/StagedAlloc.mlb b/mlb/StagedAlloc.mlb
new file mode 100644
index 0000000..5aa93cc
--- /dev/null
+++ b/mlb/StagedAlloc.mlb
@@ -0,0 +1,91 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l11 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l28 =
+    bas
+      (* $/smlnj-lib.cm ====> *) $(SML_LIB)/smlnj-lib/Util/smlnj-lib.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      ../staged-alloc/conventions/c-loc-kind.sml
+   in
+      structure gs_0 = CLocKind
+   end
+   local
+      ../staged-alloc/allocator/staged-allocation-sig.sml
+   in
+      signature gs_1 = STAGED_ALLOCATION
+   end
+   local
+      open l11
+   in
+      structure gs_2 = List
+   end
+   local
+      open l11
+   in
+      structure gs_3 = Int
+   end
+   local
+      structure CLocKind = gs_0
+      structure Int = gs_3
+      structure List = gs_2
+      signature STAGED_ALLOCATION = gs_1
+      ../staged-alloc/conventions/sparc-c-fn.sml
+   in
+      functor gs_4 = SparcCConventionFn
+   end
+   local
+      structure CLocKind = gs_0
+      structure Int = gs_3
+      structure List = gs_2
+      signature STAGED_ALLOCATION = gs_1
+      ../staged-alloc/conventions/x86-c-fn.sml
+   in
+      functor gs_5 = X86CConventionFn
+   end
+   local
+      structure CLocKind = gs_0
+      structure Int = gs_3
+      structure List = gs_2
+      signature STAGED_ALLOCATION = gs_1
+      ../staged-alloc/conventions/x86-64-c-fn.sml
+   in
+      functor gs_6 = X86_64CConventionFn
+   end
+   local
+      open l28
+   in
+      structure gs_7 = IntBinaryMap
+   end
+   local
+      structure Int = gs_3
+      structure IntBinaryMap = gs_7
+      structure List = gs_2
+      signature STAGED_ALLOCATION = gs_1
+      ../staged-alloc/allocator/staged-allocation-fn.sml
+   in
+      functor gs_8 = StagedAllocationFn
+   end
+in
+   structure CLocKind = gs_0
+   signature STAGED_ALLOCATION = gs_1
+   functor SparcCConventionFn = gs_4
+   functor StagedAllocationFn = gs_8
+   functor X86CConventionFn = gs_5
+   functor X86_64CConventionFn = gs_6
+end
+end
+
+end
diff --git a/mlb/Visual.mlb b/mlb/Visual.mlb
new file mode 100644
index 0000000..7245fd9
--- /dev/null
+++ b/mlb/Visual.mlb
@@ -0,0 +1,252 @@
+
+ann
+  "nonexhaustiveMatch warn" "redundantMatch warn"
+  "sequenceNonUnit ignore"
+  "warnUnused false" "forceUsed"
+in
+
+local
+  basis l23 =
+    bas
+      (* $/basis.cm ====> *) $(SML_LIB)/basis/basis.mlb $(SML_LIB)/basis/unsafe.mlb
+    end
+  basis l5 =
+    bas
+      (* $Control.cm(=(proxyLib.cm):.)/Control.cm =??=> *) Control.mlb
+    end
+  basis l19 =
+    bas
+      (* $Lib.cm(=(proxyLib.cm):.)/Lib.cm =??=> *) Lib.mlb
+    end
+  basis l12 =
+    bas
+      (* $Graphs.cm(=(proxyLib.cm):.)/Graphs.cm =??=> *) Graphs.mlb
+    end
+  basis l66 =
+    bas
+      (* $MLRISC.cm(=(proxyLib.cm):.)/MLRISC.cm =??=> *) MLRISC.mlb
+    end
+in
+local
+   $(SML_LIB)/basis/pervasive.mlb
+   local
+      open l5
+   in
+      signature gs_0 = MLRISC_CONTROL
+      structure gs_1 = MLRiscControl
+   end
+   local
+      open l12
+   in
+      signature gs_2 = ISOMORPHIC_GRAPH_VIEW
+      structure gs_3 = IsomorphicGraphView
+   end
+   local
+      open l12
+   in
+      structure gs_4 = Graph
+   end
+   local
+      open l19
+   in
+      structure gs_5 = Annotations
+   end
+   local
+      open l23
+   in
+      structure gs_6 = Int
+   end
+   local
+      structure Annotations = gs_5
+      structure Graph = gs_4
+      signature ISOMORPHIC_GRAPH_VIEW = gs_2
+      structure Int = gs_6
+      structure IsomorphicGraphView = gs_3
+      ../visualization/graphLayout.sml
+   in
+      structure gs_7 = GraphLayout
+   end
+   local
+      structure GraphLayout = gs_7
+      ../visualization/graphDisplay.sig
+   in
+      signature gs_8 = GRAPH_DISPLAY
+   end
+   local
+      open l23
+   in
+      structure gs_9 = String
+   end
+   local
+      open l23
+   in
+      structure gs_10 = List
+   end
+   local
+      signature GRAPH_DISPLAY = gs_8
+      structure Graph = gs_4
+      structure GraphLayout = gs_7
+      structure Int = gs_6
+      structure List = gs_10
+      structure String = gs_9
+      ../visualization/daVinci.sml
+   in
+      structure gs_11 = daVinci
+   end
+   local
+      signature GRAPH_DISPLAY = gs_8
+      structure Graph = gs_4
+      structure GraphLayout = gs_7
+      structure Int = gs_6
+      structure String = gs_9
+      ../visualization/vcg.sml
+   in
+      structure gs_12 = VCG
+   end
+   local
+      signature GRAPH_DISPLAY = gs_8
+      structure Graph = gs_4
+      structure GraphLayout = gs_7
+      structure Int = gs_6
+      structure String = gs_9
+      ../visualization/dot.sml
+   in
+      structure gs_13 = Dot
+   end
+   local
+      structure Dot = gs_13
+      signature GRAPH_DISPLAY = gs_8
+      signature MLRISC_CONTROL = gs_0
+      structure MLRiscControl = gs_1
+      structure VCG = gs_12
+      structure daVinci = gs_11
+      ../visualization/allDisplays.sml
+   in
+      structure gs_14 = AllDisplays
+   end
+   local
+      open l23
+   in
+      structure gs_15 = TextIO
+   end
+   local
+      open l23
+   in
+      structure gs_16 = OS
+   end
+   local
+      structure GraphLayout = gs_7
+      ../visualization/graphViewer.sig
+   in
+      signature gs_17 = GRAPH_VIEWER
+   end
+   local
+      signature GRAPH_DISPLAY = gs_8
+      signature GRAPH_VIEWER = gs_17
+      structure Graph = gs_4
+      structure GraphLayout = gs_7
+      structure Int = gs_6
+      signature MLRISC_CONTROL = gs_0
+      structure MLRiscControl = gs_1
+      structure OS = gs_16
+      structure TextIO = gs_15
+      ../visualization/graphViewer.sml
+   in
+      functor gs_18 = GraphViewer
+   end
+   local
+      open l66
+   in
+      structure gs_19 = Label
+   end
+   local
+      open l23
+   in
+      structure gs_20 = Array
+   end
+   local
+      open l23
+   in
+      structure gs_21 = Real
+   end
+   local
+      open l23
+   in
+      structure gs_22 = Math
+   end
+   local
+      open l66
+   in
+      signature gs_23 = INSTRUCTION_EMITTER
+   end
+   local
+      open l66
+   in
+      signature gs_24 = CONTROL_FLOW_GRAPH
+   end
+   local
+      open l19
+   in
+      structure gs_25 = StringOutStream
+   end
+   local
+      open l66
+   in
+      signature gs_26 = ASM_STREAM
+      structure gs_27 = AsmStream
+   end
+   local
+      open l66
+   in
+      signature gs_28 = INSTRUCTIONS
+   end
+   local
+      signature ASM_STREAM = gs_26
+      structure Annotations = gs_5
+      structure AsmStream = gs_27
+      signature INSTRUCTIONS = gs_28
+      signature INSTRUCTION_EMITTER = gs_23
+      structure String = gs_9
+      structure StringOutStream = gs_25
+      ../visualization/mlrisc-format-insn.sml
+   in
+      signature gs_29 = FORMAT_INSTRUCTION
+      functor gs_30 = FormatInstruction
+   end
+   local
+      structure Annotations = gs_5
+      structure Array = gs_20
+      signature CONTROL_FLOW_GRAPH = gs_24
+      signature FORMAT_INSTRUCTION = gs_29
+      functor FormatInstruction = gs_30
+      signature GRAPH_VIEWER = gs_17
+      structure Graph = gs_4
+      structure GraphLayout = gs_7
+      signature INSTRUCTION_EMITTER = gs_23
+      structure Int = gs_6
+      structure Label = gs_19
+      structure List = gs_10
+      signature MLRISC_CONTROL = gs_0
+      structure MLRiscControl = gs_1
+      structure Math = gs_22
+      structure Real = gs_21
+      structure String = gs_9
+      ../visualization/cfgViewer.sml
+   in
+      functor gs_31 = CFGViewer
+   end
+in
+   structure AllDisplays = gs_14
+   functor CFGViewer = gs_31
+   structure Dot = gs_13
+   functor FormatInstruction = gs_30
+   signature GRAPH_DISPLAY = gs_8
+   signature GRAPH_VIEWER = gs_17
+   structure GraphLayout = gs_7
+   functor GraphViewer = gs_18
+   structure VCG = gs_12
+   structure daVinci = gs_11
+end
+end
+
+end
diff --git a/mlrisc-lib.mlb b/mlrisc-lib.mlb
new file mode 100644
index 0000000..3545999
--- /dev/null
+++ b/mlrisc-lib.mlb
@@ -0,0 +1,24 @@
+(* DO NOT USE.  Only suitable for type-checking purposes. *)
+local
+mlb/ALPHA.mlb
+mlb/AMD64.mlb
+mlb/AMD64-Peephole.mlb
+mlb/CCall.mlb
+mlb/CCall-sparc.mlb
+mlb/CCall-x86-64.mlb
+mlb/CCall-x86.mlb
+mlb/Control.mlb
+mlb/Graphs.mlb
+mlb/HPPA.mlb
+mlb/IA32.mlb
+mlb/IA32-Peephole.mlb
+mlb/Lib.mlb
+mlb/MLRISC.mlb
+mlb/MLTREE.mlb
+mlb/Peephole.mlb
+mlb/PPC.mlb
+mlb/RA.mlb
+mlb/SPARC.mlb
+mlb/StagedAlloc.mlb
+mlb/Visual.mlb
+in end
diff --git a/mltree/instr-gen.sig b/mltree/instr-gen.sig
index a46af29..c04db90 100644
--- a/mltree/instr-gen.sig
+++ b/mltree/instr-gen.sig
@@ -8,8 +8,29 @@ sig
    structure S   : INSTRUCTION_STREAM
    structure CFG : CONTROL_FLOW_GRAPH 
 
-   sharing I.C = C 
-   sharing CFG.P = S.P
+   (* sharing I.C = C *)
+   (* sharing CFG.P = S.P *)
+   where type P.Client.pseudo_op = S.P.Client.pseudo_op
+     and type P.T.Basis.cond = S.P.T.Basis.cond
+     and type P.T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+     and type P.T.Basis.ext = S.P.T.Basis.ext
+     and type P.T.Basis.fcond = S.P.T.Basis.fcond
+     and type P.T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+     and type P.T.Constant.const = S.P.T.Constant.const
+     and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+     and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+     and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+     and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+     and type P.T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+     and type P.T.Region.region = S.P.T.Region.region
+     and type P.T.ccexp = S.P.T.ccexp
+     and type P.T.fexp = S.P.T.fexp
+     (* and type P.T.labexp = S.P.T.labexp *)
+     and type P.T.mlrisc = S.P.T.mlrisc
+     and type P.T.oper = S.P.T.oper
+     and type P.T.rep = S.P.T.rep
+     and type P.T.rexp = S.P.T.rexp
+     and type P.T.stm = S.P.T.stm
 
    (* 
     * This function creates an instruction stream, which can be 
diff --git a/mltree/instr-gen.sml b/mltree/instr-gen.sml
index 4b5d6cd..d31db49 100644
--- a/mltree/instr-gen.sml
+++ b/mltree/instr-gen.sml
@@ -4,9 +4,33 @@
 functor InstrGen
    (structure I      : INSTRUCTIONS
     structure Stream : INSTRUCTION_STREAM
-    structure CFG    : CONTROL_FLOW_GRAPH
-    			where I = I
-			  and P = Stream.P
+    structure CFG    : CONTROL_FLOW_GRAPH (* where I = I and P = Stream.P *)
+                       where type I.addressing_mode = I.addressing_mode
+                         and type I.ea = I.ea
+                         and type I.instr = I.instr
+                         and type I.instruction = I.instruction
+                         and type I.operand = I.operand
+                       where type P.Client.pseudo_op = Stream.P.Client.pseudo_op
+                         and type P.T.Basis.cond = Stream.P.T.Basis.cond
+                         and type P.T.Basis.div_rounding_mode = Stream.P.T.Basis.div_rounding_mode
+                         and type P.T.Basis.ext = Stream.P.T.Basis.ext
+                         and type P.T.Basis.fcond = Stream.P.T.Basis.fcond
+                         and type P.T.Basis.rounding_mode = Stream.P.T.Basis.rounding_mode
+                         and type P.T.Constant.const = Stream.P.T.Constant.const
+                         and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Stream.P.T.Extension.ccx
+                         and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Stream.P.T.Extension.fx
+                         and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Stream.P.T.Extension.rx
+                         and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Stream.P.T.Extension.sx
+                         and type P.T.I.div_rounding_mode = Stream.P.T.I.div_rounding_mode
+                         and type P.T.Region.region = Stream.P.T.Region.region
+                         and type P.T.ccexp = Stream.P.T.ccexp
+                         and type P.T.fexp = Stream.P.T.fexp
+                         (* and type P.T.labexp = Stream.P.T.labexp *)
+                         and type P.T.mlrisc = Stream.P.T.mlrisc
+                         and type P.T.oper = Stream.P.T.oper
+                         and type P.T.rep = Stream.P.T.rep
+                         and type P.T.rexp = Stream.P.T.rexp
+                         and type P.T.stm = Stream.P.T.stm
    ) : INSTR_GEN =
 struct
    structure C   = I.C
diff --git a/mltree/mltree-check-ty.sml b/mltree/mltree-check-ty.sml
index 7583736..b806191 100644
--- a/mltree/mltree-check-ty.sml
+++ b/mltree/mltree-check-ty.sml
@@ -101,7 +101,13 @@ functor MLTreeCheckTy
 
    and checkCCexpB cce = (case cce
           of T.NOT cce => checkCCexpB cce
-	   | ( T.AND (cce1, cce2) | T.OR (cce1, cce2) | T.XOR (cce1, cce2) | T.EQV (cce1, cce2) ) =>
+	   | ( T.AND (cce1, cce2) ) =>
+	     checkCCexpB cce1 andalso checkCCexpB cce2
+	   | ( T.OR (cce1, cce2) ) =>
+	     checkCCexpB cce1 andalso checkCCexpB cce2
+	   | ( T.XOR (cce1, cce2) ) =>
+	     checkCCexpB cce1 andalso checkCCexpB cce2
+	   | ( T.EQV (cce1, cce2) ) =>
 	     checkCCexpB cce1 andalso checkCCexpB cce2
 	   | T.CMP (ty, _, e1, e2) => ty = checkRexp e1 andalso ty = checkRexp e2
 	   | T.FCMP (fty, _, e1, e2) => fty = checkFexp e1 andalso fty = checkFexp e2
diff --git a/mltree/mltree-gen.sig b/mltree/mltree-gen.sig
index f2d1937..757c6d1 100644
--- a/mltree/mltree-gen.sig
+++ b/mltree/mltree-gen.sig
@@ -9,8 +9,27 @@ signature MLTREEGEN =
 sig
 
    structure T : MLTREE
-   structure Size : MLTREE_SIZE
-   	where T = T
+   structure Size : MLTREE_SIZE (* where T = T *)
+                    where type T.Basis.cond = T.Basis.cond
+                      and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                      and type T.Basis.ext = T.Basis.ext
+                      and type T.Basis.fcond = T.Basis.fcond
+                      and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                      and type T.Constant.const = T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                      and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                      and type T.Region.region = T.Region.region
+                      and type T.ccexp = T.ccexp
+                      and type T.fexp = T.fexp
+                      (* and type T.labexp = T.labexp *)
+                      and type T.mlrisc = T.mlrisc
+                      and type T.oper = T.oper
+                      and type T.rep = T.rep
+                      and type T.rexp = T.rexp
+                      and type T.stm = T.stm
 
    val condOf : T.ccexp -> T.Basis.cond
    val fcondOf : T.ccexp -> T.Basis.fcond
diff --git a/mltree/mltree-mult.sig b/mltree/mltree-mult.sig
index 827c051..a69f5a6 100644
--- a/mltree/mltree-mult.sig
+++ b/mltree/mltree-mult.sig
@@ -8,7 +8,7 @@ sig
 
    structure T : MLTREE
    structure C : CELLS 
-   structure I : INSTRUCTIONS where C=C
+   structure I : INSTRUCTIONS (* where C = C *)
 
    exception TooComplex
 
diff --git a/mltree/mltree-mult.sml b/mltree/mltree-mult.sml
index 41c26eb..e0e0609 100644
--- a/mltree/mltree-mult.sml
+++ b/mltree/mltree-mult.sml
@@ -8,7 +8,16 @@ functor MLTreeMult
   (structure I : INSTRUCTIONS
    structure T : MLTREE
 
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    val intTy : int (* width of integer type *)
 
    type argi = {r:CB.cell, i:int, d:CB.cell}
@@ -20,8 +29,8 @@ functor MLTreeMult
    val slli  : argi -> I.instruction list
    val srli  : argi -> I.instruction list
    val srai  : argi -> I.instruction list
-  )
-  (val trapping : bool (* trap on overflow? *)
+
+   val trapping : bool (* trap on overflow? *)
    val multCost : int ref  (* cost of multiplication *)
 
        (* basic ops; these have to implemented by the architecture *)
@@ -37,8 +46,8 @@ functor MLTreeMult
    val sh1addv  : (arg -> I.instruction list) option (* a*2 + b *)
    val sh2addv  : (arg -> I.instruction list) option (* a*4 + b *)  
    val sh3addv  : (arg -> I.instruction list) option (* a*8 + b *)
-  )  
-  (val signed   : bool (* signed? *)
+
+   val signed   : bool (* signed? *)
   ) : MLTREE_MULT_DIV =
 struct
    structure T = T 
diff --git a/mltree/mltree-simplify.in b/mltree/mltree-simplify.in
index 0e8de12..63ebbc2 100644
--- a/mltree/mltree-simplify.in
+++ b/mltree/mltree-simplify.in
@@ -14,8 +14,27 @@ in
 
 functor MLTreeSimplifier
   (structure T    : MLTREE
-   structure Size : MLTREE_SIZE
-      where T = T
+   structure Size : MLTREE_SIZE (* where T = T *)
+                    where type T.Basis.cond = T.Basis.cond
+                      and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                      and type T.Basis.ext = T.Basis.ext
+                      and type T.Basis.fcond = T.Basis.fcond
+                      and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                      and type T.Constant.const = T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                      and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                      and type T.Region.region = T.Region.region
+                      and type T.ccexp = T.ccexp
+                      and type T.fexp = T.fexp
+                      (* and type T.labexp = T.labexp *)
+                      and type T.mlrisc = T.mlrisc
+                      and type T.oper = T.oper
+                      and type T.rep = T.rep
+                      and type T.rexp = T.rexp
+                      and type T.stm = T.stm
    (* Extension *)
    val sext : T.rewriter -> T.sext -> T.sext
    val rext : T.rewriter -> T.rext -> T.rext
diff --git a/mltree/mltree-simplify.sml b/mltree/mltree-simplify.sml
index 75e2867..5a15b04 100644
--- a/mltree/mltree-simplify.sml
+++ b/mltree/mltree-simplify.sml
@@ -9,7 +9,27 @@ functor MLTreeSimplifier(
                          structure T : MLTREE
 
 (*#line 17.4 "mltree-simplify.in"*)
-                         structure Size : MLTREE_SIZE where T=T
+                         structure Size : MLTREE_SIZE (* where T=T *)
+                                          where type T.Basis.cond = T.Basis.cond
+                                            and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                                            and type T.Basis.ext = T.Basis.ext
+                                            and type T.Basis.fcond = T.Basis.fcond
+                                            and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                                            and type T.Constant.const = T.Constant.const
+                                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                                            and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                                            and type T.Region.region = T.Region.region
+                                            and type T.ccexp = T.ccexp
+                                            and type T.fexp = T.fexp
+                                            (* and type T.labexp = T.labexp *)
+                                            and type T.mlrisc = T.mlrisc
+                                            and type T.oper = T.oper
+                                            and type T.rep = T.rep
+                                            and type T.rexp = T.rexp
+                                            and type T.stm = T.stm
 
 (*#line 20.4 "mltree-simplify.in"*)
                          val sext : T.rewriter -> T.sext -> T.sext
diff --git a/mltree/mltree-utils.sml b/mltree/mltree-utils.sml
index e6e01d6..4d9e333 100644
--- a/mltree/mltree-utils.sml
+++ b/mltree/mltree-utils.sml
@@ -518,9 +518,10 @@ struct
 
       and oper(T.OPER{name,...}) = name 
 
-      and parenRexp
-            (e as (T.REG _ | T.LI _ | T.$ _ | T.ARG _)) = 
-              rexp e
+      and parenRexp (e as T.REG _) = rexp e
+        | parenRexp (e as T.LI _) = rexp e
+        | parenRexp (e as T.$ _) = rexp e
+        | parenRexp (e as T.ARG _) = rexp e
         | parenRexp e = "("^rexp e^")"
 
       and slices sc = listify' (fn (from,to) => i2s from^".."^i2s to) sc
diff --git a/mltree/mltree.sig b/mltree/mltree.sig
index 90f25e9..8bba294 100644
--- a/mltree/mltree.sig
+++ b/mltree/mltree.sig
@@ -30,6 +30,10 @@ signature MLTREE = sig
    * extension type.  Unfortunately, this has to be made polymorphic to make
    * it possible for recursive type definitions to work.
    *)
+  type controlflow = Label.label list (* control flow info *)
+  type ctrl   = var                   (* control dependence info *)
+  type ctrls  = ctrl list
+
   datatype stm =
       (* assignment *)
       MV      of ty * dst * rexp
@@ -70,7 +74,7 @@ signature MLTREE = sig
     | DEFINE of Label.label   (* define local label *)
 
     | ANNOTATION of stm * an
-    | EXT of sext  (* extension *)
+    | EXT of (stm, rexp, fexp, ccexp) Extension.sx  (* extension *)
 
       (* synthetic instructions to indicated that the regs are live or
        * killed at this program point. The spilled list must always
@@ -152,7 +156,7 @@ signature MLTREE = sig
 
     | LET of stm * rexp
 
-    | REXT of ty * rext
+    | REXT of ty * (stm, rexp, fexp, ccexp) Extension.rx
 
     | MARK of rexp * an
 
@@ -187,7 +191,7 @@ signature MLTREE = sig
 
     | FPRED of fexp * ctrl
 
-    | FEXT of fty * fext
+    | FEXT of fty * (stm, rexp, fexp, ccexp) Extension.fx
 
     | FMARK of fexp * an
 
@@ -204,17 +208,14 @@ signature MLTREE = sig
     | CMP    of ty * Basis.cond * rexp * rexp
     | FCMP   of fty * Basis.fcond * fexp * fexp
     | CCMARK of ccexp * an
-    | CCEXT  of ty * ccext
+    | CCEXT  of ty * (stm, rexp, fexp, ccexp) Extension.ccx
 
   and mlrisc =
       CCR of ccexp
     | GPR of rexp
     | FPR of fexp
 
-  withtype controlflow = Label.label list (* control flow info *)
-       and ctrl   = var                   (* control dependence info *)
-       and ctrls  = ctrl list
-       and sext   = (stm, rexp, fexp, ccexp) Extension.sx
+  type sext   = (stm, rexp, fexp, ccexp) Extension.sx
        and rext   = (stm, rexp, fexp, ccexp) Extension.rx
        and fext   = (stm, rexp, fexp, ccexp) Extension.fx
        and ccext  = (stm, rexp, fexp, ccexp) Extension.ccx
diff --git a/mltree/mltree.sml b/mltree/mltree.sml
index 7f5f1b1..b250ce2 100644
--- a/mltree/mltree.sml
+++ b/mltree/mltree.sml
@@ -32,6 +32,10 @@ struct
    * extension type.  Unfortunately, this has to be made polymorphic to make
    * it possible for recursive type definitions to work.
    *)
+  type controlflow = Label.label list (* control flow info *)
+  type ctrl   = var                   (* control dependence info *)
+  type ctrls  = ctrl list
+
   datatype stm =
       (* assignment *)
       MV      of ty * dst * rexp
@@ -199,10 +203,7 @@ struct
     | GPR of rexp
     | FPR of fexp
 
-  withtype controlflow = Label.label list (* control flow info *)
-       and ctrl   = var                   (* control dependence info *)
-       and ctrls  = ctrl list
-       and sext   = (stm, rexp, fexp, ccexp) Extension.sx
+  withtype sext   = (stm, rexp, fexp, ccexp) Extension.sx
        and rext   = (stm, rexp, fexp, ccexp) Extension.rx
        and fext   = (stm, rexp, fexp, ccexp) Extension.fx
        and ccext  = (stm, rexp, fexp, ccexp) Extension.ccx
diff --git a/mltree/mltreecomp.sig b/mltree/mltreecomp.sig
index 79ceab5..f6b72e1 100644
--- a/mltree/mltreecomp.sig
+++ b/mltree/mltreecomp.sig
@@ -9,11 +9,56 @@
 signature MLTREE_EXTENSION_COMP =
 sig
    structure T : MLTREE
-   structure TS : MLTREE_STREAM where T = T
+   structure TS : MLTREE_STREAM (* where T = T *)
+                  where type T.Basis.cond = T.Basis.cond
+                    and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                    and type T.Basis.ext = T.Basis.ext
+                    and type T.Basis.fcond = T.Basis.fcond
+                    and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                    and type T.Constant.const = T.Constant.const
+                    and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                    and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                    and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                    and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                    and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                    and type T.Region.region = T.Region.region
+                    and type T.ccexp = T.ccexp
+                    and type T.fexp = T.fexp
+                    (* and type T.labexp = T.labexp *)
+                    and type T.mlrisc = T.mlrisc
+                    and type T.oper = T.oper
+                    and type T.rep = T.rep
+                    and type T.rexp = T.rexp
+                    and type T.stm = T.stm
    structure I : INSTRUCTIONS
-   structure CFG : CONTROL_FLOW_GRAPH
-		where I = I
-	          and P = TS.S.P
+   structure CFG : CONTROL_FLOW_GRAPH (* where I = I and P = TS.S.P *)
+                   where type I.addressing_mode = I.addressing_mode
+                     and type I.ea = I.ea
+                     and type I.instr = I.instr
+                     and type I.instruction = I.instruction
+                     and type I.operand = I.operand
+                   where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                     and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                     and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                     and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                     and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                     and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                     and type P.T.Constant.const = TS.S.P.T.Constant.const
+                     and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                     and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                     and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                     and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                     and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                     and type P.T.Region.region = TS.S.P.T.Region.region
+                     and type P.T.ccexp = TS.S.P.T.ccexp
+                     and type P.T.fexp = TS.S.P.T.fexp
+	             (* and type P.T.labexp = TS.S.P.T.labexp *)
+                     and type P.T.mlrisc = TS.S.P.T.mlrisc
+                     and type P.T.oper = TS.S.P.T.oper
+                     and type P.T.rep = TS.S.P.T.rep
+                     and type P.T.rexp = TS.S.P.T.rexp
+                     and type P.T.stm = TS.S.P.T.stm
+
    (* 
     * The reducer is given to the client during the compilation of
     * the user extensions.
@@ -34,11 +79,54 @@ signature MLTREECOMP =
 sig
    structure TS : MLTREE_STREAM
    structure I : INSTRUCTIONS 
-   structure CFG : CONTROL_FLOW_GRAPH 
-      		where I = I
-		  and P = TS.S.P
-   structure Gen : MLTREEGEN 
-   		where T = TS.T
+   structure CFG : CONTROL_FLOW_GRAPH (* where I = I and P = TS.S.P *)
+                   where type I.addressing_mode = I.addressing_mode
+                     and type I.ea = I.ea
+                     and type I.instr = I.instr
+                     and type I.instruction = I.instruction
+                     and type I.operand = I.operand
+                   where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                     and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                     and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                     and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                     and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                     and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                     and type P.T.Constant.const = TS.S.P.T.Constant.const
+                     and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                     and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                     and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                     and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                     and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                     and type P.T.Region.region = TS.S.P.T.Region.region
+                     and type P.T.ccexp = TS.S.P.T.ccexp
+                     and type P.T.fexp = TS.S.P.T.fexp
+                     (* and type P.T.labexp = TS.S.P.T.labexp *)
+                     and type P.T.mlrisc = TS.S.P.T.mlrisc
+                     and type P.T.oper = TS.S.P.T.oper
+                     and type P.T.rep = TS.S.P.T.rep
+                     and type P.T.rexp = TS.S.P.T.rexp
+                     and type P.T.stm = TS.S.P.T.stm
+   structure Gen : MLTREEGEN (* where T = TS.T *)
+                   where type T.Basis.cond = TS.T.Basis.cond
+                     and type T.Basis.div_rounding_mode = TS.T.Basis.div_rounding_mode
+                     and type T.Basis.ext = TS.T.Basis.ext
+                     and type T.Basis.fcond = TS.T.Basis.fcond
+                     and type T.Basis.rounding_mode = TS.T.Basis.rounding_mode
+                     and type T.Constant.const = TS.T.Constant.const
+                     and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) TS.T.Extension.ccx
+                     and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) TS.T.Extension.fx
+                     and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) TS.T.Extension.rx
+                     and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) TS.T.Extension.sx
+                     and type T.I.div_rounding_mode = TS.T.I.div_rounding_mode
+                     and type T.Region.region = TS.T.Region.region
+                     and type T.ccexp = TS.T.ccexp
+                     and type T.fexp = TS.T.fexp
+                     (* and type T.labexp = TS.T.labexp *)
+                     and type T.mlrisc = TS.T.mlrisc
+                     and type T.oper = TS.T.oper
+                     and type T.rep = TS.T.rep
+                     and type T.rexp = TS.T.rexp
+                     and type T.stm = TS.T.stm
 
    type instrStream = (I.instruction, I.C.cellset, CFG.cfg) TS.stream  
    type mltreeStream = (TS.T.stm, TS.T.mlrisc list, CFG.cfg) TS.stream 
diff --git a/omit-frameptr/omit-frame-pointer.sig b/omit-frameptr/omit-frame-pointer.sig
index dc0fb5b..e4ec806 100644
--- a/omit-frameptr/omit-frame-pointer.sig
+++ b/omit-frameptr/omit-frame-pointer.sig
@@ -2,7 +2,12 @@
 
 signature OMIT_FRAME_POINTER = sig
   structure I : INSTRUCTIONS
-  structure CFG : CONTROL_FLOW_GRAPH where I = I
+  structure CFG : CONTROL_FLOW_GRAPH (* where I = I *)
+                  where type I.addressing_mode = I.addressing_mode
+                    and type I.ea = I.ea
+                    and type I.instr = I.instr
+                    and type I.instruction = I.instruction
+                    and type I.operand = I.operand
   
   (* idelta is the intial displacement between the fp and sp. *)
   val omitframeptr : {vfp:CellsBasis.cell, idelta:Int32.int option, cfg:CFG.cfg} -> unit
diff --git a/ppc/backpatch/ppcDelaySlots.sml b/ppc/backpatch/ppcDelaySlots.sml
index 69823c1..a01898a 100644
--- a/ppc/backpatch/ppcDelaySlots.sml
+++ b/ppc/backpatch/ppcDelaySlots.sml
@@ -5,8 +5,12 @@
 
 
 functor PPCDelaySlots(structure I : PPCINSTR
-                      structure P : INSN_PROPERTIES
-                         where I = I
+                      structure P : INSN_PROPERTIES (* where I = I *)
+                                    where type I.addressing_mode = I.addressing_mode
+                                      and type I.ea = I.ea
+                                      and type I.instr = I.instr
+                                      and type I.instruction = I.instruction
+                                      and type I.operand = I.operand
                      ) : DELAY_SLOT_PROPERTIES =
 struct
    structure I = I
diff --git a/ppc/backpatch/ppcJumps.sml b/ppc/backpatch/ppcJumps.sml
index e12d7d2..7411f04 100644
--- a/ppc/backpatch/ppcJumps.sml
+++ b/ppc/backpatch/ppcJumps.sml
@@ -1,7 +1,70 @@
 functor PPCJumps 
   (structure Instr: PPCINSTR
-   structure Shuffle : PPCSHUFFLE where I = Instr
-   structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+   structure Shuffle : PPCSHUFFLE (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         and type I.arith = Instr.arith
+                         and type I.arithi = Instr.arithi
+                         and type I.bit = Instr.bit
+                         and type I.bo = Instr.bo
+                         and type I.ccarith = Instr.ccarith
+                         and type I.cmp = Instr.cmp
+                         and type I.ea = Instr.ea
+                         and type I.farith = Instr.farith
+                         and type I.farith3 = Instr.farith3
+                         and type I.fcmp = Instr.fcmp
+                         and type I.fload = Instr.fload
+                         and type I.fstore = Instr.fstore
+                         and type I.funary = Instr.funary
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.load = Instr.load
+                         and type I.operand = Instr.operand
+                         and type I.rotate = Instr.rotate
+                         and type I.rotatei = Instr.rotatei
+                         and type I.spr = Instr.spr
+                         and type I.store = Instr.store
+                         and type I.unary = Instr.unary
+                         and type I.xerbit = Instr.xerbit
+   structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
   ) : SDI_JUMPS = 
 struct
   structure I = Instr
@@ -68,22 +131,35 @@ struct
 	  | operand _ = error "sdiSize:operand"
       in
 	case instr
-	of I.L{ld=(I.LBZ | I.LHZ | I.LHA | I.LWZ),d,...} => 
-	      operand(d, signed16, 4, 8)
+	of I.L{ld=I.LBZ,d,...} => operand(d, signed16, 4, 8)
+	 | I.L{ld=I.LHZ,d,...} => operand(d, signed16, 4, 8)
+	 | I.L{ld=I.LHA,d,...} => operand(d, signed16, 4, 8)
+	 | I.L{ld=I.LWZ,d,...} => operand(d, signed16, 4, 8)
 	 | I.L{d,...} => operand(d, signed12, 4, 8)
-	 | I.LF{ld=(I.LFS | I.LFD), d, ...} => operand(d, signed16, 4, 8)
+	 | I.LF{ld=I.LFS, d, ...} => operand(d, signed16, 4, 8)
+	 | I.LF{ld=I.LFD, d, ...} => operand(d, signed16, 4, 8)
 	 | I.LF{d, ...} => operand(d, signed12, 4, 8)
-	 | I.ST{st=(I.STB | I.STH | I.STW), d, ...} => operand(d, signed16, 4, 8)
+	 | I.ST{st=I.STB, d, ...} => operand(d, signed16, 4, 8)
+	 | I.ST{st=I.STH, d, ...} => operand(d, signed16, 4, 8)
+	 | I.ST{st=I.STW, d, ...} => operand(d, signed16, 4, 8)
 	 | I.ST{d, ...} => operand(d, signed12, 4, 8)
-	 | I.STF{st=(I.STFS | I.STFD), d, ...} => operand(d, signed16, 4, 8)
+	 | I.STF{st=I.STFS, d, ...} => operand(d, signed16, 4, 8)
+	 | I.STF{st=I.STFD, d, ...} => operand(d, signed16, 4, 8)
 	 | I.STF{d, ...} => operand(d, signed12, 4, 8)
 	 | I.ARITHI{oper, im, ...} => 
 	   (case oper
 	    of I.ADDI => operand(im, signed16, 4, 8)
-	     | (I.ADDIS | I.SUBFIC | I.MULLI) => operand(im, signed16, 4, 12)
-	     | (I.ANDI_Rc | I.ANDIS_Rc | I.ORI | I.ORIS | I.XORI | I.XORIS) => 
-		   operand(im, unsigned16, 4, 12)
-	     | (I.SRAWI | I.SRADI) => operand(im, unsigned5, 4, 12)
+	     | I.ADDIS => operand(im, signed16, 4, 12)
+	     | I.SUBFIC => operand(im, signed16, 4, 12)
+	     | I.MULLI => operand(im, signed16, 4, 12)
+	     | I.ANDI_Rc => operand(im, unsigned16, 4, 12)
+	     | I.ANDIS_Rc => operand(im, unsigned16, 4, 12)
+	     | I.ORI => operand(im, unsigned16, 4, 12)
+	     | I.ORIS => operand(im, unsigned16, 4, 12)
+	     | I.XORI => operand(im, unsigned16, 4, 12)
+	     | I.XORIS => operand(im, unsigned16, 4, 12)
+	     | I.SRAWI => operand(im, unsigned5, 4, 12)
+	     | I.SRADI => operand(im, unsigned5, 4, 12)
 	    (*esac*))
 	 | I.ROTATEI{sh, ...} => error "sdiSize:ROTATE"
 	 | I.COMPARE{cmp, rb, ...} => 
diff --git a/ppc/c-calls/ppc-macosx.sml b/ppc/c-calls/ppc-macosx.sml
index 24fe75d..26d1ae9 100644
--- a/ppc/c-calls/ppc-macosx.sml
+++ b/ppc/c-calls/ppc-macosx.sml
@@ -277,7 +277,9 @@ functor PPCMacOSX_CCalls (
 		      assignFPR (tys, offset, availGPRs, availFPRs, layout)
 		  | CTy.C_long_double =>
 		      assignFPR (tys, offset, availGPRs, availFPRs, layout)
-		  | (CTy.C_unsigned isz | CTy.C_signed isz) =>
+		  | CTy.C_unsigned isz =>
+		      assignGPR([sizeOfInt isz], tys, offset, availGPRs, availFPRs, layout)
+		  | CTy.C_signed isz =>
 		      assignGPR([sizeOfInt isz], tys, offset, availGPRs, availFPRs, layout)
 		  | CTy.C_PTR =>
 		      assignGPR([sizeOfPtr], tys, offset, availGPRs, availFPRs, layout)
@@ -464,7 +466,8 @@ functor PPCMacOSX_CCalls (
 	  in
 	  (* check calling convention *)
 	    case conv
-	     of ("" | "ccall") => ()
+	     of ("") => ()
+	      | ("ccall") => ()
 	      | _ => error (concat [
 		    "unknown calling convention \"",
 		    String.toString conv, "\""
diff --git a/ppc/emit/ppcAsm.sml b/ppc/emit/ppcAsm.sml
index 1d241bb..13b3d1e 100644
--- a/ppc/emit/ppcAsm.sml
+++ b/ppc/emit/ppcAsm.sml
@@ -6,12 +6,92 @@
 
 
 functor PPCAsmEmitter(structure S : INSTRUCTION_STREAM
-                      structure Instr : PPCINSTR
-                         where T = S.P.T
-                      structure Shuffle : PPCSHUFFLE
-                         where I = Instr
-                      structure MLTreeEval : MLTREE_EVAL
-                         where T = Instr.T
+                      structure Instr : PPCINSTR (* where T = S.P.T *)
+                                        where type T.Basis.cond = S.P.T.Basis.cond
+                                          and type T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+                                          and type T.Basis.ext = S.P.T.Basis.ext
+                                          and type T.Basis.fcond = S.P.T.Basis.fcond
+                                          and type T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+                                          and type T.Constant.const = S.P.T.Constant.const
+                                          and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+                                          and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+                                          and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+                                          and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+                                          and type T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+                                          and type T.Region.region = S.P.T.Region.region
+                                          and type T.ccexp = S.P.T.ccexp
+                                          and type T.fexp = S.P.T.fexp
+                                          (* and type T.labexp = S.P.T.labexp *)
+                                          and type T.mlrisc = S.P.T.mlrisc
+                                          and type T.oper = S.P.T.oper
+                                          and type T.rep = S.P.T.rep
+                                          and type T.rexp = S.P.T.rexp
+                                          and type T.stm = S.P.T.stm
+                      structure Shuffle : PPCSHUFFLE (* where I = Instr *)
+                                          where type I.Constant.const = Instr.Constant.const
+                                            and type I.Region.region = Instr.Region.region
+                                            and type I.T.Basis.cond = Instr.T.Basis.cond
+                                            and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                            and type I.T.Basis.ext = Instr.T.Basis.ext
+                                            and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                            and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                            and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                            and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                            and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                            and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                            and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                            and type I.T.ccexp = Instr.T.ccexp
+                                            and type I.T.fexp = Instr.T.fexp
+                                            (* and type I.T.labexp = Instr.T.labexp *)
+                                            and type I.T.mlrisc = Instr.T.mlrisc
+                                            and type I.T.oper = Instr.T.oper
+                                            and type I.T.rep = Instr.T.rep
+                                            and type I.T.rexp = Instr.T.rexp
+                                            and type I.T.stm = Instr.T.stm
+                                            and type I.arith = Instr.arith
+                                            and type I.arithi = Instr.arithi
+                                            and type I.bit = Instr.bit
+                                            and type I.bo = Instr.bo
+                                            and type I.ccarith = Instr.ccarith
+                                            and type I.cmp = Instr.cmp
+                                            and type I.ea = Instr.ea
+                                            and type I.farith = Instr.farith
+                                            and type I.farith3 = Instr.farith3
+                                            and type I.fcmp = Instr.fcmp
+                                            and type I.fload = Instr.fload
+                                            and type I.fstore = Instr.fstore
+                                            and type I.funary = Instr.funary
+                                            and type I.instr = Instr.instr
+                                            and type I.instruction = Instr.instruction
+                                            and type I.load = Instr.load
+                                            and type I.operand = Instr.operand
+                                            and type I.rotate = Instr.rotate
+                                            and type I.rotatei = Instr.rotatei
+                                            and type I.spr = Instr.spr
+                                            and type I.store = Instr.store
+                                            and type I.unary = Instr.unary
+                                            and type I.xerbit = Instr.xerbit
+                      structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                             where type T.Basis.cond = Instr.T.Basis.cond
+                                               and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                               and type T.Basis.ext = Instr.T.Basis.ext
+                                               and type T.Basis.fcond = Instr.T.Basis.fcond
+                                               and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                               and type T.Constant.const = Instr.T.Constant.const
+                                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                               and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                               and type T.Region.region = Instr.T.Region.region
+                                               and type T.ccexp = Instr.T.ccexp
+                                               and type T.fexp = Instr.T.fexp
+                                               (* and type T.labexp = Instr.T.labexp *)
+                                               and type T.mlrisc = Instr.T.mlrisc
+                                               and type T.oper = Instr.T.oper
+                                               and type T.rep = Instr.T.rep
+                                               and type T.rexp = Instr.T.rexp
+                                               and type T.stm = Instr.T.stm
                      ) : INSTRUCTION_EMITTER =
 struct
    structure I  = Instr
diff --git a/ppc/emit/ppcMC.sml b/ppc/emit/ppcMC.sml
index fcd3e4a..776ea7d 100644
--- a/ppc/emit/ppcMC.sml
+++ b/ppc/emit/ppcMC.sml
@@ -6,7 +6,27 @@
 
 
 functor PPCMCEmitter(structure Instr : PPCINSTR
-                     structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+                     structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                            where type T.Basis.cond = Instr.T.Basis.cond
+                                              and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                              and type T.Basis.ext = Instr.T.Basis.ext
+                                              and type T.Basis.fcond = Instr.T.Basis.fcond
+                                              and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                              and type T.Constant.const = Instr.T.Constant.const
+                                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                              and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                              and type T.Region.region = Instr.T.Region.region
+                                              and type T.ccexp = Instr.T.ccexp
+                                              and type T.fexp = Instr.T.fexp
+                                              (* and type T.labexp = Instr.T.labexp *)
+                                              and type T.mlrisc = Instr.T.mlrisc
+                                              and type T.oper = Instr.T.oper
+                                              and type T.rep = Instr.T.rep
+                                              and type T.rexp = Instr.T.rexp
+                                              and type T.stm = Instr.T.stm
                      structure Stream : INSTRUCTION_STREAM 
                      structure CodeString : CODE_STRING
                     ) : INSTRUCTION_EMITTER =
@@ -47,6 +67,7 @@ struct
        (* note: fromLargeWord strips the high order bits! *)
        fun eByteW w =
        let val i = !loc
+           val w = W.toLargeWord w
        in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
    
        fun doNothing _ = ()
@@ -380,14 +401,24 @@ struct
        end
    and arith {oper, rt, ra, rb, OE, Rc} = 
        (case oper of
-         (I.ADD | I.SUBF | I.MULLW | I.MULLD | I.MULHW | I.MULHWU | I.DIVW | I.DIVD | I.DIVWU | I.DIVDU) => 
-            arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+         I.ADD => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.SUBF => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.MULLW => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.MULLD => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.MULHW => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.MULHWU => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.DIVW => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.DIVD => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.DIVWU => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
+       | I.DIVDU => arith' {oper=oper, rt=rt, ra=ra, rb=rb, OE=OE, Rc=Rc}
        | _ => arith' {oper=oper, rt=ra, ra=rt, rb=rb, OE=OE, Rc=Rc}
        )
    and arithi {oper, rt, ra, im} = 
        (case oper of
-         (I.ADDI | I.ADDIS | I.SUBFIC | I.MULLI) => arithi' {oper=oper, rt=rt, 
-            ra=ra, im=im}
+         I.ADDI => arithi' {oper=oper, rt=rt, ra=ra, im=im}
+       | I.ADDIS => arithi' {oper=oper, rt=rt, ra=ra, im=im}
+       | I.SUBFIC => arithi' {oper=oper, rt=rt, ra=ra, im=im}
+       | I.MULLI => arithi' {oper=oper, rt=rt, ra=ra, im=im}
        | I.SRAWI => srawi {rs=ra, ra=rt, sh=im}
        | I.SRADI => sradi {rs=ra, ra=rt, sh=im}
        | _ => arithi' {oper=oper, rt=ra, ra=rt, im=im}
@@ -462,8 +493,8 @@ struct
               val (opcd, xo) = emit_farith oper
           in 
              (case oper of
-               (I.FMUL | I.FMULS) => a_form {opcd=opcd, frt=ft, fra=fa, frb=0wx0, 
-                  frc=fb, xo=xo, rc=Rc}
+               I.FMUL => a_form {opcd=opcd, frt=ft, fra=fa, frb=0wx0, frc=fb, xo=xo, rc=Rc}
+             | I.FMULS => a_form {opcd=opcd, frt=ft, fra=fa, frb=0wx0, frc=fb, xo=xo, rc=Rc}
              | _ => a_form {opcd=opcd, frt=ft, fra=fa, frb=fb, frc=0wx0, xo=xo, 
                   rc=Rc}
              )
diff --git a/ppc/flowgraph/ppcDarwinPseudoOps.sml b/ppc/flowgraph/ppcDarwinPseudoOps.sml
index daf6933..533b845 100644
--- a/ppc/flowgraph/ppcDarwinPseudoOps.sml
+++ b/ppc/flowgraph/ppcDarwinPseudoOps.sml
@@ -7,7 +7,27 @@
 
 functor PPCDarwinPseudoOps (
     structure T : MLTREE
-    structure MLTreeEval : MLTREE_EVAL  where T = T
+    structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                           where type T.Basis.cond = T.Basis.cond
+                             and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                             and type T.Basis.ext = T.Basis.ext
+                             and type T.Basis.fcond = T.Basis.fcond
+                             and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                             and type T.Constant.const = T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                             and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                             and type T.Region.region = T.Region.region
+                             and type T.ccexp = T.ccexp
+                             and type T.fexp = T.fexp
+                             (* and type T.labexp = T.labexp *)
+                             and type T.mlrisc = T.mlrisc
+                             and type T.oper = T.oper
+                             and type T.rep = T.rep
+                             and type T.rexp = T.rexp
+                             and type T.stm = T.stm
   ) : PSEUDO_OPS_BASIS = struct
 
     structure T = T
diff --git a/ppc/flowgraph/ppcGasPseudoOps.sml b/ppc/flowgraph/ppcGasPseudoOps.sml
index e627bfa..267246d 100644
--- a/ppc/flowgraph/ppcGasPseudoOps.sml
+++ b/ppc/flowgraph/ppcGasPseudoOps.sml
@@ -1,6 +1,26 @@
 functor PPCGasPseudoOps 
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL  where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
     ) : PSEUDO_OPS_BASIS = 
 
 struct
diff --git a/ppc/instructions/ppcCompInstrExt.sml b/ppc/instructions/ppcCompInstrExt.sml
index b2354cd..d7b6562 100644
--- a/ppc/instructions/ppcCompInstrExt.sml
+++ b/ppc/instructions/ppcCompInstrExt.sml
@@ -9,11 +9,54 @@
 signature PPCCOMP_INSTR_EXT =
   sig
     structure I : PPCINSTR
-    structure TS : MLTREE_STREAM
-      where T = I.T
-    structure CFG : CONTROL_FLOW_GRAPH 
-      where I = I
-	and P = TS.S.P
+    structure TS : MLTREE_STREAM (* where T = I.T *)
+                   where type T.Basis.cond = I.T.Basis.cond
+                     and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                     and type T.Basis.ext = I.T.Basis.ext
+                     and type T.Basis.fcond = I.T.Basis.fcond
+                     and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                     and type T.Constant.const = I.T.Constant.const
+                     and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                     and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                     and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                     and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                     and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                     and type T.Region.region = I.T.Region.region
+                     and type T.ccexp = I.T.ccexp
+                     and type T.fexp = I.T.fexp
+                     (* and type T.labexp = I.T.labexp *)
+                     and type T.mlrisc = I.T.mlrisc
+                     and type T.oper = I.T.oper
+                     and type T.rep = I.T.rep
+                     and type T.rexp = I.T.rexp
+                     and type T.stm = I.T.stm
+    structure CFG : CONTROL_FLOW_GRAPH  (* where I = I and  and P = TS.S.P *)
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
+                    where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                      and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                      and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                      and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                      and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                      and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                      and type P.T.Constant.const = TS.S.P.T.Constant.const
+                      and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                      and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                      and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                      and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                      and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                      and type P.T.Region.region = TS.S.P.T.Region.region
+                      and type P.T.ccexp = TS.S.P.T.ccexp
+                      and type P.T.fexp = TS.S.P.T.fexp
+                      (* and type P.T.labexp = TS.S.P.T.labexp *)
+                      and type P.T.mlrisc = TS.S.P.T.mlrisc
+                      and type P.T.oper = TS.S.P.T.oper
+                      and type P.T.rep = TS.S.P.T.rep
+                      and type P.T.rexp = TS.S.P.T.rexp
+                      and type P.T.stm = TS.S.P.T.stm
 
     type reducer = 
       (I.instruction, I.C.cellset, I.operand, I.addressing_mode, CFG.cfg) TS.reducer
@@ -28,12 +71,54 @@ signature PPCCOMP_INSTR_EXT =
 functor PPCCompInstrExt (
 
     structure I : PPCINSTR
-    structure TS  : MLTREE_STREAM
-      where T = I.T
-    structure CFG : CONTROL_FLOW_GRAPH 
-      where P = TS.S.P
-	and I = I
-
+    structure TS  : MLTREE_STREAM (* where T = I.T *)
+                    where type T.Basis.cond = I.T.Basis.cond
+                      and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                      and type T.Basis.ext = I.T.Basis.ext
+                      and type T.Basis.fcond = I.T.Basis.fcond
+                      and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                      and type T.Constant.const = I.T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                      and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                      and type T.Region.region = I.T.Region.region
+                      and type T.ccexp = I.T.ccexp
+                      and type T.fexp = I.T.fexp
+                      (* and type T.labexp = I.T.labexp *)
+                      and type T.mlrisc = I.T.mlrisc
+                      and type T.oper = I.T.oper
+                      and type T.rep = I.T.rep
+                      and type T.rexp = I.T.rexp
+                      and type T.stm = I.T.stm
+    structure CFG : CONTROL_FLOW_GRAPH (* where P = TS.S.P and I = I *)
+                    where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                      and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                      and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                      and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                      and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                      and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                      and type P.T.Constant.const = TS.S.P.T.Constant.const
+                      and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                      and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                      and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                      and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                      and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                      and type P.T.Region.region = TS.S.P.T.Region.region
+                      and type P.T.ccexp = TS.S.P.T.ccexp
+                      and type P.T.fexp = TS.S.P.T.fexp
+                      (* and type P.T.labexp = TS.S.P.T.labexp *)
+                      and type P.T.mlrisc = TS.S.P.T.mlrisc
+                      and type P.T.oper = TS.S.P.T.oper
+                      and type P.T.rep = TS.S.P.T.rep
+                      and type P.T.rexp = TS.S.P.T.rexp
+                      and type P.T.stm = TS.S.P.T.stm
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
   ) : PPCCOMP_INSTR_EXT =  struct
 
     structure CFG = CFG
diff --git a/ppc/instructions/ppcInstr.sml b/ppc/instructions/ppcInstr.sml
index 5839cc9..a6dcdc0 100644
--- a/ppc/instructions/ppcInstr.sml
+++ b/ppc/instructions/ppcInstr.sml
@@ -8,7 +8,16 @@
 signature PPCINSTR =
 sig
    structure C : PPCCELLS
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    structure T : MLTREE
    structure Constant: CONSTANT
    structure Region : REGION
diff --git a/ppc/instructions/ppcProps.sml b/ppc/instructions/ppcProps.sml
index d1dd455..ee9be9b 100644
--- a/ppc/instructions/ppcProps.sml
+++ b/ppc/instructions/ppcProps.sml
@@ -5,8 +5,48 @@
 
 functor PPCProps
    ( structure PPCInstr : PPCINSTR
-     structure MLTreeEval : MLTREE_EVAL where T = PPCInstr.T
-     structure MLTreeHash : MLTREE_HASH where T = PPCInstr.T
+     structure MLTreeEval : MLTREE_EVAL (* where T = PPCInstr.T *)
+                            where type T.Basis.cond = PPCInstr.T.Basis.cond
+                              and type T.Basis.div_rounding_mode = PPCInstr.T.Basis.div_rounding_mode
+                              and type T.Basis.ext = PPCInstr.T.Basis.ext
+                              and type T.Basis.fcond = PPCInstr.T.Basis.fcond
+                              and type T.Basis.rounding_mode = PPCInstr.T.Basis.rounding_mode
+                              and type T.Constant.const = PPCInstr.T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) PPCInstr.T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) PPCInstr.T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) PPCInstr.T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) PPCInstr.T.Extension.sx
+                              and type T.I.div_rounding_mode = PPCInstr.T.I.div_rounding_mode
+                              and type T.Region.region = PPCInstr.T.Region.region
+                              and type T.ccexp = PPCInstr.T.ccexp
+                              and type T.fexp = PPCInstr.T.fexp
+                              (* and type T.labexp = PPCInstr.T.labexp *)
+                              and type T.mlrisc = PPCInstr.T.mlrisc
+                              and type T.oper = PPCInstr.T.oper
+                              and type T.rep = PPCInstr.T.rep
+                              and type T.rexp = PPCInstr.T.rexp
+                              and type T.stm = PPCInstr.T.stm
+     structure MLTreeHash : MLTREE_HASH (* where T = PPCInstr.T *)
+                            where type T.Basis.cond = PPCInstr.T.Basis.cond
+                              and type T.Basis.div_rounding_mode = PPCInstr.T.Basis.div_rounding_mode
+                              and type T.Basis.ext = PPCInstr.T.Basis.ext
+                              and type T.Basis.fcond = PPCInstr.T.Basis.fcond
+                              and type T.Basis.rounding_mode = PPCInstr.T.Basis.rounding_mode
+                              and type T.Constant.const = PPCInstr.T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) PPCInstr.T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) PPCInstr.T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) PPCInstr.T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) PPCInstr.T.Extension.sx
+                              and type T.I.div_rounding_mode = PPCInstr.T.I.div_rounding_mode
+                              and type T.Region.region = PPCInstr.T.Region.region
+                              and type T.ccexp = PPCInstr.T.ccexp
+                              and type T.fexp = PPCInstr.T.fexp
+                              (* and type T.labexp = PPCInstr.T.labexp *)
+                              and type T.mlrisc = PPCInstr.T.mlrisc
+                              and type T.oper = PPCInstr.T.oper
+                              and type T.rep = PPCInstr.T.rep
+                              and type T.rexp = PPCInstr.T.rexp
+                              and type T.stm = PPCInstr.T.stm
     ) : INSN_PROPERTIES = 
 struct
   structure I = PPCInstr
diff --git a/ppc/mltree/ppc.sml b/ppc/mltree/ppc.sml
index 94d81f6..c3968da 100644
--- a/ppc/mltree/ppc.sml
+++ b/ppc/mltree/ppc.sml
@@ -10,10 +10,76 @@
 
 functor PPC
   (structure PPCInstr : PPCINSTR
-   structure PseudoInstrs : PPC_PSEUDO_INSTR 
-   			where I = PPCInstr
-   structure ExtensionComp : MLTREE_EXTENSION_COMP 
-   			where I = PPCInstr and T = PPCInstr.T
+   structure PseudoInstrs : PPC_PSEUDO_INSTR (* where I = PPCInstr *)
+                            where type I.Constant.const = PPCInstr.Constant.const
+                              and type I.Region.region = PPCInstr.Region.region
+                              and type I.T.Basis.cond = PPCInstr.T.Basis.cond
+                              and type I.T.Basis.div_rounding_mode = PPCInstr.T.Basis.div_rounding_mode
+                              and type I.T.Basis.ext = PPCInstr.T.Basis.ext
+                              and type I.T.Basis.fcond = PPCInstr.T.Basis.fcond
+                              and type I.T.Basis.rounding_mode = PPCInstr.T.Basis.rounding_mode
+                              and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) PPCInstr.T.Extension.ccx
+                              and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) PPCInstr.T.Extension.fx
+                              and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) PPCInstr.T.Extension.rx
+                              and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) PPCInstr.T.Extension.sx
+                              and type I.T.I.div_rounding_mode = PPCInstr.T.I.div_rounding_mode
+                              and type I.T.ccexp = PPCInstr.T.ccexp
+                              and type I.T.fexp = PPCInstr.T.fexp
+                              (* and type I.T.labexp = PPCInstr.T.labexp *)
+                              and type I.T.mlrisc = PPCInstr.T.mlrisc
+                              and type I.T.oper = PPCInstr.T.oper
+                              and type I.T.rep = PPCInstr.T.rep
+                              and type I.T.rexp = PPCInstr.T.rexp
+                              and type I.T.stm = PPCInstr.T.stm
+                              and type I.arith = PPCInstr.arith
+                              and type I.arithi = PPCInstr.arithi
+                              and type I.bit = PPCInstr.bit
+                              and type I.bo = PPCInstr.bo
+                              and type I.ccarith = PPCInstr.ccarith
+                              and type I.cmp = PPCInstr.cmp
+                              and type I.ea = PPCInstr.ea
+                              and type I.farith = PPCInstr.farith
+                              and type I.farith3 = PPCInstr.farith3
+                              and type I.fcmp = PPCInstr.fcmp
+                              and type I.fload = PPCInstr.fload
+                              and type I.fstore = PPCInstr.fstore
+                              and type I.funary = PPCInstr.funary
+                              and type I.instr = PPCInstr.instr
+                              and type I.instruction = PPCInstr.instruction
+                              and type I.load = PPCInstr.load
+                              and type I.operand = PPCInstr.operand
+                              and type I.rotate = PPCInstr.rotate
+                              and type I.rotatei = PPCInstr.rotatei
+                              and type I.spr = PPCInstr.spr
+                              and type I.store = PPCInstr.store
+                              and type I.unary = PPCInstr.unary
+                              and type I.xerbit = PPCInstr.xerbit
+   structure ExtensionComp : MLTREE_EXTENSION_COMP (* where I = PPCInstr and T = PPCInstr.T *)
+                             where type I.addressing_mode = PPCInstr.addressing_mode
+                               and type I.ea = PPCInstr.ea
+                               and type I.instr = PPCInstr.instr
+                               and type I.instruction = PPCInstr.instruction
+                               and type I.operand = PPCInstr.operand
+                             where type T.Basis.cond = PPCInstr.T.Basis.cond
+                               and type T.Basis.div_rounding_mode = PPCInstr.T.Basis.div_rounding_mode
+                               and type T.Basis.ext = PPCInstr.T.Basis.ext
+                               and type T.Basis.fcond = PPCInstr.T.Basis.fcond
+                               and type T.Basis.rounding_mode = PPCInstr.T.Basis.rounding_mode
+                               and type T.Constant.const = PPCInstr.T.Constant.const
+                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) PPCInstr.T.Extension.ccx
+                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) PPCInstr.T.Extension.fx
+                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) PPCInstr.T.Extension.rx
+                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) PPCInstr.T.Extension.sx
+                               and type T.I.div_rounding_mode = PPCInstr.T.I.div_rounding_mode
+                               and type T.Region.region = PPCInstr.T.Region.region
+                               and type T.ccexp = PPCInstr.T.ccexp
+                               and type T.fexp = PPCInstr.T.fexp
+                               (* and type T.labexp = PPCInstr.T.labexp *)
+                               and type T.mlrisc = PPCInstr.T.mlrisc
+                               and type T.oper = PPCInstr.T.oper
+                               and type T.rep = PPCInstr.T.rep
+                               and type T.rexp = PPCInstr.T.rexp
+                               and type T.stm = PPCInstr.T.stm
 
    (* 
     * Support 64 bit mode? 
@@ -71,7 +137,7 @@ struct
   (*  
    * Integer multiplication 
    *)
-  functor Multiply32 = MLTreeMult
+  structure Mulu32 = MLTreeMult
     (structure I = I
      structure T = T
      structure CB = CellsBasis
@@ -84,40 +150,64 @@ struct
      fun slli{r,i,d} = [I.INSTR(SLLI32{r=r,i=i,d=d})]
      fun srli{r,i,d} = [I.INSTR(SRLI32{r=r,i=i,d=d})]
      fun srai{r,i,d} = [I.arithi{oper=I.SRAWI,rt=d,ra=r,im=I.ImmedOp i}]
-    )
 
-  structure Mulu32 = Multiply32
-    (val trapping = false
+     val trapping = false
      val multCost = multCost
      fun addv{r1,r2,d}=[I.arith{oper=I.ADD,ra=r1,rb=r2,rt=d,Rc=false,OE=false}]
      fun subv{r1,r2,d}=[I.arith{oper=I.SUBF,ra=r2,rb=r1,rt=d,Rc=false,OE=false}]
      val sh1addv = NONE
      val sh2addv = NONE
      val sh3addv = NONE
-    )
-    (val signed = false)
 
-  structure Muls32 = Multiply32
-    (val trapping = false
+     val signed = false)
+
+  structure Muls32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+     val intTy = 32
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d}= I.arith{oper=I.ADD,ra=r1,rb=r2,rt=d,Rc=false,OE=false}
+     fun slli{r,i,d} = [I.INSTR(SLLI32{r=r,i=i,d=d})]
+     fun srli{r,i,d} = [I.INSTR(SRLI32{r=r,i=i,d=d})]
+     fun srai{r,i,d} = [I.arithi{oper=I.SRAWI,rt=d,ra=r,im=I.ImmedOp i}]
+
+     val trapping = false
      val multCost = multCost
      fun addv{r1,r2,d}=[I.arith{oper=I.ADD,ra=r1,rb=r2,rt=d,Rc=false,OE=false}]
      fun subv{r1,r2,d}=[I.arith{oper=I.SUBF,ra=r2,rb=r1,rt=d,Rc=false,OE=false}]
      val sh1addv = NONE
      val sh2addv = NONE
      val sh3addv = NONE
-    )
-    (val signed = true)
 
-  structure Mult32 = Multiply32
-    (val trapping = true
+     val signed = true)
+
+  structure Mult32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+     val intTy = 32
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d}= I.arith{oper=I.ADD,ra=r1,rb=r2,rt=d,Rc=false,OE=false}
+     fun slli{r,i,d} = [I.INSTR(SLLI32{r=r,i=i,d=d})]
+     fun srli{r,i,d} = [I.INSTR(SRLI32{r=r,i=i,d=d})]
+     fun srai{r,i,d} = [I.arithi{oper=I.SRAWI,rt=d,ra=r,im=I.ImmedOp i}]
+
+     val trapping = true
      val multCost = multCost
      fun addv{r1,r2,d} = error "Mult32.addv"
      fun subv{r1,r2,d} = error "Mult32.subv"
      val sh1addv = NONE
      val sh2addv = NONE
      val sh3addv = NONE
-    )
-    (val signed = true)
+
+     val signed = true)
 
   fun selectInstructions
       (instrStream as 
@@ -277,7 +367,9 @@ struct
         | stmt(T.FCOPY(_, dst, src), an) = fcopy(dst, src, an)
         | stmt(T.JMP(T.LABEXP lexp, labs),an) =
              mark(I.B{addr=I.LabelOp lexp, LK=false},an)
-        | stmt(T.JMP(x as (T.LABEL _ | T.CONST _), labs),an) =
+        | stmt(T.JMP(x as T.LABEL _, labs),an) =
+             mark(I.B{addr=I.LabelOp x, LK=false},an)
+        | stmt(T.JMP(x as T.CONST _, labs),an) =
              mark(I.B{addr=I.LabelOp x, LK=false},an)
         | stmt(T.JMP(rexp, labs),an) =
           let val rs = expr(rexp)
@@ -326,7 +418,8 @@ struct
 		| T.LEU => (I.FALSE, I.GT)
 		| T.GTU => (I.TRUE,  I.GT)
 		| T.GEU => (I.FALSE, I.LT)
-		| (T.SETCC | T.MISC_COND _) => error "branch(CMP)"
+		| T.SETCC => error "branch(CMP)"
+		| T.MISC_COND _ => error "branch(CMP)"
 	     (*esac*))
             val ccreg = if true then CR0 else newCCreg() (* XXX *)
 	    val addr = I.LabelOp(T.LABEL lab)
@@ -356,11 +449,16 @@ struct
           in  case cc of 
                 T.EQ => branch(I.TRUE, I.EQ)
               | T.NE => branch(I.FALSE, I.EQ)
-              | (T.LT | T.LTU) => branch(I.TRUE, I.LT)
-              | (T.LE | T.LEU) => branch(I.FALSE, I.GT)
-              | (T.GE | T.GEU) => branch(I.FALSE, I.LT)
-              | (T.GT | T.GTU) => branch(I.TRUE, I.GT)
-	      | (T.SETCC | T.MISC_COND _) => error "branch(CC)"
+              | T.LT  => branch(I.TRUE, I.LT)
+              | T.LTU => branch(I.TRUE, I.LT)
+              | T.LE  => branch(I.FALSE, I.GT)
+              | T.LEU => branch(I.FALSE, I.GT)
+              | T.GE  => branch(I.FALSE, I.LT)
+              | T.GEU => branch(I.FALSE, I.LT)
+              | T.GT  => branch(I.TRUE, I.GT)
+              | T.GTU => branch(I.TRUE, I.GT)
+	      | T.SETCC => error "branch(CC)"
+	      | T.MISC_COND _ => error "branch(CC)"
           end  
         | branch(cmp as T.FCMP(fty, cond, _, _), lab, an) = 
           let val ccreg = if true then CR0 else newCCreg() (* XXX *)
@@ -390,7 +488,8 @@ struct
               | T.?<= => branch(I.FALSE,  ccreg, I.FG)
               | T.<>  => test2bits(I.FL, I.FG)
               | T.?=  => test2bits(I.FU, I.FE)
-	      | (T.SETFCC | T.MISC_FCOND _) => error "branch(FCMP)"
+	      | T.SETFCC => error "branch(FCMP)"
+	      | T.MISC_FCOND _ => error "branch(FCMP)"
              (*esac*)
           end
         | branch _ = error "branch"
@@ -496,7 +595,10 @@ struct
                            rb=expr e1, OE=false, Rc=false}, an)
             )
         | subtract(ty, T.LI i, e2, rt, an) = subfImmed(i, expr e2, rt, an)
-        | subtract(ty, x as (T.CONST _ | T.LABEL _), e2, rt, an) =
+        | subtract(ty, x as T.CONST _, e2, rt, an) =
+             mark(I.ARITHI{oper=I.SUBFIC,rt=rt,ra=expr e2,
+                           im=I.LabelOp x},an)
+        | subtract(ty, x as T.LABEL _, e2, rt, an) =
              mark(I.ARITHI{oper=I.SUBFIC,rt=rt,ra=expr e2,
                            im=I.LabelOp x},an)
         | subtract(ty, e1, e2, rt, an) =
@@ -729,8 +831,10 @@ struct
                app emitInstruction (PseudoInstrs.cvti2d{reg=expr e,fd=ft})
 
             (* Single/double precision support *)
-          | T.FABS((32|64), e) => funary(I.FABS, e, ft, an)
-          | T.FNEG((32|64), e) => funary(I.FNEG, e, ft, an)
+          | T.FABS(32, e) => funary(I.FABS, e, ft, an)
+          | T.FABS(64, e) => funary(I.FABS, e, ft, an)
+          | T.FNEG(32, e) => funary(I.FNEG, e, ft, an)
+          | T.FNEG(64, e) => funary(I.FNEG, e, ft, an)
 	  | T.FSQRT(32, e)     => funary(I.FSQRTS, e, ft, an)
 	  | T.FSQRT(64, e)     => funary(I.FSQRT, e, ft, an)
 
@@ -757,8 +861,12 @@ struct
               T.CMP(ty, cc, e1, e2) => 
               let val (opnds, cmp) =
                    case cc of 
-                     (T.LT | T.LE | T.EQ | T.NE | T.GT | T.GE) =>
-                       (immedOpnd signed16, I.CMP)
+                     T.LT => (immedOpnd signed16, I.CMP)
+                   | T.LE => (immedOpnd signed16, I.CMP)
+                   | T.EQ => (immedOpnd signed16, I.CMP)
+                   | T.NE => (immedOpnd signed16, I.CMP)
+                   | T.GT => (immedOpnd signed16, I.CMP)
+                   | T.GE => (immedOpnd signed16, I.CMP)
                    | _ => (immedOpnd unsigned16, I.CMPL)
                   val (opndA, opndB) = opnds(e1, e2)
                   val l  = case ty of
diff --git a/ra/arch-spill-instr.sig b/ra/arch-spill-instr.sig
index b91475f..a76c52c 100644
--- a/ra/arch-spill-instr.sig
+++ b/ra/arch-spill-instr.sig
@@ -10,7 +10,16 @@
  *)
 signature ARCH_SPILL_INSTR = sig
   structure I : INSTRUCTIONS
-  structure CB : CELLS_BASIS = CellsBasis
+  structure CB : CELLS_BASIS (* = CellsBasis *)
+                 where type CellSet.cellset = CellsBasis.CellSet.cellset
+                   and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                   and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                   and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                   and type cell = CellsBasis.cell
+                   and type cellColor = CellsBasis.cellColor
+                   and type cellkind = CellsBasis.cellkind
+                   and type cellkindDesc = CellsBasis.cellkindDesc
+                   and type cellkindInfo = CellsBasis.cellkindInfo
   
   val spillToEA :
       CB.cellkind ->
diff --git a/ra/chaitin-spillheur2.sml b/ra/chaitin-spillheur2.sml
index 3ca0dbe..475d126 100644
--- a/ra/chaitin-spillheur2.sml
+++ b/ra/chaitin-spillheur2.sml
@@ -35,7 +35,35 @@ struct
           | moveSavings(NODE{movelist, ...}) = 
             let fun loop([], savings) = 
                      foldr (fn ((_,a),b) => Real.max(a,b)) 0.0 savings
-                  | loop(MV{status=ref(WORKLIST | GEORGE_MOVE | BRIGGS_MOVE),
+                  | loop(MV{status=ref WORKLIST,
+                            dst, src, cost, ...}::mvs, savings) =
+                    let fun add(c,[]) = [(c,cost)]
+                          | add(c,(x as (c':int,s))::savings) =
+                             if c = c' then (c',s+cost)::savings
+                             else x::add(c,savings)
+                        val savings =
+                           case chase dst of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ =>
+                           case chase src of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ => savings
+                   in  loop(mvs, savings) end
+                  | loop(MV{status=ref GEORGE_MOVE,
+                            dst, src, cost, ...}::mvs, savings) =
+                    let fun add(c,[]) = [(c,cost)]
+                          | add(c,(x as (c':int,s))::savings) =
+                             if c = c' then (c',s+cost)::savings
+                             else x::add(c,savings)
+                        val savings =
+                           case chase dst of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ =>
+                           case chase src of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ => savings
+                   in  loop(mvs, savings) end
+                  | loop(MV{status=ref BRIGGS_MOVE,
                             dst, src, cost, ...}::mvs, savings) = 
                     let fun add(c,[]) = [(c,cost)]
                           | add(c,(x as (c':int,s))::savings) =
diff --git a/ra/chow-hennessy-spillheur2.sml b/ra/chow-hennessy-spillheur2.sml
index 811a509..54fac74 100644
--- a/ra/chow-hennessy-spillheur2.sml
+++ b/ra/chow-hennessy-spillheur2.sml
@@ -32,7 +32,35 @@ struct
           | moveSavings(NODE{movelist, ...}) = 
             let fun loop([], savings) = 
                      foldr (fn ((_,a),b) => Real.max(a,b)) 0.0 savings
-                  | loop(MV{status=ref(WORKLIST | GEORGE_MOVE | BRIGGS_MOVE),
+                  | loop(MV{status=ref WORKLIST,
+                            dst, src, cost, ...}::mvs, savings) =
+                    let fun add(c,[]) = [(c,cost)]
+                          | add(c,(x as (c':int,s))::savings) =
+                             if c = c' then (c',s+cost)::savings
+                             else x::add(c,savings)
+                        val savings =
+                           case chase dst of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ =>
+                           case chase src of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ => savings
+                   in  loop(mvs, savings) end
+                  | loop(MV{status=ref GEORGE_MOVE,
+                            dst, src, cost, ...}::mvs, savings) =
+                    let fun add(c,[]) = [(c,cost)]
+                          | add(c,(x as (c':int,s))::savings) =
+                             if c = c' then (c',s+cost)::savings
+                             else x::add(c,savings)
+                        val savings =
+                           case chase dst of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ =>
+                           case chase src of
+                             NODE{color=ref(COLORED c), ...} => add(c,savings)
+                           | _ => savings
+                   in  loop(mvs, savings) end
+                  | loop(MV{status=ref BRIGGS_MOVE,
                             dst, src, cost, ...}::mvs, savings) = 
                     let fun add(c,[]) = [(c,cost)]
                           | add(c,(x as (c':int,s))::savings) =
diff --git a/ra/cluster-ra.sml b/ra/cluster-ra.sml
index 129fe40..edef1e1 100644
--- a/ra/cluster-ra.sml
+++ b/ra/cluster-ra.sml
@@ -14,13 +14,45 @@
 
 functor ClusterRA
    (structure Asm       : INSTRUCTION_EMITTER
-    structure Flowgraph : CONTROL_FLOW_GRAPH
-    			where I = Asm.I 
-			  and P = Asm.S.P
-    structure InsnProps : INSN_PROPERTIES
-    			where I = Flowgraph.I 
-    structure Spill : RA_SPILL 
-    			where I = Flowgraph.I
+    structure Flowgraph : CONTROL_FLOW_GRAPH (* where I = Asm.I and P = Asm.S.P *)
+                          where type I.addressing_mode = Asm.I.addressing_mode
+                            and type I.ea = Asm.I.ea
+                            and type I.instr = Asm.I.instr
+                            and type I.instruction = Asm.I.instruction
+                            and type I.operand = Asm.I.operand
+                          where type P.Client.pseudo_op = Asm.S.P.Client.pseudo_op
+                            and type P.T.Basis.cond = Asm.S.P.T.Basis.cond
+                            and type P.T.Basis.div_rounding_mode = Asm.S.P.T.Basis.div_rounding_mode
+                            and type P.T.Basis.ext = Asm.S.P.T.Basis.ext
+                            and type P.T.Basis.fcond = Asm.S.P.T.Basis.fcond
+                            and type P.T.Basis.rounding_mode = Asm.S.P.T.Basis.rounding_mode
+                            and type P.T.Constant.const = Asm.S.P.T.Constant.const
+                            and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Asm.S.P.T.Extension.ccx
+                            and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Asm.S.P.T.Extension.fx
+                            and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Asm.S.P.T.Extension.rx
+                            and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Asm.S.P.T.Extension.sx
+                            and type P.T.I.div_rounding_mode = Asm.S.P.T.I.div_rounding_mode
+                            and type P.T.Region.region = Asm.S.P.T.Region.region
+                            and type P.T.ccexp = Asm.S.P.T.ccexp
+                            and type P.T.fexp = Asm.S.P.T.fexp
+                            (* and type P.T.labexp = Asm.S.P.T.labexp *)
+                            and type P.T.mlrisc = Asm.S.P.T.mlrisc
+                            and type P.T.oper = Asm.S.P.T.oper
+                            and type P.T.rep = Asm.S.P.T.rep
+                            and type P.T.rexp = Asm.S.P.T.rexp
+                            and type P.T.stm = Asm.S.P.T.stm
+    structure InsnProps : INSN_PROPERTIES (* where I = Flowgraph.I *)
+                          where type I.addressing_mode = Flowgraph.I.addressing_mode
+                            and type I.ea = Flowgraph.I.ea
+                            and type I.instr = Flowgraph.I.instr
+                            and type I.instruction = Flowgraph.I.instruction
+                            and type I.operand = Flowgraph.I.operand
+    structure Spill     : RA_SPILL (* where I = Flowgraph.I *)
+                          where type I.addressing_mode = Flowgraph.I.addressing_mode
+                            and type I.ea = Flowgraph.I.ea
+                            and type I.instr = Flowgraph.I.instr
+                            and type I.instruction = Flowgraph.I.instruction
+                            and type I.operand = Flowgraph.I.operand
    ) : RA_FLOWGRAPH =
 struct
    structure CFG    = Flowgraph
diff --git a/ra/mem-ra.sml b/ra/mem-ra.sml
index de295f5..e248202 100644
--- a/ra/mem-ra.sml
+++ b/ra/mem-ra.sml
@@ -51,7 +51,9 @@ struct
       fun collectMoves([], mv') = mv'
 	| collectMoves(NODE{movelist, color, ...}::ns, mv') = let
 	    fun ins([], mv') = collectMoves(ns, mv')
-	      | ins(MV{status=ref(COALESCED | CONSTRAINED), ...}::mvs, mv') = 
+	      | ins(MV{status=ref COALESCED, ...}::mvs, mv') =
+		  ins(mvs, mv')
+	      | ins(MV{status=ref CONSTRAINED, ...}::mvs, mv') =
 		  ins(mvs, mv')
 	      | ins((mv as MV{dst, src, ...})::mvs, mv') = let
 		  val NODE{color=ref cd, number=nd, ...} = chase dst
@@ -92,7 +94,19 @@ struct
 		| union((n as NODE{color, adj=adjT, 
 				   number=t, ...})::adjDst, adjSrc) = 
 		  (case !color of
-		     (SPILLED | MEMREG _ | SPILL_LOC _ | PSEUDO) =>
+		     SPILLED =>
+		       if addEdge(s, t) then
+			  (adjT := src :: !adjT; union(adjDst, n::adjSrc))
+		       else union(adjDst, adjSrc)
+		   | MEMREG _ =>
+		       if addEdge(s, t) then
+			  (adjT := src :: !adjT; union(adjDst, n::adjSrc))
+		       else union(adjDst, adjSrc)
+		   | SPILL_LOC _ =>
+		       if addEdge(s, t) then
+			  (adjT := src :: !adjT; union(adjDst, n::adjSrc))
+		       else union(adjDst, adjSrc)
+		   | PSEUDO =>
 		       if addEdge(s, t) then 
 			  (adjT := src :: !adjT; union(adjDst, n::adjSrc))
 		       else union(adjDst, adjSrc)
@@ -155,7 +169,10 @@ struct
                  x = y orelse member(x,y) orelse interferes(x, ns)
 
           fun moveSavings([], pinned, total) = (pinned, total+total)
-            | moveSavings(MV{status=ref(CONSTRAINED | COALESCED), ...}::mvs,
+            | moveSavings(MV{status=ref CONSTRAINED, ...}::mvs,
+                          pinned, total) =
+                 moveSavings(mvs, pinned, total)
+            | moveSavings(MV{status=ref COALESCED, ...}::mvs,
                           pinned, total) = 
                  moveSavings(mvs, pinned, total)
             | moveSavings(MV{dst, src, cost, ...}::mvs, pinned, total) =
diff --git a/ra/ra-core.sig b/ra/ra-core.sig
index 3127769..1cecd17 100644
--- a/ra/ra-core.sig
+++ b/ra/ra-core.sig
@@ -11,7 +11,26 @@
 signature RA_CORE = 
 sig
 
-   structure G  : RA_GRAPH = RAGraph
+   structure G  : RA_GRAPH (* = RAGraph *)
+                  where type C.CellSet.cellset = RAGraph.C.CellSet.cellset
+                    and type 'a C.ColorTable.hash_table = 'a RAGraph.C.ColorTable.hash_table
+                    and type 'a C.HashTable.hash_table = 'a RAGraph.C.HashTable.hash_table
+                    and type C.SortedCells.sorted_cells = RAGraph.C.SortedCells.sorted_cells
+                    and type C.cell = RAGraph.C.cell
+                    and type C.cellColor = RAGraph.C.cellColor
+                    and type C.cellkind = RAGraph.C.cellkind
+                    and type C.cellkindDesc = RAGraph.C.cellkindDesc
+                    and type C.cellkindInfo = RAGraph.C.cellkindInfo
+                    and type 'a PPtHashTable.hash_table = 'a RAGraph.PPtHashTable.hash_table
+                    and type 'a SpillLocHashTable.hash_table = 'a RAGraph.SpillLocHashTable.hash_table
+                    and type interferenceGraph = RAGraph.interferenceGraph
+                    and type move = RAGraph.move
+                    and type moveKind = RAGraph.moveKind
+                    and type moveStatus = RAGraph.moveStatus
+                    and type node = RAGraph.node
+                    and type nodeStatus = RAGraph.nodeStatus
+                    and type spillLoc = RAGraph.spillLoc
+                    and type trailInfo = RAGraph.trailInfo
    structure BM : RA_BITMATRIX
    structure MV : RA_PRIORITY_QUEUE where type elem = G.move
    structure FZ : RA_PRIORITY_QUEUE where type elem = G.node
diff --git a/ra/ra-core.sml b/ra/ra-core.sml
index 594fd74..ae42220 100644
--- a/ra/ra-core.sml
+++ b/ra/ra-core.sml
@@ -163,7 +163,15 @@ struct
   fun dumpGraph(G as G.GRAPH{nodes, showReg, K,...}) stream =
   let fun pr s = TextIO.output(stream, s)
       val show = show G
-      fun prMove(MV{src, dst, status=ref(WORKLIST | BRIGGS_MOVE | GEORGE_MOVE),
+      fun prMove(MV{src, dst, status=ref WORKLIST,
+                    cost,...}) =
+            pr(node2s(chase dst)^" <- "^node2s(chase src)^
+               "("^r2s(cost)^") ")
+        | prMove(MV{src, dst, status=ref BRIGGS_MOVE,
+                    cost,...}) =
+            pr(node2s(chase dst)^" <- "^node2s(chase src)^
+               "("^r2s(cost)^") ")
+        | prMove(MV{src, dst, status=ref GEORGE_MOVE,
                     cost,...}) = 
             pr(node2s(chase dst)^" <- "^node2s(chase src)^
                "("^r2s(cost)^") ")
@@ -541,7 +549,13 @@ struct
                 | addMv((m as MV{status, hicount as ref hi, ...})::rest,
                         ns, mv) = 
                   (case !status of
-                     (BRIGGS_MOVE | GEORGE_MOVE) => 
+                     BRIGGS_MOVE =>
+                       (* decrements hi, when hi <= 0 enable move *)
+                       if hi <= 1 then
+                         (status := WORKLIST; addMv(rest, ns, MV.add(m, mv)))
+                       else
+                         (hicount := hi-1; addMv(rest, ns, mv))
+                   | GEORGE_MOVE =>
                        (* decrements hi, when hi <= 0 enable move *)
                        if hi <= 1 then
                          (status := WORKLIST; addMv(rest, ns, MV.add(m, mv)))
@@ -623,7 +637,10 @@ struct
                 * nodes that are removed, since removed nodes either have
                 * deg < K or else optimistic spilling must be in effect!
                 *)
-               NODE{degree,number,color=ref(PSEUDO | REMOVED), ...} => 
+               NODE{degree,number,color=ref PSEUDO, ...} =>
+               if !degree < K orelse member(reg, number) then loop(adj, hi)
+               else loop(adj, hi+1)
+             | NODE{degree,number,color=ref REMOVED, ...} =>
                if !degree < K orelse member(reg, number) then loop(adj, hi)
                else loop(adj, hi+1)
              | _ => loop(adj, hi)
@@ -706,7 +723,13 @@ struct
            | union((t as NODE{color, degree, ...})::adj, 
                    mv, fz, stack) =
               (case !color of
-                 (COLORED _ | SPILL_LOC _ | MEMREG _ | SPILLED) => 
+                 COLORED _ =>
+                   (addEdge(t, u); union(adj, mv, fz, stack))
+               | SPILL_LOC _ =>
+                   (addEdge(t, u); union(adj, mv, fz, stack))
+               | MEMREG _ =>
+                   (addEdge(t, u); union(adj, mv, fz, stack))
+               | SPILLED =>
                    (addEdge(t, u); union(adj, mv, fz, stack))
                | PSEUDO =>
                    (addEdge(t, u);
@@ -864,7 +887,22 @@ struct
             | elimMoves(MV{status, src, dst, ...}::mvs, simp) =
               case !status of 
                 WORKLIST => error "elimMoves"
-              | (BRIGGS_MOVE | GEORGE_MOVE) => (* mark move as lost *)
+              | BRIGGS_MOVE => (* mark move as lost *)
+                let val _ = status := LOST
+                    val src as NODE{number=s,...} = chase src
+                    val you = if s = me then chase dst else src
+                in  case you of
+                      NODE{color=ref(COLORED _),...} =>
+                        elimMoves(mvs, simp)
+                    | NODE{movecnt as ref c, degree, ...} => (* pseudo *)
+                        (movecnt := c - 1;
+                         if c = 1 andalso !degree < K then
+                            elimMoves(mvs, you::simp)
+                         else
+                            elimMoves(mvs, simp)
+                        )
+                end
+              | GEORGE_MOVE => (* mark move as lost *)
                 let val _ = status := LOST
                     val src as NODE{number=s,...} = chase src
                     val you = if s = me then chase dst else src
@@ -1085,7 +1123,23 @@ struct
                * color the move with the same color
                *)
               fun getPref([], pref) = pref
-                | getPref(MV{status=ref(LOST | BRIGGS_MOVE | GEORGE_MOVE), 
+                | getPref(MV{status=ref LOST,
+                             src, dst, ...}::mvs, pref) =
+                  let val src as NODE{number=s,...} = chase src
+                      val other = if s = number then chase dst else src
+                  in  case other of
+                        NODE{color=ref(COLORED c),...} => getPref(mvs, c::pref)
+                      | _ => getPref(mvs, pref)
+                  end
+                | getPref(MV{status=ref BRIGGS_MOVE,
+                             src, dst, ...}::mvs, pref) =
+                  let val src as NODE{number=s,...} = chase src
+                      val other = if s = number then chase dst else src
+                  in  case other of
+                        NODE{color=ref(COLORED c),...} => getPref(mvs, c::pref)
+                      | _ => getPref(mvs, pref)
+                  end
+                | getPref(MV{status=ref GEORGE_MOVE,
                              src, dst, ...}::mvs, pref) =
                   let val src as NODE{number=s,...} = chase src
                       val other = if s = number then chase dst else src 
diff --git a/ra/ra-deadCodeE.sml b/ra/ra-deadCodeE.sml
index 8f05f89..a7bb8c8 100644
--- a/ra/ra-deadCodeE.sml
+++ b/ra/ra-deadCodeE.sml
@@ -6,9 +6,9 @@
  * -- Allen
  *)
 
-functor RADeadCodeElim
-   (Flowgraph : RA_FLOWGRAPH)
-   (  (* check for dead code on these cellkinds only *)
+functor RADeadCodeElim (
+    structure Flowgraph : RA_FLOWGRAPH
+      (* check for dead code on these cellkinds only *)
     val cellkind : CellsBasis.cellkind -> bool
       (* Dead registers are stored here. *)
     val deadRegs : bool IntHashTable.hash_table 
diff --git a/ra/ra-flowgraph.sig b/ra/ra-flowgraph.sig
index 6837166..d7b6981 100644
--- a/ra/ra-flowgraph.sig
+++ b/ra/ra-flowgraph.sig
@@ -12,10 +12,34 @@ sig
 
    structure I     : INSTRUCTIONS
    structure C     : CELLS  
-   structure G     : RA_GRAPH = RAGraph
+   structure G     : RA_GRAPH (* = RAGraph *)
+                     where type C.CellSet.cellset = RAGraph.C.CellSet.cellset
+                       and type 'a C.ColorTable.hash_table = 'a RAGraph.C.ColorTable.hash_table
+                       and type 'a C.HashTable.hash_table = 'a RAGraph.C.HashTable.hash_table
+                       and type C.SortedCells.sorted_cells = RAGraph.C.SortedCells.sorted_cells
+                       and type C.cell = RAGraph.C.cell
+                       and type C.cellColor = RAGraph.C.cellColor
+                       and type C.cellkind = RAGraph.C.cellkind
+                       and type C.cellkindDesc = RAGraph.C.cellkindDesc
+                       and type C.cellkindInfo = RAGraph.C.cellkindInfo
+                       and type 'a PPtHashTable.hash_table = 'a RAGraph.PPtHashTable.hash_table
+                       and type 'a SpillLocHashTable.hash_table = 'a RAGraph.SpillLocHashTable.hash_table
+                       and type interferenceGraph = RAGraph.interferenceGraph
+                       and type move = RAGraph.move
+                       and type moveKind = RAGraph.moveKind
+                       and type moveStatus = RAGraph.moveStatus
+                       and type node = RAGraph.node
+                       and type nodeStatus = RAGraph.nodeStatus
+                       and type spillLoc = RAGraph.spillLoc
+                       and type trailInfo = RAGraph.trailInfo
    structure Spill : RA_SPILL
-     sharing Spill.I = I
-     sharing I.C = C 
+     (* sharing Spill.I = I *)
+     where type I.addressing_mode = I.addressing_mode
+       and type I.ea = I.ea
+       and type I.instr = I.instr
+       and type I.instruction = I.instruction
+       and type I.operand = I.operand
+     (* sharing I.C = C *)
 
    type flowgraph
 
diff --git a/ra/ra-graph.sig b/ra/ra-graph.sig
index 67f7d89..db2435b 100644
--- a/ra/ra-graph.sig
+++ b/ra/ra-graph.sig
@@ -11,7 +11,10 @@ signature RA_GRAPH =
 sig
 
   structure C : CELLS_BASIS
-  structure BM : RA_BITMATRIX = RaBitmatrix
+  structure BM : RA_BITMATRIX (* = RaBitmatrix *)
+                 where type bitMatrix = RaBitmatrix.bitMatrix
+                   and type bucket = RaBitmatrix.bucket
+                   and type hashTable = RaBitmatrix.hashTable
   (*
    * The following are the data structures used in the register allocator.
    *)
diff --git a/ra/ra-spill-with-renaming.sml b/ra/ra-spill-with-renaming.sml
index d5d2b8b..ba4dff1 100644
--- a/ra/ra-spill-with-renaming.sml
+++ b/ra/ra-spill-with-renaming.sml
@@ -79,16 +79,14 @@
  * -- Allen
  *)
 
-local
-
-   val debug = false
-
-in
-
 functor RASpillWithRenaming
    (structure InsnProps : INSN_PROPERTIES 
-    structure Asm       : INSTRUCTION_EMITTER
-    			where I = InsnProps.I
+    structure Asm       : INSTRUCTION_EMITTER (* where I = InsnProps.I *)
+                          where type I.addressing_mode = InsnProps.I.addressing_mode
+                            and type I.ea = InsnProps.I.ea
+                            and type I.instr = InsnProps.I.instr
+                            and type I.instruction = InsnProps.I.instruction
+                            and type I.operand = InsnProps.I.operand
 
     (* Spilling a variable v creates tiny live-ranges at all its definitions
      * and uses.  The following parameter is the maximal distance of
@@ -107,6 +105,7 @@ functor RASpillWithRenaming
     val keep_multiple_values : bool ref
    ) : RA_SPILL =
 struct
+   val debug = false
 
    structure I      = InsnProps.I
    structure P      = InsnProps
@@ -584,5 +583,3 @@ struct
    in  spillRewrite
    end
 end
-
-end (* local *)
diff --git a/ra/ra-spill.sig b/ra/ra-spill.sig
index 2d19e00..39279de 100644
--- a/ra/ra-spill.sig
+++ b/ra/ra-spill.sig
@@ -7,11 +7,39 @@ signature RA_SPILL =
 sig
 
    structure I : INSTRUCTIONS
-   structure G : RA_GRAPH = RAGraph
+   structure G : RA_GRAPH (* = RAGraph *)
+                 where type C.CellSet.cellset = RAGraph.C.CellSet.cellset
+                   and type 'a C.ColorTable.hash_table = 'a RAGraph.C.ColorTable.hash_table
+                   and type 'a C.HashTable.hash_table = 'a RAGraph.C.HashTable.hash_table
+                   and type C.SortedCells.sorted_cells = RAGraph.C.SortedCells.sorted_cells
+                   and type C.cell = RAGraph.C.cell
+                   and type C.cellColor = RAGraph.C.cellColor
+                   and type C.cellkind = RAGraph.C.cellkind
+                   and type C.cellkindDesc = RAGraph.C.cellkindDesc
+                   and type C.cellkindInfo = RAGraph.C.cellkindInfo
+                   and type 'a PPtHashTable.hash_table = 'a RAGraph.PPtHashTable.hash_table
+                   and type 'a SpillLocHashTable.hash_table = 'a RAGraph.SpillLocHashTable.hash_table
+                   and type interferenceGraph = RAGraph.interferenceGraph
+                   and type move = RAGraph.move
+                   and type moveKind = RAGraph.moveKind
+                   and type moveStatus = RAGraph.moveStatus
+                   and type node = RAGraph.node
+                   and type nodeStatus = RAGraph.nodeStatus
+                   and type spillLoc = RAGraph.spillLoc
+                   and type trailInfo = RAGraph.trailInfo
    structure C : CELLS 
-      sharing I.C = C
+      (* sharing I.C = C *)
 
-   structure CB : CELLS_BASIS = CellsBasis 
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    type copyInstr =
           (CB.cell list * CB.cell list) * I.instruction -> I.instruction list
 
diff --git a/ra/ra-spill.sml b/ra/ra-spill.sml
index d89a67a..8df619e 100644
--- a/ra/ra-spill.sml
+++ b/ra/ra-spill.sml
@@ -48,18 +48,17 @@
  * -- Allen
  *)
 
-local
-
-   val debug = false
-
-in
-
 functor RASpill
    (structure InsnProps : INSN_PROPERTIES
-    structure Asm       : INSTRUCTION_EMITTER
-    			where I = InsnProps.I
+    structure Asm       : INSTRUCTION_EMITTER (* where I = InsnProps.I *)
+                          where type I.addressing_mode = InsnProps.I.addressing_mode
+                            and type I.ea = InsnProps.I.ea
+                            and type I.instr = InsnProps.I.instr
+                            and type I.instruction = InsnProps.I.instruction
+                            and type I.operand = InsnProps.I.operand
    ) : RA_SPILL =
 struct
+   val debug = false
 
    structure I      = InsnProps.I
    structure P      = InsnProps
@@ -451,5 +450,3 @@ struct
    in  spillRewrite
    end
 end
-
-end (* local *)
diff --git a/ra/ra-spillheur.sig b/ra/ra-spillheur.sig
index 50f0224..77aeeb5 100644
--- a/ra/ra-spillheur.sig
+++ b/ra/ra-spillheur.sig
@@ -3,7 +3,26 @@
  *)
 signature RA_SPILL_HEURISTICS =
 sig
-   structure G : RA_GRAPH = RAGraph
+   structure G : RA_GRAPH (* = RAGraph *)
+                 where type C.CellSet.cellset = RAGraph.C.CellSet.cellset
+                   and type 'a C.ColorTable.hash_table = 'a RAGraph.C.ColorTable.hash_table
+                   and type 'a C.HashTable.hash_table = 'a RAGraph.C.HashTable.hash_table
+                   and type C.SortedCells.sorted_cells = RAGraph.C.SortedCells.sorted_cells
+                   and type C.cell = RAGraph.C.cell
+                   and type C.cellColor = RAGraph.C.cellColor
+                   and type C.cellkind = RAGraph.C.cellkind
+                   and type C.cellkindDesc = RAGraph.C.cellkindDesc
+                   and type C.cellkindInfo = RAGraph.C.cellkindInfo
+                   and type 'a PPtHashTable.hash_table = 'a RAGraph.PPtHashTable.hash_table
+                   and type 'a SpillLocHashTable.hash_table = 'a RAGraph.SpillLocHashTable.hash_table
+                   and type interferenceGraph = RAGraph.interferenceGraph
+                   and type move = RAGraph.move
+                   and type moveKind = RAGraph.moveKind
+                   and type moveStatus = RAGraph.moveStatus
+                   and type node = RAGraph.node
+                   and type nodeStatus = RAGraph.nodeStatus
+                   and type spillLoc = RAGraph.spillLoc
+                   and type trailInfo = RAGraph.trailInfo
 
    exception NoCandidate
 
diff --git a/ra/ra.sig b/ra/ra.sig
index 7fdacac..549c5a4 100644
--- a/ra/ra.sig
+++ b/ra/ra.sig
@@ -9,9 +9,23 @@ sig
    structure I : INSTRUCTIONS
    structure C : CELLS
    structure F : RA_FLOWGRAPH 
-      sharing F.I   = I
-      sharing I.C   = C
-   structure CB : CELLS_BASIS = CellsBasis
+      (* sharing F.I = I *)
+     where type I.addressing_mode = I.addressing_mode
+       and type I.ea = I.ea
+       and type I.instr = I.instr
+       and type I.instruction = I.instruction
+       and type I.operand = I.operand
+      (* sharing I.C = C *)
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
 
    type getreg = { pref  : CB.cell_id list,
                    stamp : int, 
diff --git a/ra/ra.sml b/ra/ra.sml
index 388f0b2..bf66604 100644
--- a/ra/ra.sml
+++ b/ra/ra.sml
@@ -37,9 +37,10 @@
  * -- Allen Leung (leunga@cs.nyu.edu)
  *)
 
-functor RegisterAllocator
-   (SpillHeuristics : RA_SPILL_HEURISTICS) 
-   (Flowgraph : RA_FLOWGRAPH where C = CellsBasis) : RA =
+functor RegisterAllocator (
+   structure SpillHeuristics : RA_SPILL_HEURISTICS
+   structure Flowgraph : RA_FLOWGRAPH (* where C = CellsBasis *)
+) : RA =
 struct
 
    structure F      = Flowgraph
diff --git a/ra/region-based-ra.sml b/ra/region-based-ra.sml
index 7166945..e31e981 100644
--- a/ra/region-based-ra.sml
+++ b/ra/region-based-ra.sml
@@ -4,10 +4,10 @@
  * it into manageable pieces to be allocated.
  *)
 functor RegionBasedRA
-   (RA : RA)
-   (FlowgraphPartitioner : RA_FLOWGRAPH_PARTITIONER 
+   (structure RA : RA
+    structure FlowgraphPartitioner : RA_FLOWGRAPH_PARTITIONER
        where type flowgraph = RA.F.flowgraph
-       where C = RA.C
+       (* where C = RA.C *)
    ) : RA =
 struct
 
diff --git a/ra/risc-ra.sml b/ra/risc-ra.sml
index d5d2ec3..b965871 100644
--- a/ra/risc-ra.sml
+++ b/ra/risc-ra.sml
@@ -5,17 +5,57 @@
  *)
 functor RISC_RA
   (structure I         : INSTRUCTIONS
-   structure Asm       : INSTRUCTION_EMITTER
-   			where I = I 
-   structure CFG       : CONTROL_FLOW_GRAPH 
-   			where I = I
-		          and P = Asm.S.P
-   structure InsnProps : INSN_PROPERTIES
-   			where I = I
-   structure Rewrite   : REWRITE_INSTRUCTIONS
-   			where I = I
-   structure SpillInstr : ARCH_SPILL_INSTR
-                        where I = I
+   structure Asm        : INSTRUCTION_EMITTER (* where I = I *)
+                          where type I.addressing_mode = I.addressing_mode
+                            and type I.ea = I.ea
+                            and type I.instr = I.instr
+                            and type I.instruction = I.instruction
+                            and type I.operand = I.operand
+   structure CFG        : CONTROL_FLOW_GRAPH (* where I = I and P = Asm.S.P *)
+                          where type I.addressing_mode = I.addressing_mode
+                            and type I.ea = I.ea
+                            and type I.instr = I.instr
+                            and type I.instruction = I.instruction
+                            and type I.operand = I.operand
+                          where type P.Client.pseudo_op = Asm.S.P.Client.pseudo_op
+                            and type P.T.Basis.cond = Asm.S.P.T.Basis.cond
+                            and type P.T.Basis.div_rounding_mode = Asm.S.P.T.Basis.div_rounding_mode
+                            and type P.T.Basis.ext = Asm.S.P.T.Basis.ext
+                            and type P.T.Basis.fcond = Asm.S.P.T.Basis.fcond
+                            and type P.T.Basis.rounding_mode = Asm.S.P.T.Basis.rounding_mode
+                            and type P.T.Constant.const = Asm.S.P.T.Constant.const
+                            and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) Asm.S.P.T.Extension.ccx
+                            and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) Asm.S.P.T.Extension.fx
+                            and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) Asm.S.P.T.Extension.rx
+                            and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) Asm.S.P.T.Extension.sx
+                            and type P.T.I.div_rounding_mode = Asm.S.P.T.I.div_rounding_mode
+                            and type P.T.Region.region = Asm.S.P.T.Region.region
+                            and type P.T.ccexp = Asm.S.P.T.ccexp
+                            and type P.T.fexp = Asm.S.P.T.fexp
+                            (* and type P.T.labexp = Asm.S.P.T.labexp *)
+                            and type P.T.mlrisc = Asm.S.P.T.mlrisc
+                            and type P.T.oper = Asm.S.P.T.oper
+                            and type P.T.rep = Asm.S.P.T.rep
+                            and type P.T.rexp = Asm.S.P.T.rexp
+                            and type P.T.stm = Asm.S.P.T.stm
+   structure InsnProps  : INSN_PROPERTIES (* where I = I *)
+                          where type I.addressing_mode = I.addressing_mode
+                            and type I.ea = I.ea
+                            and type I.instr = I.instr
+                            and type I.instruction = I.instruction
+                            and type I.operand = I.operand
+   structure Rewrite    : REWRITE_INSTRUCTIONS (* where I = I *)
+                          where type I.addressing_mode = I.addressing_mode
+                            and type I.ea = I.ea
+                            and type I.instr = I.instr
+                            and type I.instruction = I.instruction
+                            and type I.operand = I.operand
+   structure SpillInstr : ARCH_SPILL_INSTR (* where I = I *)
+                          where type I.addressing_mode = I.addressing_mode
+                            and type I.ea = I.ea
+                            and type I.instr = I.instr
+                            and type I.instruction = I.instruction
+                            and type I.operand = I.operand
 
       (* Spilling heuristics determines which node should be spilled.
        * You can use Chaitin, ChowHenessey, or one of your own.
@@ -26,7 +66,12 @@ functor RISC_RA
        * spill code.  You can use RASpill, or RASpillWithRenaming,
        * or write your own if you are feeling adventurous.
        *)
-   structure Spill : RA_SPILL where I = I
+   structure Spill : RA_SPILL (* where I = I *)
+                     where type I.addressing_mode = I.addressing_mode
+                       and type I.ea = I.ea
+                       and type I.instr = I.instr
+                       and type I.instruction = I.instruction
+                       and type I.operand = I.operand
           
    val architecture : string
 
@@ -85,9 +130,9 @@ struct
    (* The generic register allocator *)
    structure Ra =
       RegisterAllocator
-        (SpillHeur) 
+        (structure SpillHeuristics = SpillHeur
         (* (ChowHennessySpillHeur) *)
-        (ClusterRA 
+         structure Flowgraph = ClusterRA
           (structure Flowgraph = CFG
            structure Asm = Asm
            structure InsnProps = InsnProps
diff --git a/sparc/backpatch/sparcDelaySlotProps.sml b/sparc/backpatch/sparcDelaySlotProps.sml
index e552cd8..5897411 100644
--- a/sparc/backpatch/sparcDelaySlotProps.sml
+++ b/sparc/backpatch/sparcDelaySlotProps.sml
@@ -1,6 +1,11 @@
 functor SparcDelaySlots
    (structure I : SPARCINSTR
-    structure P : INSN_PROPERTIES where I = I
+    structure P : INSN_PROPERTIES (* where I = I *)
+                  where type I.addressing_mode = I.addressing_mode
+                    and type I.ea = I.ea
+                    and type I.instr = I.instr
+                    and type I.instruction = I.instruction
+                    and type I.operand = I.operand
     (* sharing/defn conflict:   sharing P.I = I*)
    ) : DELAY_SLOT_PROPERTIES =
 struct
@@ -113,10 +118,16 @@ struct
             clash(toSL defUseOther)
         end
 
-    fun delaySlotCandidate{jmp,delaySlot=
-              (  I.INSTR(I.CALL _) | I.INSTR(I.Bicc _) | I.INSTR(I.FBfcc _) 
-               | I.INSTR(I.Ticc _) | I.INSTR(I.BR _) | I.INSTR(I.JMP _) | I.INSTR(I.JMPL _) 
-	       | I.INSTR(I.RET _) | I.INSTR(I.BP _) | I.INSTR(I.FCMP _))} = false
+    fun delaySlotCandidate{jmp,delaySlot=I.INSTR(I.CALL _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.Bicc _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.FBfcc _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.Ticc _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BR _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.JMP _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.JMPL _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.RET _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.BP _)} = false
+      | delaySlotCandidate{jmp,delaySlot=I.INSTR(I.FCMP _)} = false
       | delaySlotCandidate{jmp=I.ANNOTATION{i,...},delaySlot} = 
            delaySlotCandidate{jmp=i,delaySlot=delaySlot}
       | delaySlotCandidate{jmp,delaySlot=I.ANNOTATION{i,...}} = 
diff --git a/sparc/backpatch/sparcJumps.sml b/sparc/backpatch/sparcJumps.sml
index 43763bd..bec245e 100644
--- a/sparc/backpatch/sparcJumps.sml
+++ b/sparc/backpatch/sparcJumps.sml
@@ -5,8 +5,67 @@
  *)
 functor SparcJumps
   (structure Instr:SPARCINSTR
-   structure Shuffle:SPARCSHUFFLE where I = Instr
-   structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+   structure Shuffle:SPARCSHUFFLE (* where I = Instr *)
+                     where type I.Constant.const = Instr.Constant.const
+                       and type I.Region.region = Instr.Region.region
+                       and type I.T.Basis.cond = Instr.T.Basis.cond
+                       and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                       and type I.T.Basis.ext = Instr.T.Basis.ext
+                       and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                       and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                       and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                       and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                       and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                       and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                       and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                       and type I.T.ccexp = Instr.T.ccexp
+                       and type I.T.fexp = Instr.T.fexp
+                       (* and type I.T.labexp = Instr.T.labexp *)
+                       and type I.T.mlrisc = Instr.T.mlrisc
+                       and type I.T.oper = Instr.T.oper
+                       and type I.T.rep = Instr.T.rep
+                       and type I.T.rexp = Instr.T.rexp
+                       and type I.T.stm = Instr.T.stm
+                       and type I.arith = Instr.arith
+                       and type I.branch = Instr.branch
+                       and type I.cc = Instr.cc
+                       and type I.ea = Instr.ea
+                       and type I.farith1 = Instr.farith1
+                       and type I.farith2 = Instr.farith2
+                       and type I.fbranch = Instr.fbranch
+                       and type I.fcmp = Instr.fcmp
+                       and type I.fload = Instr.fload
+                       and type I.fsize = Instr.fsize
+                       and type I.fstore = Instr.fstore
+                       and type I.instr = Instr.instr
+                       and type I.instruction = Instr.instruction
+                       and type I.load = Instr.load
+                       and type I.operand = Instr.operand
+                       and type I.prediction = Instr.prediction
+                       and type I.rcond = Instr.rcond
+                       and type I.shift = Instr.shift
+                       and type I.store = Instr.store
+   structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
   ) : SDI_JUMPS = 
 struct
   structure I = Instr
@@ -51,7 +110,9 @@ struct
 	    | I.SAVE{i,...} => oper i
 	    | I.RESTORE{i,...} => oper i
 	    (* The following is only true of Version 8 *)
-	    | I.FPop1{a=(I.FMOVd | I.FNEGd | I.FABSd), ...} => true
+	    | I.FPop1{a=I.FMOVd, ...} => true
+	    | I.FPop1{a=I.FNEGd, ...} => true
+	    | I.FPop1{a=I.FABSd, ...} => true
 	    | _ => false
 	end
 
@@ -70,11 +131,15 @@ struct
 	 | (I.BP{nop=true,...}) => 8
 	 | (I.RET{nop=true,...}) => 8
 	 | (I.FCMP{nop=true,...}) => 8
-	 | (I.FPop1{a=(I.FMOVd | I.FNEGd | I.FABSd),...}) => 8
+	 | (I.FPop1{a=I.FMOVd,...}) => 8
+	 | (I.FPop1{a=I.FNEGd,...}) => 8
+	 | (I.FPop1{a=I.FABSd,...}) => 8
 	 |  _          => 4
       (*esac*))
 
-  fun maxSize (I.INSTR(I.FPop1{a=(I.FMOVd | I.FNEGd | I.FABSd),...})) = 8
+  fun maxSize (I.INSTR(I.FPop1{a=I.FMOVd,...})) = 8
+    | maxSize (I.INSTR(I.FPop1{a=I.FNEGd,...})) = 8
+    | maxSize (I.INSTR(I.FPop1{a=I.FABSd,...})) = 8
     | maxSize (I.ANNOTATION{i,...}) = maxSize i
     | maxSize _		   = 4
 
@@ -85,7 +150,11 @@ struct
   fun immed30 n = ~0x4000000 <= n andalso n < 0x3ffffff
 
   fun instrLength([],n) = n
-    | instrLength(I.INSTR(I.FPop1{a=(I.FMOVd | I.FNEGd | I.FABSd),...})::is,n) =
+    | instrLength(I.INSTR(I.FPop1{a=I.FMOVd,...})::is,n) =
+        instrLength(is,n+8)
+    | instrLength(I.INSTR(I.FPop1{a=I.FNEGd,...})::is,n) =
+        instrLength(is,n+8)
+    | instrLength(I.INSTR(I.FPop1{a=I.FABSd,...})::is,n) =
         instrLength(is,n+8)
     | instrLength(_::is,n) = instrLength(is,n+4)
 
@@ -135,7 +204,9 @@ struct
 	  | I.BP{label,nop,...} => branch19 label + delaySlot nop
 	  | I.CALL{label,...} => call label
 	  | I.WRY{i,...} => oper(i,12)
- 	  | I.FPop1{a=(I.FMOVd | I.FNEGd | I.FABSd),...} => 8	    
+	  | I.FPop1{a=I.FMOVd,...} => 8
+	  | I.FPop1{a=I.FNEGd,...} => 8
+	  | I.FPop1{a=I.FABSd,...} => 8
 	  | _ => error "sdiSize"
       end
     | sdiSize _ = error "sdiSize"
@@ -207,10 +278,15 @@ struct
 	| (I.FBfcc _,8) => [instr]
 	| (I.BR _,8) => [instr]
 	| (I.BP _,8) => [instr]
-	| (I.JMPL{r,i,d,defs,uses,cutsTo,nop,mem},(12 | 16)) => 
+	| (I.JMPL{r,i,d,defs,uses,cutsTo,nop,mem},12) =>
 	    expandImm(i,I.JMPL{r=r,i=I.REG C.asmTmpR,d=d,defs=defs,uses=uses,
 			       cutsTo=cutsTo,nop=nop,mem=mem})
-	| (I.JMP{r,i,labs,nop},(12 | 16)) => 
+	| (I.JMPL{r,i,d,defs,uses,cutsTo,nop,mem},16) =>
+	    expandImm(i,I.JMPL{r=r,i=I.REG C.asmTmpR,d=d,defs=defs,uses=uses,
+			       cutsTo=cutsTo,nop=nop,mem=mem})
+	| (I.JMP{r,i,labs,nop},12) =>
+	    expandImm(i,I.JMP{r=r,i=I.REG C.asmTmpR,labs=labs,nop=nop})
+	| (I.JMP{r,i,labs,nop},16) =>
 	    expandImm(i,I.JMP{r=r,i=I.REG C.asmTmpR,labs=labs,nop=nop})
 	| (I.Ticc{t,cc,r,i},12) =>
 	    expandImm(i,I.Ticc{t=t,cc=cc,r=r,i=I.REG C.asmTmpR})
diff --git a/sparc/c-calls/sparc-c-calls.sml b/sparc/c-calls/sparc-c-calls.sml
index 6a27f75..413756f 100644
--- a/sparc/c-calls/sparc-c-calls.sml
+++ b/sparc/c-calls/sparc-c-calls.sml
@@ -105,15 +105,21 @@ struct
     fun roundup (i, a) = a * ((i + a - 1) div a)
 
     (* calculate size and alignment for a C type *)
-    fun szal (Ty.C_void | Ty.C_float | Ty.C_PTR |
-	      Ty.C_signed (Ty.I_int | Ty.I_long) |
-	      Ty.C_unsigned (Ty.I_int | Ty.I_long)) = (4, 4)
-      | szal (Ty.C_double |
-	      Ty.C_signed Ty.I_long_long |
-	      Ty.C_unsigned Ty.I_long_long) = (8, 8)
+    fun szal Ty.C_void = (4, 4)
+      | szal Ty.C_float = (4, 4)
+      | szal Ty.C_PTR = (4, 4)
+      | szal (Ty.C_signed Ty.I_int) = (4, 4)
+      | szal (Ty.C_signed Ty.I_long) = (4, 4)
+      | szal (Ty.C_unsigned Ty.I_int) = (4, 4)
+      | szal (Ty.C_unsigned Ty.I_long) = (4, 4)
+      | szal Ty.C_double = (8, 8)
+      | szal (Ty.C_signed Ty.I_long_long) = (8, 8)
+      | szal (Ty.C_unsigned Ty.I_long_long) = (8, 8)
       | szal (Ty.C_long_double) = (16, 8)
-      | szal (Ty.C_signed Ty.I_char | Ty.C_unsigned Ty.I_char) = (1, 1)
-      | szal (Ty.C_signed Ty.I_short | Ty.C_unsigned Ty.I_short) = (2, 2)
+      | szal (Ty.C_signed Ty.I_char) = (1, 1)
+      | szal (Ty.C_unsigned Ty.I_char) = (1, 1)
+      | szal (Ty.C_signed Ty.I_short) = (2, 2)
+      | szal (Ty.C_unsigned Ty.I_short) = (2, 2)
       | szal (Ty.C_ARRAY (t, n)) = let val (s, a) = szal t in (n * s, a) end
       | szal (Ty.C_STRUCT l) =
 	let (* i: next free memory address (relative to struct start);
@@ -183,21 +189,24 @@ struct
 		  callComment, args } = let
 	val { conv, retTy, paramTys } = proto
 	val _ = case conv of
-		    ("" | "ccall") => ()
+		    "" => ()
+		  | "ccall" => ()
 		  | _ => error (concat ["unknown calling convention \"",
 					String.toString conv, "\""])
 	val res_szal =
 	    case retTy of
-		(Ty.C_long_double | Ty.C_STRUCT _ | Ty.C_UNION _) =>
-		  SOME (szal retTy)
+		Ty.C_long_double => SOME (szal retTy)
+	      | Ty.C_STRUCT _ => SOME (szal retTy)
+	      | Ty.C_UNION _ => SOME (szal retTy)
 	      | _ => NONE
 
 	val nargwords = let
 	    fun loop ([], n) = n
 	      | loop (t :: tl, n) =
 		loop (tl, (case t of
-			       (Ty.C_double | Ty.C_signed Ty.I_long_long |
-				Ty.C_unsigned Ty.I_long_long) => 2
+			       Ty.C_double => 2
+			     | (Ty.C_signed Ty.I_long_long) => 2
+			     | (Ty.C_unsigned Ty.I_long_long) => 2
 			     | _ => 1) + n)
 	in
 	    loop (paramTys, 0)
@@ -225,17 +234,21 @@ struct
 		    T.STORE (ty, addli (spreg, to_off), a, stack) :: cpc
 	    in
 		case t of
-		    (Ty.C_void | Ty.C_PTR |
-		     Ty.C_signed (Ty.I_int | Ty.I_long) |
-		     Ty.C_unsigned (Ty.I_int | Ty.I_long)) => ldst 32
-		  | (Ty.C_signed Ty.I_char | Ty.C_unsigned Ty.I_char) => ldst 8
-		  | (Ty.C_signed Ty.I_short | Ty.C_unsigned Ty.I_short) =>
-		    ldst 16
-		  | (Ty.C_signed Ty.I_long_long |
-		     Ty.C_unsigned Ty.I_long_long) => ldst 64
+		    Ty.C_void => ldst 32
+		  | Ty.C_PTR => ldst 32
+		  | (Ty.C_signed Ty.I_int) => ldst 32
+		  | (Ty.C_signed Ty.I_long) => ldst 32
+		  | (Ty.C_unsigned Ty.I_int) => ldst 32
+		  | (Ty.C_unsigned Ty.I_long) => ldst 32
+		  | (Ty.C_signed Ty.I_char) => ldst 8
+		  | (Ty.C_unsigned Ty.I_char) => ldst 8
+		  | (Ty.C_signed Ty.I_short) => ldst 16
+		  | (Ty.C_unsigned Ty.I_short) => ldst 16
+		  | (Ty.C_signed Ty.I_long_long) => ldst 64
+		  | (Ty.C_unsigned Ty.I_long_long) => ldst 64
 		  | (Ty.C_ARRAY _) =>
 		    error "ARRAY within gather/scatter struct"
-		  | (Ty.C_STRUCT _ | Ty.C_UNION _) =>
+		  | (Ty.C_STRUCT _) =>
 		    (* Here we have to do the equivalent of a "memcpy". *)
 		    let val from = a (* argument is address of struct *)
 			fun cp (ty, incr) = let
@@ -260,8 +273,34 @@ struct
 			  | 2 => cp (16, 2)
 			  | _ => (* 4 or more *) cp (32, 4)
 		    end
-		  | (Ty.C_float | Ty.C_double | Ty.C_long_double) =>
-		    error "floating point type does not match ARG"
+		  | (Ty.C_UNION _) =>
+		    (* Here we have to do the equivalent of a "memcpy". *)
+		    let val from = a (* argument is address of struct *)
+			fun cp (ty, incr) = let
+			    fun load_from from_off =
+				T.LOAD (32, addli (from, from_off), mem)
+			    (* from_off is relative to from,
+			     * to_off is relative to %sp *)
+			    fun loop (i, from_off, to_off, cpc) =
+				if i <= 0 then cpc
+				else loop (i - incr,
+					   from_off + incr, to_off + incr,
+					   T.STORE (ty, addli (spreg, to_off),
+						    load_from from_off,
+						    stack)
+					   :: cpc)
+			in
+			    loop (sz, 0, to_off, cpc)
+			end
+		    in
+			case al of
+			    1 => cp (8, 1)
+			  | 2 => cp (16, 2)
+			  | _ => (* 4 or more *) cp (32, 4)
+		    end
+		  | Ty.C_float => error "floating point type does not match ARG"
+		  | Ty.C_double => error "floating point type does not match ARG"
+		  | Ty.C_long_double => error "floating point type does not match ARG"
 	    end
 (*
 	  | struct_copy (_, _, ARGS args, Ty.C_STRUCT tl, to_off, cpc) =
@@ -334,10 +373,13 @@ struct
 			else dwordmemarg (tmpaddr, stack, [mkstore tmpaddr])
 		in
 		    case (t, a) of
-			((Ty.C_void | Ty.C_PTR | Ty.C_ARRAY _ |
-			  Ty.C_unsigned (Ty.I_int | Ty.I_long) |
-			  Ty.C_signed (Ty.I_int | Ty.I_long)),
-			 ARG a) => wordarg (a, cpc, ss)
+			(Ty.C_void, ARG a) => wordarg (a, cpc, ss)
+		      | (Ty.C_PTR, ARG a) => wordarg (a, cpc, ss)
+		      | (Ty.C_ARRAY _, ARG a) => wordarg (a, cpc, ss)
+		      | (Ty.C_unsigned Ty.I_int, ARG a) => wordarg (a, cpc, ss)
+		      | (Ty.C_unsigned Ty.I_long, ARG a) => wordarg (a, cpc, ss)
+		      | (Ty.C_signed Ty.I_int, ARG a) => wordarg (a, cpc, ss)
+		      | (Ty.C_signed Ty.I_long, ARG a) => wordarg (a, cpc, ss)
 		      | (Ty.C_signed Ty.I_char, ARG a) =>
 			wordarg (T.SX (32, 8, a), cpc, ss)
 		      | (Ty.C_unsigned Ty.I_char, ARG a) =>
@@ -346,8 +388,13 @@ struct
 			wordarg (T.SX (32, 16, a), cpc, ss)
 		      | (Ty.C_unsigned Ty.I_short, ARG a) =>
 			wordarg (T.ZX (32, 16, a), cpc, ss)
-		      | ((Ty.C_signed Ty.I_long_long |
-			  Ty.C_unsigned Ty.I_long_long), ARG a) =>
+		      | (Ty.C_signed Ty.I_long_long, ARG a) =>
+			(case a of
+			     T.LOAD (_, addr, region) =>
+			     dwordmemarg (addr, region, [])
+			   | _ => dwordarg (fn addr =>
+					       T.STORE (64, addr, a, stack)))
+		      | (Ty.C_unsigned Ty.I_long_long, ARG a) =>
 			(case a of
 			     T.LOAD (_, addr, region) =>
 			     dwordmemarg (addr, region, [])
@@ -390,7 +437,20 @@ struct
 				     T.FSTORE (128, ssaddr, a, stack) :: cpc,
 				     ss' + 16)
 			end
-		      | (t as (Ty.C_STRUCT _ | Ty.C_UNION _), a) => let
+		      | (t as (Ty.C_STRUCT _), a) => let
+			    (* copy entire struct into scratch space
+			     * (aligned according to struct's alignment
+			     * requirements).  The address of the scratch
+			     * copy is then passed as a regular 32-bit
+			     * argument. *)
+			    val (sz, al) = szal t
+			    val ss' = roundup (ss, al)
+			    val ssaddr = addli (spreg, ss')
+			    val cpc' = struct_copy (sz, al, a, t, ss', cpc)
+			in
+			    wordarg (ssaddr, cpc', ss' + sz)
+			end
+		      | (t as (Ty.C_UNION _), a) => let
 			    (* copy entire struct into scratch space
 			     * (aligned according to struct's alignment
 			     * requirements).  The address of the scratch
@@ -437,17 +497,32 @@ struct
 		Ty.C_float => [T.FPR (T.FREG (32, FP 0))]
 	      | Ty.C_double => [T.FPR (T.FREG (64, FP 0))] (* %f0/%f1 *)
 	      | Ty.C_long_double => []
-	      | (Ty.C_STRUCT _ | Ty.C_UNION _) => []
+	      | (Ty.C_STRUCT _) => []
+	      | (Ty.C_UNION _) => []
 	      | Ty.C_ARRAY _ => error "array return type"
-	      | (Ty.C_PTR | Ty.C_void |
-		 Ty.C_signed (Ty.I_int | Ty.I_long) |
-		 Ty.C_unsigned (Ty.I_int | Ty.I_long)) =>
+	      | Ty.C_PTR =>
 		[T.GPR (T.REG (32, oreg 0))]
-	      | (Ty.C_signed Ty.I_char | Ty.C_unsigned Ty.I_char) =>
+	      | Ty.C_void =>
+		[T.GPR (T.REG (32, oreg 0))]
+	      | Ty.C_signed Ty.I_int =>
+		[T.GPR (T.REG (32, oreg 0))]
+	      | Ty.C_signed Ty.I_long =>
+		[T.GPR (T.REG (32, oreg 0))]
+	      | Ty.C_unsigned Ty.I_int =>
+		[T.GPR (T.REG (32, oreg 0))]
+	      | Ty.C_unsigned Ty.I_long =>
+		[T.GPR (T.REG (32, oreg 0))]
+	      | Ty.C_signed Ty.I_char =>
+		[T.GPR (T.REG (8, oreg 0))]
+	      | Ty.C_unsigned Ty.I_char =>
 		[T.GPR (T.REG (8, oreg 0))]
-	      | (Ty.C_signed Ty.I_short | Ty.C_unsigned Ty.I_short) =>
+	      | Ty.C_signed Ty.I_short =>
+		[T.GPR (T.REG (16, oreg 0))]
+	      | Ty.C_unsigned Ty.I_short =>
 		[T.GPR (T.REG (16, oreg 0))]
-	      | (Ty.C_signed Ty.I_long_long | Ty.C_unsigned Ty.I_long_long) =>
+	      | Ty.C_signed Ty.I_long_long =>
+		[T.GPR (T.REG (64, oreg 0))]
+	      | Ty.C_unsigned Ty.I_long_long =>
 		[T.GPR (T.REG (64, oreg 0))]
 
 	val { save, restore } = saveRestoreDedicated defs
diff --git a/sparc/emit/sparcAsm.sml b/sparc/emit/sparcAsm.sml
index 821445a..bd88ce1 100644
--- a/sparc/emit/sparcAsm.sml
+++ b/sparc/emit/sparcAsm.sml
@@ -6,12 +6,88 @@
 
 
 functor SparcAsmEmitter(structure S : INSTRUCTION_STREAM
-                        structure Instr : SPARCINSTR
-                           where T = S.P.T
-                        structure Shuffle : SPARCSHUFFLE
-                           where I = Instr
-                        structure MLTreeEval : MLTREE_EVAL
-                           where T = Instr.T
+                        structure Instr : SPARCINSTR (* where T = S.P.T *)
+                                          where type T.Basis.cond = S.P.T.Basis.cond
+                                            and type T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+                                            and type T.Basis.ext = S.P.T.Basis.ext
+                                            and type T.Basis.fcond = S.P.T.Basis.fcond
+                                            and type T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+                                            and type T.Constant.const = S.P.T.Constant.const
+                                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+                                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+                                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+                                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+                                            and type T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+                                            and type T.Region.region = S.P.T.Region.region
+                                            and type T.ccexp = S.P.T.ccexp
+                                            and type T.fexp = S.P.T.fexp
+                                            (* and type T.labexp = S.P.T.labexp *)
+                                            and type T.mlrisc = S.P.T.mlrisc
+                                            and type T.oper = S.P.T.oper
+                                            and type T.rep = S.P.T.rep
+	                                    and type T.rexp = S.P.T.rexp
+                                            and type T.stm = S.P.T.stm
+                        structure Shuffle : SPARCSHUFFLE (* where I = Instr *)
+                                            where type I.Constant.const = Instr.Constant.const
+                                              and type I.Region.region = Instr.Region.region
+                                              and type I.T.Basis.cond = Instr.T.Basis.cond
+                                              and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                              and type I.T.Basis.ext = Instr.T.Basis.ext
+                                              and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                              and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                              and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                              and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                              and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                              and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                              and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                              and type I.T.ccexp = Instr.T.ccexp
+                                              and type I.T.fexp = Instr.T.fexp
+                                              (* and type I.T.labexp = Instr.T.labexp *)
+                                              and type I.T.mlrisc = Instr.T.mlrisc
+                                              and type I.T.oper = Instr.T.oper
+                                              and type I.T.rep = Instr.T.rep
+                                              and type I.T.rexp = Instr.T.rexp
+                                              and type I.T.stm = Instr.T.stm
+                                              and type I.arith = Instr.arith
+                                              and type I.branch = Instr.branch
+                                              and type I.cc = Instr.cc
+                                              and type I.ea = Instr.ea
+                                              and type I.farith1 = Instr.farith1
+                                              and type I.farith2 = Instr.farith2
+                                              and type I.fbranch = Instr.fbranch
+                                              and type I.fcmp = Instr.fcmp
+                                              and type I.fload = Instr.fload
+                                              and type I.fsize = Instr.fsize
+                                              and type I.fstore = Instr.fstore
+                                              and type I.instr = Instr.instr
+                                              and type I.instruction = Instr.instruction
+                                              and type I.load = Instr.load
+                                              and type I.operand = Instr.operand
+                                              and type I.prediction = Instr.prediction
+                                              and type I.rcond = Instr.rcond
+                                              and type I.shift = Instr.shift
+                                              and type I.store = Instr.store
+                        structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                               where type T.Basis.cond = Instr.T.Basis.cond
+                                                 and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                                 and type T.Basis.ext = Instr.T.Basis.ext
+                                                 and type T.Basis.fcond = Instr.T.Basis.fcond
+                                                 and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                                 and type T.Constant.const = Instr.T.Constant.const
+                                                 and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                                 and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                                 and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                                 and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                                 and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                                 and type T.Region.region = Instr.T.Region.region
+                                                 and type T.ccexp = Instr.T.ccexp
+                                                 and type T.fexp = Instr.T.fexp
+                                                 (* and type T.labexp = Instr.T.labexp *)
+                                                 and type T.mlrisc = Instr.T.mlrisc
+                                                 and type T.oper = Instr.T.oper
+                                                 and type T.rep = Instr.T.rep
+                                                 and type T.rexp = Instr.T.rexp
+                                                 and type T.stm = Instr.T.stm
 
 (*#line 466.21 "sparc/sparc.mdl"*)
                         val V9 : bool
diff --git a/sparc/emit/sparcMC.sml b/sparc/emit/sparcMC.sml
index 4aa4e00..079645d 100644
--- a/sparc/emit/sparcMC.sml
+++ b/sparc/emit/sparcMC.sml
@@ -6,7 +6,27 @@
 
 
 functor SparcMCEmitter(structure Instr : SPARCINSTR
-                       structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+                       structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                              where type T.Basis.cond = Instr.T.Basis.cond
+                                                and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                                and type T.Basis.ext = Instr.T.Basis.ext
+                                                and type T.Basis.fcond = Instr.T.Basis.fcond
+                                                and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                                and type T.Constant.const = Instr.T.Constant.const
+                                                and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                                and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                                and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                                and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                                and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                                and type T.Region.region = Instr.T.Region.region
+                                                and type T.ccexp = Instr.T.ccexp
+                                                and type T.fexp = Instr.T.fexp
+                                                (* and type T.labexp = Instr.T.labexp *)
+                                                and type T.mlrisc = Instr.T.mlrisc
+                                                and type T.oper = Instr.T.oper
+                                                and type T.rep = Instr.T.rep
+                                                and type T.rexp = Instr.T.rexp
+                                                and type T.stm = Instr.T.stm
                        structure Stream : INSTRUCTION_STREAM 
                        structure CodeString : CODE_STRING
                       ) : INSTRUCTION_EMITTER =
@@ -47,6 +67,7 @@ struct
        (* note: fromLargeWord strips the high order bits! *)
        fun eByteW w =
        let val i = !loc
+           val w = W.toLargeWord w
        in loc := i + 1; CodeString.update(i,Word8.fromLargeWord w) end
    
        fun doNothing _ = ()
diff --git a/sparc/flowgraph/sparcGasPseudoOps.sml b/sparc/flowgraph/sparcGasPseudoOps.sml
index 3675d5f..66f08f0 100644
--- a/sparc/flowgraph/sparcGasPseudoOps.sml
+++ b/sparc/flowgraph/sparcGasPseudoOps.sml
@@ -1,6 +1,26 @@
 functor SparcGasPseudoOps 
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL  where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
     ) : PSEUDO_OPS_BASIS = 
 
 struct
diff --git a/sparc/instructions/sparcInstr.sml b/sparc/instructions/sparcInstr.sml
index 1cd82fc..54e5c76 100644
--- a/sparc/instructions/sparcInstr.sml
+++ b/sparc/instructions/sparcInstr.sml
@@ -8,7 +8,16 @@
 signature SPARCINSTR =
 sig
    structure C : SPARCCELLS
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    structure T : MLTREE
    structure Constant: CONSTANT
    structure Region : REGION
@@ -234,7 +243,7 @@ sig
               sz: int,          (* in bits *)
               dst: CellsBasis.cell list,
               src: CellsBasis.cell list,
-              tmp: ea option (* NONE if |dst| = {src| = 1 *)}
+              tmp: ea option (* NONE if |dst| = |src| = 1 *)}
    | ANNOTATION of {i:instruction, a:Annotations.annotation}
    | INSTR of instr
    val load : {l:load, d:CellsBasis.cell, r:CellsBasis.cell, i:operand, mem:Region.region} -> instruction
diff --git a/sparc/instructions/sparcProps.sml b/sparc/instructions/sparcProps.sml
index 8f6c283..b67eda6 100644
--- a/sparc/instructions/sparcProps.sml
+++ b/sparc/instructions/sparcProps.sml
@@ -5,8 +5,48 @@
 
 functor SparcProps
   (structure SparcInstr : SPARCINSTR
-   structure MLTreeEval : MLTREE_EVAL where T = SparcInstr.T
-   structure MLTreeHash : MLTREE_HASH where T = SparcInstr.T
+   structure MLTreeEval : MLTREE_EVAL (* where T = SparcInstr.T *)
+                          where type T.Basis.cond = SparcInstr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = SparcInstr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = SparcInstr.T.Basis.ext
+                            and type T.Basis.fcond = SparcInstr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = SparcInstr.T.Basis.rounding_mode
+                            and type T.Constant.const = SparcInstr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) SparcInstr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) SparcInstr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) SparcInstr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) SparcInstr.T.Extension.sx
+                            and type T.I.div_rounding_mode = SparcInstr.T.I.div_rounding_mode
+                            and type T.Region.region = SparcInstr.T.Region.region
+                            and type T.ccexp = SparcInstr.T.ccexp
+                            and type T.fexp = SparcInstr.T.fexp
+                            (* and type T.labexp = SparcInstr.T.labexp *)
+                            and type T.mlrisc = SparcInstr.T.mlrisc
+                            and type T.oper = SparcInstr.T.oper
+                            and type T.rep = SparcInstr.T.rep
+                            and type T.rexp = SparcInstr.T.rexp
+                            and type T.stm = SparcInstr.T.stm
+   structure MLTreeHash : MLTREE_HASH (* where T = SparcInstr.T *)
+                          where type T.Basis.cond = SparcInstr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = SparcInstr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = SparcInstr.T.Basis.ext
+                            and type T.Basis.fcond = SparcInstr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = SparcInstr.T.Basis.rounding_mode
+                            and type T.Constant.const = SparcInstr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) SparcInstr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) SparcInstr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) SparcInstr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) SparcInstr.T.Extension.sx
+                            and type T.I.div_rounding_mode = SparcInstr.T.I.div_rounding_mode
+                            and type T.Region.region = SparcInstr.T.Region.region
+                            and type T.ccexp = SparcInstr.T.ccexp
+                            and type T.fexp = SparcInstr.T.fexp
+                            (* and type T.labexp = SparcInstr.T.labexp *)
+                            and type T.mlrisc = SparcInstr.T.mlrisc
+                            and type T.oper = SparcInstr.T.oper
+                            and type T.rep = SparcInstr.T.rep
+                            and type T.rexp = SparcInstr.T.rexp
+                            and type T.stm = SparcInstr.T.stm
    ) : INSN_PROPERTIES =
 struct
   structure I = SparcInstr
diff --git a/sparc/instructions/sparccomp-instr-ext.sml b/sparc/instructions/sparccomp-instr-ext.sml
index 918dbaa..7cf7daf 100644
--- a/sparc/instructions/sparccomp-instr-ext.sml
+++ b/sparc/instructions/sparccomp-instr-ext.sml
@@ -7,12 +7,54 @@
  *)
 signature SPARCCOMP_INSTR_EXT = sig
     structure T : MLTREE
-    structure I : SPARCINSTR
-    		where T = T
-    structure TS : MLTREE_STREAM
-		where T = I.T
-    structure CFG : CONTROL_FLOW_GRAPH 
-    		where I = I 
+    structure I : SPARCINSTR (* where T = T *)
+                  where type T.Basis.cond = T.Basis.cond
+                    and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                    and type T.Basis.ext = T.Basis.ext
+                    and type T.Basis.fcond = T.Basis.fcond
+                    and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                    and type T.Constant.const = T.Constant.const
+                    and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                    and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                    and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                    and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                    and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                    and type T.Region.region = T.Region.region
+                    and type T.ccexp = T.ccexp
+                    and type T.fexp = T.fexp
+                    (* and type T.labexp = T.labexp *)
+                    and type T.mlrisc = T.mlrisc
+                    and type T.oper = T.oper
+                    and type T.rep = T.rep
+                    and type T.rexp = T.rexp
+                    and type T.stm = T.stm
+    structure TS : MLTREE_STREAM (* where T = I.T *)
+                   where type T.Basis.cond = I.T.Basis.cond
+                     and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                     and type T.Basis.ext = I.T.Basis.ext
+                     and type T.Basis.fcond = I.T.Basis.fcond
+                     and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                     and type T.Constant.const = I.T.Constant.const
+                     and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                     and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                     and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                     and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                     and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                     and type T.Region.region = I.T.Region.region
+                     and type T.ccexp = I.T.ccexp
+                     and type T.fexp = I.T.fexp
+                     (* and type T.labexp = I.T.labexp *)
+                     and type T.mlrisc = I.T.mlrisc
+                     and type T.oper = I.T.oper
+                     and type T.rep = I.T.rep
+                     and type T.rexp = I.T.rexp
+                     and type T.stm = I.T.stm
+    structure CFG : CONTROL_FLOW_GRAPH (* where I = I *)
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
 
 
     type reducer =
@@ -27,11 +69,54 @@ end
 
 functor SparcCompInstrExt 
   (structure I   : SPARCINSTR
-   structure TS  : MLTREE_STREAM
-		where T = I.T
-   structure CFG : CONTROL_FLOW_GRAPH 
-   		where I = I
-                  and P = TS.S.P
+   structure TS  : MLTREE_STREAM (* where T = I.T *)
+                   where type T.Basis.cond = I.T.Basis.cond
+                     and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                     and type T.Basis.ext = I.T.Basis.ext
+                     and type T.Basis.fcond = I.T.Basis.fcond
+                     and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                     and type T.Constant.const = I.T.Constant.const
+                     and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                     and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                     and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                     and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                     and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                     and type T.Region.region = I.T.Region.region
+                     and type T.ccexp = I.T.ccexp
+                     and type T.fexp = I.T.fexp
+                     (* and type T.labexp = I.T.labexp *)
+                     and type T.mlrisc = I.T.mlrisc
+                     and type T.oper = I.T.oper
+                     and type T.rep = I.T.rep
+	             and type T.rexp = I.T.rexp
+                     and type T.stm = I.T.stm
+   structure CFG : CONTROL_FLOW_GRAPH (* where I = I and P = TS.S.P *)
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
+                    where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                      and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                      and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                      and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                      and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                      and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                      and type P.T.Constant.const = TS.S.P.T.Constant.const
+                      and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                      and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                      and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                      and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                      and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                      and type P.T.Region.region = TS.S.P.T.Region.region
+                      and type P.T.ccexp = TS.S.P.T.ccexp
+                      and type P.T.fexp = TS.S.P.T.fexp
+                      (* and type P.T.labexp = TS.S.P.T.labexp *)
+                      and type P.T.mlrisc = TS.S.P.T.mlrisc
+                      and type P.T.oper = TS.S.P.T.oper
+                      and type P.T.rep = TS.S.P.T.rep
+                      and type P.T.rexp = TS.S.P.T.rexp
+                      and type P.T.stm = TS.S.P.T.stm
   ) : SPARCCOMP_INSTR_EXT = 
 struct
     structure CFG = CFG
diff --git a/sparc/mltree/sparc.sml b/sparc/mltree/sparc.sml
index b8e7e40..403e89c 100644
--- a/sparc/mltree/sparc.sml
+++ b/sparc/mltree/sparc.sml
@@ -14,12 +14,72 @@
 
 functor Sparc
   (structure SparcInstr : SPARCINSTR
-   structure PseudoInstrs : SPARC_PSEUDO_INSTR 
-   			where I = SparcInstr
-   structure ExtensionComp : MLTREE_EXTENSION_COMP
-   			where I = SparcInstr
-			  and T = SparcInstr.T
-
+   structure PseudoInstrs : SPARC_PSEUDO_INSTR (* where I = SparcInstr *)
+                            where type I.Constant.const = SparcInstr.Constant.const
+                              and type I.Region.region = SparcInstr.Region.region
+                              and type I.T.Basis.cond = SparcInstr.T.Basis.cond
+                              and type I.T.Basis.div_rounding_mode = SparcInstr.T.Basis.div_rounding_mode
+                              and type I.T.Basis.ext = SparcInstr.T.Basis.ext
+                              and type I.T.Basis.fcond = SparcInstr.T.Basis.fcond
+                              and type I.T.Basis.rounding_mode = SparcInstr.T.Basis.rounding_mode
+                              and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) SparcInstr.T.Extension.ccx
+                              and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) SparcInstr.T.Extension.fx
+                              and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) SparcInstr.T.Extension.rx
+                              and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) SparcInstr.T.Extension.sx
+                              and type I.T.I.div_rounding_mode = SparcInstr.T.I.div_rounding_mode
+                              and type I.T.ccexp = SparcInstr.T.ccexp
+                              and type I.T.fexp = SparcInstr.T.fexp
+                              (* and type I.T.labexp = SparcInstr.T.labexp *)
+                              and type I.T.mlrisc = SparcInstr.T.mlrisc
+                              and type I.T.oper = SparcInstr.T.oper
+                              and type I.T.rep = SparcInstr.T.rep
+                              and type I.T.rexp = SparcInstr.T.rexp
+                              and type I.T.stm = SparcInstr.T.stm
+                              and type I.arith = SparcInstr.arith
+                              and type I.branch = SparcInstr.branch
+                              and type I.cc = SparcInstr.cc
+                              and type I.ea = SparcInstr.ea
+                              and type I.farith1 = SparcInstr.farith1
+                              and type I.farith2 = SparcInstr.farith2
+                              and type I.fbranch = SparcInstr.fbranch
+                              and type I.fcmp = SparcInstr.fcmp
+                              and type I.fload = SparcInstr.fload
+                              and type I.fsize = SparcInstr.fsize
+                              and type I.fstore = SparcInstr.fstore
+                              and type I.instr = SparcInstr.instr
+                              and type I.instruction = SparcInstr.instruction
+                              and type I.load = SparcInstr.load
+                              and type I.operand = SparcInstr.operand
+                              and type I.prediction = SparcInstr.prediction
+                              and type I.rcond = SparcInstr.rcond
+                              and type I.shift = SparcInstr.shift
+                              and type I.store = SparcInstr.store
+   structure ExtensionComp : MLTREE_EXTENSION_COMP (* where I = SparcInstr and T = SparcInstr.T *)
+                             where type I.addressing_mode = SparcInstr.addressing_mode
+                               and type I.ea = SparcInstr.ea
+                               and type I.instr = SparcInstr.instr
+                               and type I.instruction = SparcInstr.instruction
+                               and type I.operand = SparcInstr.operand
+                             where type T.Basis.cond = SparcInstr.T.Basis.cond
+                               and type T.Basis.div_rounding_mode = SparcInstr.T.Basis.div_rounding_mode
+                               and type T.Basis.ext = SparcInstr.T.Basis.ext
+                               and type T.Basis.fcond = SparcInstr.T.Basis.fcond
+                               and type T.Basis.rounding_mode = SparcInstr.T.Basis.rounding_mode
+                               and type T.Constant.const = SparcInstr.T.Constant.const
+                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) SparcInstr.T.Extension.ccx
+                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) SparcInstr.T.Extension.fx
+                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) SparcInstr.T.Extension.rx
+                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) SparcInstr.T.Extension.sx
+                               and type T.I.div_rounding_mode = SparcInstr.T.I.div_rounding_mode
+                               and type T.Region.region = SparcInstr.T.Region.region
+                               and type T.ccexp = SparcInstr.T.ccexp
+                               and type T.fexp = SparcInstr.T.fexp
+                               (* and type T.labexp = SparcInstr.T.labexp *)
+                               and type T.mlrisc = SparcInstr.T.mlrisc
+                               and type T.oper = SparcInstr.T.oper
+                               and type T.rep = SparcInstr.T.rep
+                               and type T.rexp = SparcInstr.T.rexp
+                               and type T.stm = SparcInstr.T.stm
 			  
    (* 
     * The client should also specify these parameters.
@@ -76,7 +136,8 @@ struct
                             val rep = NEITHER 
                            )
 
-  functor Multiply32 = MLTreeMult
+  (* signed, trapping version of multiply and divide *)
+  structure Mult32 = MLTreeMult
     (structure I = I
      structure T = T
      structure CB = CellsBasis
@@ -89,54 +150,85 @@ struct
      fun slli{r,i,d} = [I.shift{s=I.SLL,r=r,i=I.IMMED i,d=d}]
      fun srli{r,i,d} = [I.shift{s=I.SRL,r=r,i=I.IMMED i,d=d}]
      fun srai{r,i,d} = [I.shift{s=I.SRA,r=r,i=I.IMMED i,d=d}]
-    )
 
-  functor Multiply64 = MLTreeMult
+     val trapping = true
+     val multCost = multCost
+     fun addv{r1,r2,d} =
+         I.arith{a=I.ADDCC,r=r1,i=I.REG r2,d=d}::PseudoInstrs.overflowtrap32
+     fun subv{r1,r2,d} =
+         I.arith{a=I.SUBCC,r=r1,i=I.REG r2,d=d}::PseudoInstrs.overflowtrap32
+     val sh1addv = NONE
+     val sh2addv = NONE
+     val sh3addv = NONE
+
+     val signed = true)
+
+  (* unsigned, non-trapping version of multiply and divide *)
+  structure Mulu32 = MLTreeMult
     (structure I = I
      structure T = T
      structure CB = CellsBasis
      type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
      type argi = {r:CB.cell,i:int,d:CB.cell}
       
-     val intTy = 64    
+     val intTy = 32
+     fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}
+     fun slli{r,i,d} = [I.shift{s=I.SLL,r=r,i=I.IMMED i,d=d}]
+     fun srli{r,i,d} = [I.shift{s=I.SRL,r=r,i=I.IMMED i,d=d}]
+     fun srai{r,i,d} = [I.shift{s=I.SRA,r=r,i=I.IMMED i,d=d}]
+
+     val trapping = false
+     val multCost = muluCost
+     fun addv{r1,r2,d} = [I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}]
+     fun subv{r1,r2,d} = [I.arith{a=I.SUB,r=r1,i=I.REG r2,d=d}]
+     val sh1addv = NONE 
+     val sh2addv = NONE 
+     val sh3addv = NONE 
+
+     val signed = false)
+
+  (* signed, non-trapping version of multiply and divide *)
+  structure Muls32 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     val intTy = 32
+     fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}
+     fun slli{r,i,d} = [I.shift{s=I.SLL,r=r,i=I.IMMED i,d=d}]
+     fun srli{r,i,d} = [I.shift{s=I.SRL,r=r,i=I.IMMED i,d=d}]
+     fun srai{r,i,d} = [I.shift{s=I.SRA,r=r,i=I.IMMED i,d=d}]
+
+     val trapping = false
+     val multCost = muluCost
+     fun addv{r1,r2,d} = [I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}]
+     fun subv{r1,r2,d} = [I.arith{a=I.SUB,r=r1,i=I.REG r2,d=d}]
+     val sh1addv = NONE 
+     val sh2addv = NONE 
+     val sh3addv = NONE 
+
+     val signed = true)
+
+  (* signed, trapping version of multiply and divide *)
+  structure Mult64 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     val intTy = 64
      fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
      fun add{r1,r2,d} = I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}
      fun slli{r,i,d} = [I.shift{s=I.SLLX,r=r,i=I.IMMED i,d=d}]
      fun srli{r,i,d} = [I.shift{s=I.SRLX,r=r,i=I.IMMED i,d=d}]
      fun srai{r,i,d} = [I.shift{s=I.SRAX,r=r,i=I.IMMED i,d=d}]
-    )
 
-  (* signed, trapping version of multiply and divide *)
-  structure Mult32 = Multiply32
-    (val trapping = true
-     val multCost = multCost 
-     fun addv{r1,r2,d} = 
-         I.arith{a=I.ADDCC,r=r1,i=I.REG r2,d=d}::PseudoInstrs.overflowtrap32 
-     fun subv{r1,r2,d} = 
-         I.arith{a=I.SUBCC,r=r1,i=I.REG r2,d=d}::PseudoInstrs.overflowtrap32 
-     val sh1addv = NONE 
-     val sh2addv = NONE 
-     val sh3addv = NONE 
-    )
-    (val signed = true)
-
-  (* unsigned, non-trapping version of multiply and divide *)
-  functor Mul32 = Multiply32
-    (val trapping = false
-     val multCost = muluCost
-     fun addv{r1,r2,d} = [I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}]
-     fun subv{r1,r2,d} = [I.arith{a=I.SUB,r=r1,i=I.REG r2,d=d}]
-     val sh1addv = NONE 
-     val sh2addv = NONE 
-     val sh3addv = NONE 
-    )
-  structure Mulu32 = Mul32(val signed = false)
-
-  structure Muls32 = Mul32(val signed = true)
-
-  (* signed, trapping version of multiply and divide *)
-  structure Mult64 = Multiply64
-    (val trapping = true
+     val trapping = true
      val multCost = multCost 
      fun addv{r1,r2,d} = 
          I.arith{a=I.ADDCC,r=r1,i=I.REG r2,d=d}::PseudoInstrs.overflowtrap64 
@@ -145,22 +237,58 @@ struct
      val sh1addv = NONE 
      val sh2addv = NONE 
      val sh3addv = NONE 
-    )
-    (val signed = true)
+
+     val signed = true)
 
   (* unsigned, non-trapping version of multiply and divide *)
-  functor Mul64 = Multiply64
-    (val trapping = false
+  structure Mulu64 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     val intTy = 64
+     fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}
+     fun slli{r,i,d} = [I.shift{s=I.SLLX,r=r,i=I.IMMED i,d=d}]
+     fun srli{r,i,d} = [I.shift{s=I.SRLX,r=r,i=I.IMMED i,d=d}]
+     fun srai{r,i,d} = [I.shift{s=I.SRAX,r=r,i=I.IMMED i,d=d}]
+
+     val trapping = false
      val multCost = muluCost
      fun addv{r1,r2,d} = [I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}]
      fun subv{r1,r2,d} = [I.arith{a=I.SUB,r=r1,i=I.REG r2,d=d}]
      val sh1addv = NONE 
      val sh2addv = NONE 
      val sh3addv = NONE 
-    )
-  structure Mulu64 = Mul64(val signed = false)
 
-  structure Muls64 = Mul64(val signed = true)
+     val signed = false)
+
+  (* signed, non-trapping version of multiply and divide *)
+  structure Muls64 = MLTreeMult
+    (structure I = I
+     structure T = T
+     structure CB = CellsBasis
+     type arg  = {r1:CB.cell,r2:CB.cell,d:CB.cell}
+     type argi = {r:CB.cell,i:int,d:CB.cell}
+
+     val intTy = 64
+     fun mov{r,d} = COPY{dst=[d],src=[r],tmp=NONE}
+     fun add{r1,r2,d} = I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}
+     fun slli{r,i,d} = [I.shift{s=I.SLLX,r=r,i=I.IMMED i,d=d}]
+     fun srli{r,i,d} = [I.shift{s=I.SRLX,r=r,i=I.IMMED i,d=d}]
+     fun srai{r,i,d} = [I.shift{s=I.SRAX,r=r,i=I.IMMED i,d=d}]
+
+     val trapping = false
+     val multCost = muluCost
+     fun addv{r1,r2,d} = [I.arith{a=I.ADD,r=r1,i=I.REG r2,d=d}]
+     fun subv{r1,r2,d} = [I.arith{a=I.SUB,r=r1,i=I.REG r2,d=d}]
+     val sh1addv = NONE
+     val sh2addv = NONE
+     val sh3addv = NONE
+
+     val signed = false)
 
   datatype commutative = COMMUTE | NOCOMMUTE
   datatype cc = REG    (* write to register *)
@@ -215,7 +343,12 @@ struct
         | rcond T.GT  = I.RGZ
         | rcond _ = error "rcond"
 
-      fun signedCmp(T.LT | T.LE | T.EQ | T.NE | T.GE | T.GT) = true
+      fun signedCmp T.LT = true
+        | signedCmp T.LE = true
+        | signedCmp T.EQ = true
+        | signedCmp T.NE = true
+        | signedCmp T.GE = true
+        | signedCmp T.GT = true
         | signedCmp _ = false
 
       fun fcond T.==  = I.FBE
@@ -367,8 +500,9 @@ struct
           mark(I.FPop2{a=a,r1=fexpr e1,r2=fexpr e2,d=d},an)
 
       (* convert an expression into an addressing mode *)
-      and addr(T.ADD(ty, (T.ADD (_, e, T.LI n)|
-			  T.ADD (_, T.LI n, e)), T.LI n')) =
+      and addr(T.ADD(ty, T.ADD (_, e, T.LI n), T.LI n')) =
+	  addr(T.ADD (ty, e, T.LI (T.I.ADD (ty, n, n'))))
+	| addr(T.ADD(ty, T.ADD (_, T.LI n, e), T.LI n')) =
 	  addr(T.ADD (ty, e, T.LI (T.I.ADD (ty, n, n'))))
 	| addr(T.ADD(ty, T.SUB (_, e, T.LI n), T.LI n')) =
 	  addr(T.ADD (ty, e, T.LI (T.I.SUB (ty, n', n))))
@@ -443,8 +577,9 @@ struct
       and branch(T.CMP(ty,cond,a,b),lab,an) =
           let val (cond,a,b) =
                   case a of
-                    (T.LI _ | T.CONST _ | T.LABEL _) => 
-                      (T.Basis.swapCond cond,b,a)
+                    T.LI _ => (T.Basis.swapCond cond,b,a)
+                  | T.CONST _ => (T.Basis.swapCond cond,b,a)
+                  | T.LABEL _ => (T.Basis.swapCond cond,b,a)
                   | _ => (cond,a,b)
           in  if V9 then
                  branchV9(cond,a,b,lab,an)
diff --git a/visualization/cfgViewer.sml b/visualization/cfgViewer.sml
index 65c6251..877f496 100644
--- a/visualization/cfgViewer.sml
+++ b/visualization/cfgViewer.sml
@@ -1,8 +1,13 @@
 functor CFGViewer
    (structure CFG : CONTROL_FLOW_GRAPH
     structure GraphViewer : GRAPH_VIEWER
-    structure Asm	  : INSTRUCTION_EMITTER where I = CFG.I)
-      : sig
+    structure Asm	  : INSTRUCTION_EMITTER (* where I = CFG.I *)
+                            where type I.addressing_mode = CFG.I.addressing_mode
+                              and type I.ea = CFG.I.ea
+                              and type I.instr = CFG.I.instr
+                              and type I.instruction = CFG.I.instruction
+                              and type I.operand = CFG.I.operand
+   ) : sig
 	    val view : CFG.cfg -> unit
 	end =
 struct
diff --git a/x86/backpatch/x86Jumps.sml b/x86/backpatch/x86Jumps.sml
index 120792e..4871ee2 100644
--- a/x86/backpatch/x86Jumps.sml
+++ b/x86/backpatch/x86Jumps.sml
@@ -5,9 +5,72 @@
 
 functor X86Jumps
   (structure Instr : X86INSTR
-   structure Eval : MLTREE_EVAL where T = Instr.T
-   structure Shuffle : X86SHUFFLE where I = Instr
-   structure MCEmitter : MC_EMIT where I = Instr) : SDI_JUMPS = 
+   structure Eval : MLTREE_EVAL (* where T = Instr.T *)
+                    where type T.Basis.cond = Instr.T.Basis.cond
+                      and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                      and type T.Basis.ext = Instr.T.Basis.ext
+                      and type T.Basis.fcond = Instr.T.Basis.fcond
+                      and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                      and type T.Constant.const = Instr.T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                      and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                      and type T.Region.region = Instr.T.Region.region
+                      and type T.ccexp = Instr.T.ccexp
+                      and type T.fexp = Instr.T.fexp
+                      (* and type T.labexp = Instr.T.labexp *)
+                      and type T.mlrisc = Instr.T.mlrisc
+                      and type T.oper = Instr.T.oper
+                      and type T.rep = Instr.T.rep
+                      and type T.rexp = Instr.T.rexp
+                      and type T.stm = Instr.T.stm
+   structure Shuffle : X86SHUFFLE (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         (* and type I.addressing_mode = Instr.addressing_mode *)
+                         and type I.binaryOp = Instr.binaryOp
+                         and type I.bitOp = Instr.bitOp
+                         and type I.cond = Instr.cond
+                         and type I.fbinOp = Instr.fbinOp
+                         and type I.fenvOp = Instr.fenvOp
+                         and type I.fibinOp = Instr.fibinOp
+                         and type I.fsize = Instr.fsize
+                         and type I.funOp = Instr.funOp
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.isize = Instr.isize
+                         and type I.move = Instr.move
+                         and type I.multDivOp = Instr.multDivOp
+                         and type I.operand = Instr.operand
+                         and type I.shiftOp = Instr.shiftOp
+                         and type I.unaryOp = Instr.unaryOp
+   structure MCEmitter : MC_EMIT (* where I = Instr *)
+                         where type I.addressing_mode = Instr.addressing_mode
+                           and type I.ea = Instr.ea
+                           and type I.instr = Instr.instr
+                           and type I.instruction = Instr.instruction
+                           and type I.operand = Instr.operand
+  ) : SDI_JUMPS =
 struct
   structure I = Instr
   structure C = I.C
@@ -39,14 +102,20 @@ struct
 	   | I.BINARY{src, dst, ...} => operand src orelse operand dst
 	   | I.MOVE{src, dst, ...} => operand src orelse operand dst
 	   | I.LEA{addr, ...} => operand addr
-	   | ( I.CMPL arg | I.CMPW arg | I.CMPB arg 
-	     | I.TESTL arg | I.TESTW arg | I.TESTB arg) => cmptest arg
+	   | I.CMPL arg => cmptest arg
+	   | I.CMPW arg => cmptest arg
+	   | I.CMPB arg => cmptest arg
+	   | I.TESTL arg => cmptest arg
+	   | I.TESTW arg => cmptest arg
+	   | I.TESTB arg => cmptest arg
 	   | I.MULTDIV{src, ...} => operand src
 	   | I.MUL3{src1, ...} => operand src1
 	   | I.UNARY{opnd, ...} => operand opnd
 	   | I.SET{opnd, ...} => operand opnd
 	   | I.CMOV{src, dst, ...} => operand src 
-	   | (I.PUSHL opnd | I.PUSHW opnd | I.PUSHB opnd) => operand opnd
+	   | I.PUSHL opnd => operand opnd
+	   | I.PUSHW opnd => operand opnd
+	   | I.PUSHB opnd => operand opnd
 	   | I.POP opnd =>  operand opnd
 	   | I.FSTPT opnd => operand opnd
 	   | I.FSTPL opnd => operand opnd
diff --git a/x86/c-calls/ia32-svid.sml b/x86/c-calls/ia32-svid.sml
index 2a70220..57159fa 100644
--- a/x86/c-calls/ia32-svid.sml
+++ b/x86/c-calls/ia32-svid.sml
@@ -399,7 +399,8 @@ functor IA32SVID_CCalls (
 	 * differences there might be between the SVID and Windows ABIs. (JHR)
 	 *)
 	  val calleePops = (case #conv proto
-		 of (""|"ccall") => false
+		 of "" => false
+	          | "ccall" => false
 		  | "stdcall" => true
 		  | conv => error (concat [
 			"unknown calling convention \"", String.toString conv, "\""
diff --git a/x86/emit/x86Asm.sml b/x86/emit/x86Asm.sml
index 04ac150..e4d02b4 100644
--- a/x86/emit/x86Asm.sml
+++ b/x86/emit/x86Asm.sml
@@ -6,15 +6,126 @@
 
 
 functor X86AsmEmitter(structure S : INSTRUCTION_STREAM
-                      structure Instr : X86INSTR
-                         where T = S.P.T
-                      structure Shuffle : X86SHUFFLE
-                         where I = Instr
-                      structure MLTreeEval : MLTREE_EVAL
-                         where T = Instr.T
+                      structure Instr : X86INSTR (* where T = S.P.T *)
+                                        where type T.Basis.cond = S.P.T.Basis.cond
+                                          and type T.Basis.div_rounding_mode = S.P.T.Basis.div_rounding_mode
+                                          and type T.Basis.ext = S.P.T.Basis.ext
+                                          and type T.Basis.fcond = S.P.T.Basis.fcond
+                                          and type T.Basis.rounding_mode = S.P.T.Basis.rounding_mode
+                                          and type T.Constant.const = S.P.T.Constant.const
+                                          and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) S.P.T.Extension.ccx
+                                          and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) S.P.T.Extension.fx
+                                          and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) S.P.T.Extension.rx
+                                          and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) S.P.T.Extension.sx
+                                          and type T.I.div_rounding_mode = S.P.T.I.div_rounding_mode
+                                          and type T.Region.region = S.P.T.Region.region
+                                          and type T.ccexp = S.P.T.ccexp
+                                          and type T.fexp = S.P.T.fexp
+                                          (* and type T.labexp = S.P.T.labexp *)
+                                          and type T.mlrisc = S.P.T.mlrisc
+                                          and type T.oper = S.P.T.oper
+                                          and type T.rep = S.P.T.rep
+                                          and type T.rexp = S.P.T.rexp
+                                          and type T.stm = S.P.T.stm
+                      structure Shuffle : X86SHUFFLE (* where I = Instr *)
+                                          where type I.Constant.const = Instr.Constant.const
+                                            and type I.Region.region = Instr.Region.region
+                                            and type I.T.Basis.cond = Instr.T.Basis.cond
+                                            and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                            and type I.T.Basis.ext = Instr.T.Basis.ext
+                                            and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                            and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                            and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                            and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                            and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                            and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                            and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                            and type I.T.ccexp = Instr.T.ccexp
+                                            and type I.T.fexp = Instr.T.fexp
+                                            (* and type I.T.labexp = Instr.T.labexp *)
+                                            and type I.T.mlrisc = Instr.T.mlrisc
+                                            and type I.T.oper = Instr.T.oper
+                                            and type I.T.rep = Instr.T.rep
+                                            and type I.T.rexp = Instr.T.rexp
+                                            and type I.T.stm = Instr.T.stm
+                                            (* and type I.addressing_mode = Instr.addressing_mode *)
+                                            and type I.binaryOp = Instr.binaryOp
+                                            and type I.bitOp = Instr.bitOp
+                                            and type I.cond = Instr.cond
+                                            and type I.fbinOp = Instr.fbinOp
+                                            and type I.fenvOp = Instr.fenvOp
+                                            and type I.fibinOp = Instr.fibinOp
+                                            and type I.fsize = Instr.fsize
+                                            and type I.funOp = Instr.funOp
+                                            and type I.instr = Instr.instr
+                                            and type I.instruction = Instr.instruction
+                                            and type I.isize = Instr.isize
+                                            and type I.move = Instr.move
+                                            and type I.multDivOp = Instr.multDivOp
+                                            and type I.operand = Instr.operand
+                                            and type I.shiftOp = Instr.shiftOp
+                                            and type I.unaryOp = Instr.unaryOp
+                      structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                                             where type T.Basis.cond = Instr.T.Basis.cond
+                                               and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                               and type T.Basis.ext = Instr.T.Basis.ext
+                                               and type T.Basis.fcond = Instr.T.Basis.fcond
+                                               and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                               and type T.Constant.const = Instr.T.Constant.const
+                                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                               and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                               and type T.Region.region = Instr.T.Region.region
+                                               and type T.ccexp = Instr.T.ccexp
+                                               and type T.fexp = Instr.T.fexp
+                                               (* and type T.labexp = Instr.T.labexp *)
+                                               and type T.mlrisc = Instr.T.mlrisc
+                                               and type T.oper = Instr.T.oper
+                                               and type T.rep = Instr.T.rep
+                                               and type T.rexp = Instr.T.rexp
+                                               and type T.stm = Instr.T.stm
 
 (*#line 512.7 "x86/x86.mdl"*)
-                      structure MemRegs : MEMORY_REGISTERS where I=Instr
+                      structure MemRegs : MEMORY_REGISTERS (* where I = Instr *)
+                                          where type I.Constant.const = Instr.Constant.const
+                                            and type I.Region.region = Instr.Region.region
+                                            and type I.T.Basis.cond = Instr.T.Basis.cond
+                                            and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                                            and type I.T.Basis.ext = Instr.T.Basis.ext
+                                            and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                                            and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                                            and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                                            and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                                            and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                                            and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                                            and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                                            and type I.T.ccexp = Instr.T.ccexp
+                                            and type I.T.fexp = Instr.T.fexp
+                                            (* and type I.T.labexp = Instr.T.labexp *)
+                                            and type I.T.mlrisc = Instr.T.mlrisc
+                                            and type I.T.oper = Instr.T.oper
+                                            and type I.T.rep = Instr.T.rep
+                                            and type I.T.rexp = Instr.T.rexp
+                                            and type I.T.stm = Instr.T.stm
+                                            (* and type I.addressing_mode = Instr.addressing_mode *)
+                                            and type I.binaryOp = Instr.binaryOp
+                                            and type I.bitOp = Instr.bitOp
+                                            and type I.cond = Instr.cond
+                                            and type I.fbinOp = Instr.fbinOp
+                                            and type I.fenvOp = Instr.fenvOp
+                                            and type I.fibinOp = Instr.fibinOp
+                                            and type I.fsize = Instr.fsize
+                                            and type I.funOp = Instr.funOp
+                                            and type I.instr = Instr.instr
+                                            and type I.instruction = Instr.instruction
+                                            and type I.isize = Instr.isize
+                                            and type I.move = Instr.move
+                                            and type I.multDivOp = Instr.multDivOp
+                                            and type I.operand = Instr.operand
+                                            and type I.shiftOp = Instr.shiftOp
+                                            and type I.unaryOp = Instr.unaryOp
 
 (*#line 513.7 "x86/x86.mdl"*)
                       val memRegBase : CellsBasis.cell option
@@ -370,7 +481,8 @@ struct
            val n = size fbinOp
        in 
           (case Char.toLower (String.sub (fbinOp, n - 1)) of
-            (#"s" | #"l") => String.substring (fbinOp, 0, n - 1)
+            #"s" => String.substring (fbinOp, 0, n - 1)
+          | #"l" => String.substring (fbinOp, 0, n - 1)
           | _ => fbinOp
           )
        end
@@ -511,8 +623,39 @@ struct
            emit_lsrc lsrc )
        | I.BINARY{binOp, src, dst} => 
          (case (src, binOp) of
-           (I.Direct _, (I.SARL | I.SHRL | I.SHLL | I.SARW | I.SHRW | I.SHLW | I.SARB | I.SHRB | I.SHLB)) => 
-              
+           (I.Direct _, (I.SARL)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SHRL)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SHLL)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SARW)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SHRW)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SHLW)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SARB)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SHRB)) =>
+           ( emit_binaryOp binOp;
+             emit "\t%cl, ";
+             emit_dst dst )
+         | (I.Direct _, (I.SHLB)) =>
            ( emit_binaryOp binOp; 
              emit "\t%cl, "; 
              emit_dst dst )
diff --git a/x86/flowgraph/x86-darwin-pseudo-ops.sml b/x86/flowgraph/x86-darwin-pseudo-ops.sml
index 2b3db45..d848c1c 100644
--- a/x86/flowgraph/x86-darwin-pseudo-ops.sml
+++ b/x86/flowgraph/x86-darwin-pseudo-ops.sml
@@ -7,7 +7,27 @@
 functor X86DarwinPseudoOps (
 
     structure T : MLTREE
-    structure MLTreeEval : MLTREE_EVAL  where T = T
+    structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                           where type T.Basis.cond = T.Basis.cond
+                             and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                             and type T.Basis.ext = T.Basis.ext
+                             and type T.Basis.fcond = T.Basis.fcond
+                             and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                             and type T.Constant.const = T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                             and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                             and type T.Region.region = T.Region.region
+                             and type T.ccexp = T.ccexp
+                             and type T.fexp = T.fexp
+                             (* and type T.labexp = T.labexp *)
+                             and type T.mlrisc = T.mlrisc
+                             and type T.oper = T.oper
+                             and type T.rep = T.rep
+                             and type T.rexp = T.rexp
+                             and type T.stm = T.stm
 
   ) : PSEUDO_OPS_BASIS = struct
 
diff --git a/x86/flowgraph/x86GasPseudoOps.sml b/x86/flowgraph/x86GasPseudoOps.sml
index 5b441e1..2e79f3e 100644
--- a/x86/flowgraph/x86GasPseudoOps.sml
+++ b/x86/flowgraph/x86GasPseudoOps.sml
@@ -5,7 +5,27 @@
  *)
 functor X86GasPseudoOps 
    ( structure T : MLTREE
-     structure MLTreeEval : MLTREE_EVAL  where T = T
+     structure MLTreeEval : MLTREE_EVAL (* where T = T *)
+                            where type T.Basis.cond = T.Basis.cond
+                              and type T.Basis.div_rounding_mode = T.Basis.div_rounding_mode
+                              and type T.Basis.ext = T.Basis.ext
+                              and type T.Basis.fcond = T.Basis.fcond
+                              and type T.Basis.rounding_mode = T.Basis.rounding_mode
+                              and type T.Constant.const = T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) T.Extension.sx
+                              and type T.I.div_rounding_mode = T.I.div_rounding_mode
+                              and type T.Region.region = T.Region.region
+                              and type T.ccexp = T.ccexp
+                              and type T.fexp = T.fexp
+                              (* and type T.labexp = T.labexp *)
+                              and type T.mlrisc = T.mlrisc
+                              and type T.oper = T.oper
+                              and type T.rep = T.rep
+                              and type T.rexp = T.rexp
+                              and type T.stm = T.stm
     ) : PSEUDO_OPS_BASIS = 
 
 struct
diff --git a/x86/instructions/x86Instr.sml b/x86/instructions/x86Instr.sml
index c9827a7..fdd52b4 100644
--- a/x86/instructions/x86Instr.sml
+++ b/x86/instructions/x86Instr.sml
@@ -8,7 +8,16 @@
 signature X86INSTR =
 sig
    structure C : X86CELLS
-   structure CB : CELLS_BASIS = CellsBasis
+   structure CB : CELLS_BASIS (* = CellsBasis *)
+                  where type CellSet.cellset = CellsBasis.CellSet.cellset
+                    and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                    and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                    and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                    and type cell = CellsBasis.cell
+                    and type cellColor = CellsBasis.cellColor
+                    and type cellkind = CellsBasis.cellkind
+                    and type cellkindDesc = CellsBasis.cellkindDesc
+                    and type cellkindInfo = CellsBasis.cellkindInfo
    structure T : MLTREE
    structure Constant: CONSTANT
    structure Region : REGION
diff --git a/x86/instructions/x86Peephole.peep b/x86/instructions/x86Peephole.peep
index 0859bd3..2a335ac 100644
--- a/x86/instructions/x86Peephole.peep
+++ b/x86/instructions/x86Peephole.peep
@@ -20,7 +20,27 @@ in
 functor X86Peephole
    (structure Instr : X86INSTR
     structure Eval  : MLTREE_EVAL
-      sharing Instr.T = Eval.T
+      (* sharing Instr.T = Eval.T *)
+      where type T.Basis.cond = Instr.T.Basis.cond
+        and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+        and type T.Basis.ext = Instr.T.Basis.ext
+        and type T.Basis.fcond = Instr.T.Basis.fcond
+        and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+        and type T.Constant.const = Instr.T.Constant.const
+        and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+        and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+        and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+        and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+        and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+        and type T.Region.region = Instr.T.Region.region
+        and type T.ccexp = Instr.T.ccexp
+        and type T.fexp = Instr.T.fexp
+        (* and type T.labexp = Instr.T.labexp *)
+        and type T.mlrisc = Instr.T.mlrisc
+        and type T.oper = Instr.T.oper
+        and type T.rep = Instr.T.rep
+        and type T.rexp = Instr.T.rexp
+        and type T.stm = Instr.T.stm
    ) : PEEPHOLE =
 struct
    structure I = Instr
diff --git a/x86/instructions/x86Peephole.sml b/x86/instructions/x86Peephole.sml
index 66670c1..fe27654 100644
--- a/x86/instructions/x86Peephole.sml
+++ b/x86/instructions/x86Peephole.sml
@@ -12,7 +12,27 @@ functor X86Peephole(
                     structure Eval : MLTREE_EVAL
 
 (*#line 23.7 "x86Peephole.peep"*)
-                    sharing Instr.T = Eval.T
+                    (* sharing Instr.T = Eval.T *)
+                    where type T.Basis.cond = Instr.T.Basis.cond
+                      and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                      and type T.Basis.ext = Instr.T.Basis.ext
+                      and type T.Basis.fcond = Instr.T.Basis.fcond
+                      and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                      and type T.Constant.const = Instr.T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                      and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                      and type T.Region.region = Instr.T.Region.region
+                      and type T.ccexp = Instr.T.ccexp
+                      and type T.fexp = Instr.T.fexp
+                      (* and type T.labexp = Instr.T.labexp *)
+                      and type T.mlrisc = Instr.T.mlrisc
+                      and type T.oper = Instr.T.oper
+                      and type T.rep = Instr.T.rep
+                      and type T.rexp = Instr.T.rexp
+                      and type T.stm = Instr.T.stm
                    ): PEEPHOLE =
 struct
 
diff --git a/x86/instructions/x86Props.sml b/x86/instructions/x86Props.sml
index 6cd50da..1b060fd 100644
--- a/x86/instructions/x86Props.sml
+++ b/x86/instructions/x86Props.sml
@@ -5,8 +5,48 @@
 
 functor X86Props
   (structure Instr : X86INSTR
-   structure MLTreeHash : MLTREE_HASH where T = Instr.T
-   structure MLTreeEval : MLTREE_EVAL where T = Instr.T
+   structure MLTreeHash : MLTREE_HASH (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
+   structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
   ) : INSN_PROPERTIES =
 struct
   structure I = Instr
@@ -230,8 +270,10 @@ struct
 	val uses = operandUse src
       in
 	case multDivOp
-	 of (I.IDIVL1 | I.DIVL1) => (eaxPair, C.edx::C.eax::uses)
-	  | (I.IMULL1 | I.MULL1) => (eaxPair, C.eax::uses)
+	 of I.IDIVL1 => (eaxPair, C.edx::C.eax::uses)
+	  | I.DIVL1 => (eaxPair, C.edx::C.eax::uses)
+	  | I.IMULL1 => (eaxPair, C.eax::uses)
+	  | I.MULL1 => (eaxPair, C.eax::uses)
       end
 
       fun unary opnd = (operandDef opnd, operandUse opnd)
@@ -249,8 +291,12 @@ struct
 	| I.MOVE{src, dst=I.MemReg r, ...} => ([r], operandUse src)
 	| I.MOVE{src, dst, ...} => ([], operandAcc(dst, operandUse src))
 	| I.LEA{r32, addr}      => ([r32], operandUse addr)
-	| ( I.CMPL arg | I.CMPW arg | I.CMPB arg
-	  | I.TESTL arg | I.TESTW arg | I.TESTB arg ) => cmptest arg 
+	| I.CMPL arg => cmptest arg
+	| I.CMPW arg => cmptest arg
+	| I.CMPB arg => cmptest arg
+	| I.TESTL arg => cmptest arg
+	| I.TESTW arg => cmptest arg
+	| I.TESTB arg => cmptest arg
 	| I.BITOP{lsrc, rsrc, ...} => cmptest{lsrc=lsrc,rsrc=rsrc}
 	| I.BINARY{binOp=I.XORL,src=I.Direct rs,dst=I.Direct rd,...} =>   
 	     if CB.sameColor(rs,rd) then ([rd],[]) else ([rd],[rs,rd])
@@ -268,7 +314,9 @@ struct
 
 	| I.UNARY{opnd, ...}    => unary opnd
 	| I.SET{opnd, ...}      => unary opnd
-	| ( I.PUSHL arg | I.PUSHW arg | I.PUSHB arg ) => push arg
+	| I.PUSHL arg => push arg
+	| I.PUSHW arg => push arg
+	| I.PUSHB arg => push arg
 	| I.POP arg	      => (C.stackptrR::operandDef arg, [C.stackptrR])
 	| I.PUSHFD	      => espOnly()
 	| I.POPFD		      => espOnly()
diff --git a/x86/instructions/x86comp-instr-ext.sml b/x86/instructions/x86comp-instr-ext.sml
index d846378..7a0d5dd 100644
--- a/x86/instructions/x86comp-instr-ext.sml
+++ b/x86/instructions/x86comp-instr-ext.sml
@@ -6,11 +6,54 @@
  *)
 signature X86COMP_INSTR_EXT = sig
   structure I : X86INSTR
-  structure TS : MLTREE_STREAM
-		 where T = I.T
-  structure CFG : CONTROL_FLOW_GRAPH 
- 	         where I = I
-                   and P = TS.S.P
+  structure TS : MLTREE_STREAM (* where T = I.T *)
+                 where type T.Basis.cond = I.T.Basis.cond
+                   and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                   and type T.Basis.ext = I.T.Basis.ext
+                   and type T.Basis.fcond = I.T.Basis.fcond
+                   and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                   and type T.Constant.const = I.T.Constant.const
+                   and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                   and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                   and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                   and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                   and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                   and type T.Region.region = I.T.Region.region
+                   and type T.ccexp = I.T.ccexp
+                   and type T.fexp = I.T.fexp
+                   (* and type T.labexp = I.T.labexp *)
+                   and type T.mlrisc = I.T.mlrisc
+                   and type T.oper = I.T.oper
+                   and type T.rep = I.T.rep
+	           and type T.rexp = I.T.rexp
+                   and type T.stm = I.T.stm
+  structure CFG : CONTROL_FLOW_GRAPH (* where I = I and P = TS.S.P *)
+                  where type I.addressing_mode = I.addressing_mode
+                    and type I.ea = I.ea
+                    and type I.instr = I.instr
+                    and type I.instruction = I.instruction
+                    and type I.operand = I.operand
+                  where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                    and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                    and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                    and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                    and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                    and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                    and type P.T.Constant.const = TS.S.P.T.Constant.const
+                    and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                    and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                    and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                    and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                    and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                    and type P.T.Region.region = TS.S.P.T.Region.region
+                    and type P.T.ccexp = TS.S.P.T.ccexp
+                    and type P.T.fexp = TS.S.P.T.fexp
+                    (* and type P.T.labexp = TS.S.P.T.labexp *)
+                    and type P.T.mlrisc = TS.S.P.T.mlrisc
+                    and type P.T.oper = TS.S.P.T.oper
+                    and type P.T.rep = TS.S.P.T.rep
+                    and type P.T.rexp = TS.S.P.T.rexp
+                    and type P.T.stm = TS.S.P.T.stm
 
   type reducer = 
     (I.instruction, I.C.cellset, I.operand, I.addressing_mode, CFG.cfg) TS.reducer
@@ -27,11 +70,54 @@ end
 
 functor X86CompInstrExt
   ( structure I : X86INSTR
-    structure TS  : MLTREE_STREAM
-		   where T = I.T
-    structure CFG : CONTROL_FLOW_GRAPH 
-		   where P = TS.S.P
-		     and I = I
+    structure TS  : MLTREE_STREAM (* where T = I.T *)
+                    where type T.Basis.cond = I.T.Basis.cond
+                      and type T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                      and type T.Basis.ext = I.T.Basis.ext
+                      and type T.Basis.fcond = I.T.Basis.fcond
+                      and type T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                      and type T.Constant.const = I.T.Constant.const
+                      and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                      and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                      and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                      and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                      and type T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                      and type T.Region.region = I.T.Region.region
+                      and type T.ccexp = I.T.ccexp
+                      and type T.fexp = I.T.fexp
+                      (* and type T.labexp = I.T.labexp *)
+                      and type T.mlrisc = I.T.mlrisc
+                      and type T.oper = I.T.oper
+                      and type T.rep = I.T.rep
+                      and type T.rexp = I.T.rexp
+                      and type T.stm = I.T.stm
+    structure CFG : CONTROL_FLOW_GRAPH (* where P = TS.S.P and I = I *)
+                    where type P.Client.pseudo_op = TS.S.P.Client.pseudo_op
+                      and type P.T.Basis.cond = TS.S.P.T.Basis.cond
+                      and type P.T.Basis.div_rounding_mode = TS.S.P.T.Basis.div_rounding_mode
+                      and type P.T.Basis.ext = TS.S.P.T.Basis.ext
+                      and type P.T.Basis.fcond = TS.S.P.T.Basis.fcond
+                      and type P.T.Basis.rounding_mode = TS.S.P.T.Basis.rounding_mode
+                      and type P.T.Constant.const = TS.S.P.T.Constant.const
+                      and type ('s,'r,'f,'c) P.T.Extension.ccx = ('s,'r,'f,'c) TS.S.P.T.Extension.ccx
+                      and type ('s,'r,'f,'c) P.T.Extension.fx = ('s,'r,'f,'c) TS.S.P.T.Extension.fx
+                      and type ('s,'r,'f,'c) P.T.Extension.rx = ('s,'r,'f,'c) TS.S.P.T.Extension.rx
+                      and type ('s,'r,'f,'c) P.T.Extension.sx = ('s,'r,'f,'c) TS.S.P.T.Extension.sx
+                      and type P.T.I.div_rounding_mode = TS.S.P.T.I.div_rounding_mode
+                      and type P.T.Region.region = TS.S.P.T.Region.region
+                      and type P.T.ccexp = TS.S.P.T.ccexp
+                      and type P.T.fexp = TS.S.P.T.fexp
+                      (* and type P.T.labexp = TS.S.P.T.labexp *)
+                      and type P.T.mlrisc = TS.S.P.T.mlrisc
+                      and type P.T.oper = TS.S.P.T.oper
+                      and type P.T.rep = TS.S.P.T.rep
+                      and type P.T.rexp = TS.S.P.T.rexp
+                      and type P.T.stm = TS.S.P.T.stm
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
    ) : X86COMP_INSTR_EXT = 
 struct
   structure CFG = CFG
diff --git a/x86/mltree/x86-fp.sml b/x86/mltree/x86-fp.sml
index 60a8610..1383d06 100644
--- a/x86/mltree/x86-fp.sml
+++ b/x86/mltree/x86-fp.sml
@@ -53,27 +53,88 @@
  * -- Allen Leung (leunga@cs.nyu.edu)
  *) 
 
-local
+functor X86FP
+   (structure X86Instr  : X86INSTR
+    structure X86Props  : INSN_PROPERTIES (* where I = X86Instr *)
+                          where type I.addressing_mode = X86Instr.addressing_mode
+                            and type I.ea = X86Instr.ea
+                            and type I.instr = X86Instr.instr
+                            and type I.instruction = X86Instr.instruction
+                            and type I.operand = X86Instr.operand
+    structure Flowgraph : CONTROL_FLOW_GRAPH (* where I = X86Instr *)
+                          where type I.addressing_mode = X86Instr.addressing_mode
+                            and type I.ea = X86Instr.ea
+                            and type I.instr = X86Instr.instr
+                            and type I.instruction = X86Instr.instruction
+                            and type I.operand = X86Instr.operand
+    structure Liveness  : LIVENESS (* where CFG = Flowgraph *)
+                          where type CFG.I.addressing_mode = Flowgraph.I.addressing_mode
+                            and type CFG.I.ea = Flowgraph.I.ea
+                            and type CFG.I.instr = Flowgraph.I.instr
+                            and type CFG.I.instruction = Flowgraph.I.instruction
+                            and type CFG.I.operand = Flowgraph.I.operand
+                            and type CFG.P.Client.pseudo_op = Flowgraph.P.Client.pseudo_op
+                            and type CFG.P.T.Basis.cond = Flowgraph.P.T.Basis.cond
+                            and type CFG.P.T.Basis.div_rounding_mode = Flowgraph.P.T.Basis.div_rounding_mode
+                            and type CFG.P.T.Basis.ext = Flowgraph.P.T.Basis.ext
+                            and type CFG.P.T.Basis.fcond = Flowgraph.P.T.Basis.fcond
+                            and type CFG.P.T.Basis.rounding_mode = Flowgraph.P.T.Basis.rounding_mode
+                            and type CFG.P.T.Constant.const = Flowgraph.P.T.Constant.const
+                            and type ('s,'r,'f,'c) CFG.P.T.Extension.ccx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.ccx
+                            and type ('s,'r,'f,'c) CFG.P.T.Extension.fx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.fx
+                            and type ('s,'r,'f,'c) CFG.P.T.Extension.rx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.rx
+                            and type ('s,'r,'f,'c) CFG.P.T.Extension.sx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.sx
+                            and type CFG.P.T.I.div_rounding_mode = Flowgraph.P.T.I.div_rounding_mode
+                            and type CFG.P.T.Region.region = Flowgraph.P.T.Region.region
+                            and type CFG.P.T.ccexp = Flowgraph.P.T.ccexp
+                            and type CFG.P.T.fexp = Flowgraph.P.T.fexp
+                            (* and type CFG.P.T.labexp = Flowgraph.P.T.labexp *)
+                            and type CFG.P.T.mlrisc = Flowgraph.P.T.mlrisc
+                            and type CFG.P.T.oper = Flowgraph.P.T.oper
+                            and type CFG.P.T.rep = Flowgraph.P.T.rep
+                            and type CFG.P.T.rexp = Flowgraph.P.T.rexp
+                            and type CFG.P.T.stm = Flowgraph.P.T.stm
+                            and type CFG.block = Flowgraph.block
+                            and type CFG.block_kind = Flowgraph.block_kind
+                            and type CFG.edge_info = Flowgraph.edge_info
+                            and type CFG.edge_kind = Flowgraph.edge_kind
+                            and type CFG.info = Flowgraph.info
+    structure Asm       : INSTRUCTION_EMITTER (* where I = X86Instr and S.P = Flowgraph.P *)
+                          where type I.addressing_mode = X86Instr.addressing_mode
+                            and type I.ea = X86Instr.ea
+                            and type I.instr = X86Instr.instr
+                            and type I.instruction = X86Instr.instruction
+                            and type I.operand = X86Instr.operand
+                          where type S.P.Client.pseudo_op = Flowgraph.P.Client.pseudo_op
+                            and type S.P.T.Basis.cond = Flowgraph.P.T.Basis.cond
+                            and type S.P.T.Basis.div_rounding_mode = Flowgraph.P.T.Basis.div_rounding_mode
+                            and type S.P.T.Basis.ext = Flowgraph.P.T.Basis.ext
+                            and type S.P.T.Basis.fcond = Flowgraph.P.T.Basis.fcond
+                            and type S.P.T.Basis.rounding_mode = Flowgraph.P.T.Basis.rounding_mode
+                            and type S.P.T.Constant.const = Flowgraph.P.T.Constant.const
+                            and type ('s,'r,'f,'c) S.P.T.Extension.ccx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.ccx
+                            and type ('s,'r,'f,'c) S.P.T.Extension.fx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.fx
+                            and type ('s,'r,'f,'c) S.P.T.Extension.rx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.rx
+                            and type ('s,'r,'f,'c) S.P.T.Extension.sx = ('s,'r,'f,'c) Flowgraph.P.T.Extension.sx
+                            and type S.P.T.I.div_rounding_mode = Flowgraph.P.T.I.div_rounding_mode
+                            and type S.P.T.Region.region = Flowgraph.P.T.Region.region
+                            and type S.P.T.ccexp = Flowgraph.P.T.ccexp
+                            and type S.P.T.fexp = Flowgraph.P.T.fexp
+                            (* and type S.P.T.labexp = Flowgraph.P.T.labexp *)
+                            and type S.P.T.mlrisc = Flowgraph.P.T.mlrisc
+                            and type S.P.T.oper = Flowgraph.P.T.oper
+                            and type S.P.T.rep = Flowgraph.P.T.rep
+                            and type S.P.T.rexp = Flowgraph.P.T.rexp
+                            and type S.P.T.stm = Flowgraph.P.T.stm
+   ) : CFG_OPTIMIZATION =
+struct
    val debug = false         (* set this to true to debug this module 
                               * set this to false for production use.
                               *) 
    val debugLiveness = true (* debug liveness analysis *)
    val debugDead = false     (* debug dead code removal *)
    val sanityCheck = true
-in
-functor X86FP
-   (structure X86Instr  : X86INSTR
-    structure X86Props  : INSN_PROPERTIES 
-			      where I = X86Instr
-    structure Flowgraph : CONTROL_FLOW_GRAPH
-			      where I = X86Instr
-    structure Liveness  : LIVENESS 
-			      where CFG = Flowgraph
-    structure Asm       : INSTRUCTION_EMITTER 
-			      where I = X86Instr
-				and S.P = Flowgraph.P
-   ) : CFG_OPTIMIZATION = 
-struct
+
    structure CFG = Flowgraph
    structure G  = Graph
    structure I  = X86Instr
@@ -1543,14 +1604,36 @@ struct
 		       * Catch instructions that absolutely 
 		       * should not have been generated at this point.
 		       *)
-		   | (I.FLD1 | I.FLDL2E | I.FLDLG2 | I.FLDLN2 | I.FLDPI |
-		      I.FLDZ | I.FLDL _ | I.FLDS _ | I.FLDT _ | 
-		      I.FILD _ | I.FILDL _ | I.FILDLL _ | 
-		      I.FENV _ | I.FBINARY _ | I.FIBINARY _ | I.FUNARY _ |
-		      I.FUCOMPP | I.FUCOM _ | I.FUCOMP _ | I.FCOMPP | I.FXCH _ |
-                      I.FCOMI _ | I.FCOMIP _ | I.FUCOMI _ | I.FUCOMIP _ |
-		      I.FSTPL _ | I.FSTPS _ | I.FSTPT _ | I.FSTL _ | I.FSTS _ 
-		     ) => bug("Illegal FP instructions")
+		   | I.FLD1 => bug("Illegal FP instructions")
+		   | I.FLDL2E => bug("Illegal FP instructions")
+		   | I.FLDLG2 => bug("Illegal FP instructions")
+		   | I.FLDLN2 => bug("Illegal FP instructions")
+		   | I.FLDPI => bug("Illegal FP instructions")
+		   | I.FLDZ => bug("Illegal FP instructions")
+		   | I.FLDL _ => bug("Illegal FP instructions")
+		   | I.FLDS _ => bug("Illegal FP instructions")
+		   | I.FLDT _ => bug("Illegal FP instructions")
+		   | I.FILD _ => bug("Illegal FP instructions")
+		   | I.FILDL _ => bug("Illegal FP instructions")
+		   | I.FILDLL _ => bug("Illegal FP instructions")
+		   | I.FENV _ => bug("Illegal FP instructions")
+		   | I.FBINARY _ => bug("Illegal FP instructions")
+		   | I.FIBINARY _ => bug("Illegal FP instructions")
+		   | I.FUNARY _ => bug("Illegal FP instructions")
+		   | I.FUCOMPP => bug("Illegal FP instructions")
+		   | I.FUCOM _ => bug("Illegal FP instructions")
+		   | I.FUCOMP _ => bug("Illegal FP instructions")
+		   | I.FCOMPP => bug("Illegal FP instructions")
+		   | I.FXCH _ => bug("Illegal FP instructions")
+		   | I.FCOMI _ => bug("Illegal FP instructions")
+		   | I.FCOMIP _ => bug("Illegal FP instructions")
+		   | I.FUCOMI _ => bug("Illegal FP instructions")
+		   | I.FUCOMIP _ => bug("Illegal FP instructions")
+		   | I.FSTPL _ => bug("Illegal FP instructions")
+		   | I.FSTPS _ => bug("Illegal FP instructions")
+		   | I.FSTPT _ => bug("Illegal FP instructions")
+		   | I.FSTL _ => bug("Illegal FP instructions")
+		   | I.FSTS _ => bug("Illegal FP instructions")
 
 		      (* Other instructions are untouched *)
 		   | instr => FINISH(mark(I.INSTR instr, an)::code)
@@ -1575,8 +1658,12 @@ struct
                fun pop() = n := !n - 1
                fun scan(I.INSTR(I.FBINARY{binOp, ...})) = 
                       (case binOp of 
-                        ( I.FADDP | I.FSUBP | I.FSUBRP | I.FMULP
-                        | I.FDIVP | I.FDIVRP) => pop()
+                        I.FADDP => pop()
+                      | I.FSUBP => pop()
+                      | I.FSUBRP => pop()
+                      | I.FMULP => pop()
+                      | I.FDIVP => pop()
+                      | I.FDIVRP => pop()
                       | _ => ()
                       )
                  | scan(I.INSTR(I.FIBINARY{binOp, ...})) = ()
@@ -1670,5 +1757,3 @@ struct
        else repairCriticalEdges(Cfg)
    end 
 end (* functor *)
-
-end (* local *)
diff --git a/x86/mltree/x86.sml b/x86/mltree/x86.sml
index 69fbd74..7872cdd 100644
--- a/x86/mltree/x86.sml
+++ b/x86/mltree/x86.sml
@@ -32,19 +32,77 @@
  *
  * -- Allen
  *)
-local
-   val rewriteMemReg = true (* should we rewrite memRegs *)
-   val enableFastFPMode = true (* set this to false to disable the mode *)
-in
 
 functor X86
   (structure X86Instr : X86INSTR
-   structure MLTreeUtils : MLTREE_UTILS
-			where T = X86Instr.T
-   structure ExtensionComp : MLTREE_EXTENSION_COMP
-     			where I = X86Instr and T = X86Instr.T
-   structure MLTreeStream : MLTREE_STREAM
-			where T = ExtensionComp.T
+   structure MLTreeUtils : MLTREE_UTILS (* where T = X86Instr.T *)
+                           where type T.Basis.cond = X86Instr.T.Basis.cond
+                             and type T.Basis.div_rounding_mode = X86Instr.T.Basis.div_rounding_mode
+                             and type T.Basis.ext = X86Instr.T.Basis.ext
+                             and type T.Basis.fcond = X86Instr.T.Basis.fcond
+                             and type T.Basis.rounding_mode = X86Instr.T.Basis.rounding_mode
+                             and type T.Constant.const = X86Instr.T.Constant.const
+                             and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) X86Instr.T.Extension.ccx
+                             and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) X86Instr.T.Extension.fx
+                             and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) X86Instr.T.Extension.rx
+                             and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) X86Instr.T.Extension.sx
+                             and type T.I.div_rounding_mode = X86Instr.T.I.div_rounding_mode
+                             and type T.Region.region = X86Instr.T.Region.region
+                             and type T.ccexp = X86Instr.T.ccexp
+                             and type T.fexp = X86Instr.T.fexp
+                             (* and type T.labexp = X86Instr.T.labexp *)
+                             and type T.mlrisc = X86Instr.T.mlrisc
+                             and type T.oper = X86Instr.T.oper
+                             and type T.rep = X86Instr.T.rep
+                             and type T.rexp = X86Instr.T.rexp
+                             and type T.stm = X86Instr.T.stm
+   structure ExtensionComp : MLTREE_EXTENSION_COMP (* where I = X86Instr and T = X86Instr.T *)
+                             where type I.addressing_mode = X86Instr.addressing_mode
+                               and type I.ea = X86Instr.ea
+                               and type I.instr = X86Instr.instr
+                               and type I.instruction = X86Instr.instruction
+                               and type I.operand = X86Instr.operand
+                             where type T.Basis.cond = X86Instr.T.Basis.cond
+                               and type T.Basis.div_rounding_mode = X86Instr.T.Basis.div_rounding_mode
+                               and type T.Basis.ext = X86Instr.T.Basis.ext
+                               and type T.Basis.fcond = X86Instr.T.Basis.fcond
+                               and type T.Basis.rounding_mode = X86Instr.T.Basis.rounding_mode
+                               and type T.Constant.const = X86Instr.T.Constant.const
+                               and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) X86Instr.T.Extension.ccx
+                               and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) X86Instr.T.Extension.fx
+                               and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) X86Instr.T.Extension.rx
+                               and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) X86Instr.T.Extension.sx
+                               and type T.I.div_rounding_mode = X86Instr.T.I.div_rounding_mode
+                               and type T.Region.region = X86Instr.T.Region.region
+                               and type T.ccexp = X86Instr.T.ccexp
+                               and type T.fexp = X86Instr.T.fexp
+                               (* and type T.labexp = X86Instr.T.labexp *)
+                               and type T.mlrisc = X86Instr.T.mlrisc
+                               and type T.oper = X86Instr.T.oper
+                               and type T.rep = X86Instr.T.rep
+                               and type T.rexp = X86Instr.T.rexp
+                               and type T.stm = X86Instr.T.stm
+   structure MLTreeStream : MLTREE_STREAM (* where T = ExtensionComp.T *)
+                            where type T.Basis.cond = ExtensionComp.T.Basis.cond
+                              and type T.Basis.div_rounding_mode = ExtensionComp.T.Basis.div_rounding_mode
+                              and type T.Basis.ext = ExtensionComp.T.Basis.ext
+                              and type T.Basis.fcond = ExtensionComp.T.Basis.fcond
+                              and type T.Basis.rounding_mode = ExtensionComp.T.Basis.rounding_mode
+                              and type T.Constant.const = ExtensionComp.T.Constant.const
+                              and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) ExtensionComp.T.Extension.ccx
+                              and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) ExtensionComp.T.Extension.fx
+                              and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) ExtensionComp.T.Extension.rx
+                              and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) ExtensionComp.T.Extension.sx
+                              and type T.I.div_rounding_mode = ExtensionComp.T.I.div_rounding_mode
+                              and type T.Region.region = ExtensionComp.T.Region.region
+                              and type T.ccexp = ExtensionComp.T.ccexp
+                              and type T.fexp = ExtensionComp.T.fexp
+                              (* and type T.labexp = ExtensionComp.T.labexp *)
+                              and type T.mlrisc = ExtensionComp.T.mlrisc
+                              and type T.oper = ExtensionComp.T.oper
+                              and type T.rep = ExtensionComp.T.rep
+                              and type T.rexp = ExtensionComp.T.rexp
+                              and type T.stm = ExtensionComp.T.stm
     datatype arch = Pentium | PentiumPro | PentiumII | PentiumIII
     val arch : arch ref
     val cvti2f : 
@@ -65,6 +123,9 @@ functor X86
           val rewriteMemReg : bool
       end = 
 struct
+  val rewriteMemReg = true (* should we rewrite memRegs *)
+  val enableFastFPMode = true (* set this to false to disable the mode *)
+
   structure I = X86Instr
   structure T = I.T
   structure TS = ExtensionComp.TS
@@ -421,7 +482,8 @@ struct
 
           (* reduce an expression into an operand *)
       and operand(T.LI i) = I.Immed(toInt32(i)) 
-        | operand(x as (T.CONST _ | T.LABEL _)) = I.ImmedLabel x
+        | operand(x as T.CONST _) = I.ImmedLabel x
+        | operand(x as T.LABEL _) = I.ImmedLabel x
         | operand(T.LABEXP le) = I.ImmedLabel le
         | operand(T.REG(_,r)) = IntReg r
         | operand(T.LOAD(32,ea,mem)) = address(ea, mem)
@@ -969,8 +1031,8 @@ struct
 		 else
 		   move'(I.Immed(n), rdOpnd, an)
 	       end
-             | (T.CONST _ | T.LABEL _) => 
-                 move'(I.ImmedLabel exp, rdOpnd, an)
+             | T.CONST _ => move'(I.ImmedLabel exp, rdOpnd, an)
+             | T.LABEL _ => move'(I.ImmedLabel exp, rdOpnd, an)
              | T.LABEXP le => move'(I.ImmedLabel le, rdOpnd, an)
 
                (* 32-bit addition *)
@@ -1096,7 +1158,14 @@ struct
           * On the x86, TEST is superior to AND for doing the same thing,
           * since it doesn't need to write out the result in a register.
           *)
-     and cmpWithZero(cc as (T.EQ | T.NE), e as T.ANDB(ty, a, b), an) = 
+     and cmpWithZero(cc as T.EQ, e as T.ANDB(ty, a, b), an) =
+            (case ty of
+               8  => test(I.TESTB, a, b, an)
+             | 16 => test(I.TESTW, a, b, an)
+             | 32 => test(I.TESTL, a, b, an)
+             | _  => doExpr(e, newReg(), an);
+             cc)
+       | cmpWithZero(cc as T.NE, e as T.ANDB(ty, a, b), an) =
             (case ty of
                8  => test(I.TESTB, a, b, an)
              | 16 => test(I.TESTW, a, b, an)
@@ -1410,7 +1479,8 @@ struct
         *)
       and foldableFexp(T.FREG _) = true
         | foldableFexp(T.FLOAD _) = true
-        | foldableFexp(T.CVTI2F(_, (16 | 32), _)) = true
+        | foldableFexp(T.CVTI2F(_, 16, _)) = true
+        | foldableFexp(T.CVTI2F(_, 32, _)) = true
         | foldableFexp(T.CVTF2F(_, _, t)) = foldableFexp t
         | foldableFexp(T.FMARK(t, _)) = foldableFexp t
         | foldableFexp _ = false
@@ -1533,7 +1603,8 @@ struct
               (* Try to fold the the memory operand or integer conversion *) 
               and suFold(e as T.FREG _) = (LEAF(0, e, []), false)
                 | suFold(e as T.FLOAD _) = (LEAF(0, e, []), false)
-                | suFold(e as T.CVTI2F(_,(16 | 32),_)) = (LEAF(0, e, []), true)
+                | suFold(e as T.CVTI2F(_,16,_)) = (LEAF(0, e, []), true)
+                | suFold(e as T.CVTI2F(_,32,_)) = (LEAF(0, e, []), true)
                 | suFold(T.CVTF2F(_, _, t)) = suFold t
                 | suFold(T.FMARK(t, a)) = 
                   let val (t, integer) = suFold t 
@@ -1727,7 +1798,8 @@ struct
           let 
               fun isMemOpnd(T.FREG(_, f)) = isFMemReg f
                 | isMemOpnd(T.FLOAD _) = true
-                | isMemOpnd(T.CVTI2F(_, (16 | 32), _)) = true
+                | isMemOpnd(T.CVTI2F(_, 16, _)) = true
+                | isMemOpnd(T.CVTI2F(_, 32, _)) = true
                 | isMemOpnd(T.CVTF2F(_, _, t)) = isMemOpnd t
                 | isMemOpnd(T.FMARK(t, _)) = isMemOpnd t
                 | isMemOpnd _ = false
@@ -2010,5 +2082,3 @@ struct
   end 
 
 end (* functor *)
-
-end (* local *)
diff --git a/x86/omit-frameptr/x86omit-frameptr.sml b/x86/omit-frameptr/x86omit-frameptr.sml
index be5f2a4..c14cc0b 100644
--- a/x86/omit-frameptr/x86omit-frameptr.sml
+++ b/x86/omit-frameptr/x86omit-frameptr.sml
@@ -10,8 +10,50 @@
  *)
 functor X86OmitFramePointer (
     structure I : X86INSTR 
-    structure CFG : CONTROL_FLOW_GRAPH where I = I
-    structure MemRegs : MEMORY_REGISTERS where I=I
+    structure CFG : CONTROL_FLOW_GRAPH (* where I = I *)
+                    where type I.addressing_mode = I.addressing_mode
+                      and type I.ea = I.ea
+                      and type I.instr = I.instr
+                      and type I.instruction = I.instruction
+                      and type I.operand = I.operand
+    structure MemRegs : MEMORY_REGISTERS (* where I = I *)
+                        where type I.Constant.const = I.Constant.const
+                          and type I.Region.region = I.Region.region
+                          and type I.T.Basis.cond = I.T.Basis.cond
+                          and type I.T.Basis.div_rounding_mode = I.T.Basis.div_rounding_mode
+                          and type I.T.Basis.ext = I.T.Basis.ext
+                          and type I.T.Basis.fcond = I.T.Basis.fcond
+                          and type I.T.Basis.rounding_mode = I.T.Basis.rounding_mode
+                          and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) I.T.Extension.ccx
+                          and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) I.T.Extension.fx
+                          and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) I.T.Extension.rx
+                          and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) I.T.Extension.sx
+                          and type I.T.I.div_rounding_mode = I.T.I.div_rounding_mode
+                          and type I.T.ccexp = I.T.ccexp
+                          and type I.T.fexp = I.T.fexp
+                          (* and type I.T.labexp = I.T.labexp *)
+                          and type I.T.mlrisc = I.T.mlrisc
+                          and type I.T.oper = I.T.oper
+                          and type I.T.rep = I.T.rep
+                          and type I.T.rexp = I.T.rexp
+                          and type I.T.stm = I.T.stm
+                          (* and type I.addressing_mode = I.addressing_mode *)
+                          and type I.binaryOp = I.binaryOp
+                          and type I.bitOp = I.bitOp
+                          and type I.cond = I.cond
+                          and type I.fbinOp = I.fbinOp
+                          and type I.fenvOp = I.fenvOp
+                          and type I.fibinOp = I.fibinOp
+                          and type I.fsize = I.fsize
+                          and type I.funOp = I.funOp
+                          and type I.instr = I.instr
+                          and type I.instruction = I.instruction
+                          and type I.isize = I.isize
+                          and type I.move = I.move
+                          and type I.multDivOp = I.multDivOp
+                          and type I.operand = I.operand
+                          and type I.shiftOp = I.shiftOp
+                          and type I.unaryOp = I.unaryOp
     val memRegBase : CellsBasis.cell option): OMIT_FRAME_POINTER = 
 struct
   structure CFG = CFG
diff --git a/x86/ra/x86RA.sml b/x86/ra/x86RA.sml
index 806296f..20db98c 100644
--- a/x86/ra/x86RA.sml
+++ b/x86/ra/x86RA.sml
@@ -109,13 +109,45 @@
 
 functor X86RA 
   ( structure I          : X86INSTR
-    structure InsnProps  : INSN_PROPERTIES 
-			       where I = I
-    structure CFG        : CONTROL_FLOW_GRAPH 
-			       where I = I
-    structure Asm        : INSTRUCTION_EMITTER 
-			       where I = I 
-				 and S.P = CFG.P
+    structure InsnProps  : INSN_PROPERTIES (* where I = I *)
+                           where type I.addressing_mode = I.addressing_mode
+                             and type I.ea = I.ea
+                             and type I.instr = I.instr
+                             and type I.instruction = I.instruction
+                             and type I.operand = I.operand
+    structure CFG        : CONTROL_FLOW_GRAPH (* where I = I *)
+                           where type I.addressing_mode = I.addressing_mode
+                             and type I.ea = I.ea
+                             and type I.instr = I.instr
+                             and type I.instruction = I.instruction
+                             and type I.operand = I.operand
+    structure Asm        : INSTRUCTION_EMITTER (* where I = I and S.P = CFG.P *)
+                           where type I.addressing_mode = I.addressing_mode
+                             and type I.ea = I.ea
+                             and type I.instr = I.instr
+                             and type I.instruction = I.instruction
+                             and type I.operand = I.operand
+                           where type S.P.Client.pseudo_op = CFG.P.Client.pseudo_op
+                             and type S.P.T.Basis.cond = CFG.P.T.Basis.cond
+                             and type S.P.T.Basis.div_rounding_mode = CFG.P.T.Basis.div_rounding_mode
+                             and type S.P.T.Basis.ext = CFG.P.T.Basis.ext
+                             and type S.P.T.Basis.fcond = CFG.P.T.Basis.fcond
+                             and type S.P.T.Basis.rounding_mode = CFG.P.T.Basis.rounding_mode
+                             and type S.P.T.Constant.const = CFG.P.T.Constant.const
+                             and type ('s,'r,'f,'c) S.P.T.Extension.ccx = ('s,'r,'f,'c) CFG.P.T.Extension.ccx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.fx = ('s,'r,'f,'c) CFG.P.T.Extension.fx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.rx = ('s,'r,'f,'c) CFG.P.T.Extension.rx
+                             and type ('s,'r,'f,'c) S.P.T.Extension.sx = ('s,'r,'f,'c) CFG.P.T.Extension.sx
+                             and type S.P.T.I.div_rounding_mode = CFG.P.T.I.div_rounding_mode
+                             and type S.P.T.Region.region = CFG.P.T.Region.region
+                             and type S.P.T.ccexp = CFG.P.T.ccexp
+                             and type S.P.T.fexp = CFG.P.T.fexp
+                             (* and type S.P.T.labexp = CFG.P.T.labexp *)
+                             and type S.P.T.mlrisc = CFG.P.T.mlrisc
+                             and type S.P.T.oper = CFG.P.T.oper
+                             and type S.P.T.rep = CFG.P.T.rep
+                             and type S.P.T.rexp = CFG.P.T.rexp
+                             and type S.P.T.stm = CFG.P.T.stm
 
       (* Spilling heuristics determines which node should be spilled 
        * You can use Chaitin, ChowHenessey, or one of your own.
@@ -126,7 +158,12 @@ functor X86RA
        * spill code.  You can use RASpill, or RASpillWithRenaming,
        * or write your own if you are feeling adventurous.
        *)
-    structure Spill : RA_SPILL where I = I 
+    structure Spill : RA_SPILL (* where I = I *)
+                      where type I.addressing_mode = I.addressing_mode
+                        and type I.ea = I.ea
+                        and type I.instr = I.instr
+                        and type I.instruction = I.instruction
+                        and type I.operand = I.operand
 
 
     type spill_info (* user-defined abstract type *)
@@ -304,17 +341,16 @@ struct
     (* This is the generic register allocator *)
     structure Ra = 
       RegisterAllocator
-       (SpillHeur)
-       (MemoryRA             (* for memory coalescing *)
+       (structure SpillHeuristics = SpillHeur
+        structure Flowgraph = MemoryRA             (* for memory coalescing *)
          (RADeadCodeElim     (* do the funky dead code elimination stuff *)
-            (ClusterRA
+            (structure Flowgraph = ClusterRA
                (structure Flowgraph = CFG
                 structure Asm = Asm
                 structure InsnProps = InsnProps
                 structure Spill = Spill
                )
-            )
-            (fun cellkind CB.GP = true | cellkind _ = false
+             fun cellkind CB.GP = true | cellkind _ = false
              val deadRegs = deadRegs
              val affectedBlocks = affectedBlocks
              val spillInit = spillInit
diff --git a/x86/ra/x86Rewrite.sig b/x86/ra/x86Rewrite.sig
index eaacca7..ddb6486 100644
--- a/x86/ra/x86Rewrite.sig
+++ b/x86/ra/x86Rewrite.sig
@@ -1,6 +1,15 @@
 signature X86REWRITE = sig
   structure I  : X86INSTR
-  structure CB : CELLS_BASIS = CellsBasis
+  structure CB : CELLS_BASIS (* = CellsBasis *)
+                 where type CellSet.cellset = CellsBasis.CellSet.cellset
+                   and type 'a ColorTable.hash_table = 'a CellsBasis.ColorTable.hash_table
+                   and type 'a HashTable.hash_table = 'a CellsBasis.HashTable.hash_table
+                   and type SortedCells.sorted_cells = CellsBasis.SortedCells.sorted_cells
+                   and type cell = CellsBasis.cell
+                   and type cellColor = CellsBasis.cellColor
+                   and type cellkind = CellsBasis.cellkind
+                   and type cellkindDesc = CellsBasis.cellkindDesc
+                   and type cellkindInfo = CellsBasis.cellkindInfo
   val rewriteUse : I.instruction * CB.cell * CB.cell -> I.instruction
   val rewriteDef : I.instruction * CB.cell * CB.cell -> I.instruction
   val frewriteUse : I.instruction * CB.cell * CB.cell -> I.instruction
diff --git a/x86/ra/x86SpillInstr.sml b/x86/ra/x86SpillInstr.sml
index dcf2305..7417847 100644
--- a/x86/ra/x86SpillInstr.sml
+++ b/x86/ra/x86SpillInstr.sml
@@ -8,7 +8,12 @@
  * introduced before.
  *)
 functor X86SpillInstr(structure Instr: X86INSTR
-                 structure Props: INSN_PROPERTIES where I = Instr
+                      structure Props: INSN_PROPERTIES (* where I = Instr *)
+                                       where type I.addressing_mode = Instr.addressing_mode
+                                         and type I.ea = Instr.ea
+                                         and type I.instr = Instr.instr
+                                         and type I.instruction = Instr.instruction
+                                         and type I.operand = Instr.operand
 		) : ARCH_SPILL_INSTR = struct
 
   structure I  = Instr
@@ -56,7 +61,28 @@ functor X86SpillInstr(structure Instr: X86INSTR
 	  done(I.CALL{opnd=addr, defs=C.rmvReg(reg,defs), 
 				 return=return, uses=uses, 
 		      cutsTo=cutsTo, mem=mem, pops=pops}, an)
-      | I.MOVE{mvOp as (I.MOVZBL|I.MOVSBL|I.MOVZWL|I.MOVSWL), src, dst} => 
+      | I.MOVE{mvOp as I.MOVZBL, src, dst} =>
+	  let val tmpR = newReg() val tmp = I.Direct tmpR
+	  in  {proh=[tmpR], newReg=SOME tmpR,
+	       code=[mark(I.MOVE{mvOp=mvOp, src=src, dst=tmp}, an),
+		     I.move{mvOp=I.MOVL, src=tmp, dst=spillLoc}]
+	      }
+	  end
+      | I.MOVE{mvOp as I.MOVSBL, src, dst} =>
+	  let val tmpR = newReg() val tmp = I.Direct tmpR
+	  in  {proh=[tmpR], newReg=SOME tmpR,
+	       code=[mark(I.MOVE{mvOp=mvOp, src=src, dst=tmp}, an),
+		     I.move{mvOp=I.MOVL, src=tmp, dst=spillLoc}]
+	      }
+	  end
+      | I.MOVE{mvOp as I.MOVZWL, src, dst} =>
+	  let val tmpR = newReg() val tmp = I.Direct tmpR
+	  in  {proh=[tmpR], newReg=SOME tmpR,
+	       code=[mark(I.MOVE{mvOp=mvOp, src=src, dst=tmp}, an),
+		     I.move{mvOp=I.MOVL, src=tmp, dst=spillLoc}]
+	      }
+	  end
+      | I.MOVE{mvOp as I.MOVSWL, src, dst} =>
 	  let val tmpR = newReg() val tmp = I.Direct tmpR
 	  in  {proh=[tmpR], newReg=SOME tmpR,
 	       code=[mark(I.MOVE{mvOp=mvOp, src=src, dst=tmp}, an),
@@ -99,7 +125,12 @@ functor X86SpillInstr(structure Instr: X86INSTR
 	      newReg=NONE
 	     }
       | I.BINARY{binOp, src, dst} => let (* note: dst = reg *)
-	 fun multBinOp(I.MULL|I.MULW|I.MULB|I.IMULL|I.IMULW|I.IMULB) = true
+	 fun multBinOp(I.MULL) = true
+	   | multBinOp(I.MULW) = true
+	   | multBinOp(I.MULB) = true
+	   | multBinOp(I.IMULL) = true
+	   | multBinOp(I.IMULW) = true
+	   | multBinOp(I.IMULB) = true
 	   | multBinOp _ = false
 	in
 	  if multBinOp binOp then let
diff --git a/x86/x86.mdl b/x86/x86.mdl
index 88ea24b..fe2e54a 100644
--- a/x86/x86.mdl
+++ b/x86/x86.mdl
@@ -578,7 +578,8 @@ struct
       fun chop fbinOp =
           let val n = size fbinOp
           in  case Char.toLower(String.sub(fbinOp,n-1)) of
-                (#"s" | #"l") => String.substring(fbinOp,0,n-1)
+                #"s" => String.substring(fbinOp,0,n-1)
+              | #"l" => String.substring(fbinOp,0,n-1)
               | _ => fbinOp
           end
 
@@ -707,9 +708,23 @@ struct
     | BINARY of {binOp:binaryOp, src:operand, dst:operand}
 	asm: (case (src,binOp) of
                (I.Direct _,  (* tricky business here for shifts *)
-               (I.SARL | I.SHRL | I.SHLL |
-                I.SARW | I.SHRW | I.SHLW |
-                I.SARB | I.SHRB | I.SHLB)) => ``<binOp>\t%cl, <dst>''
+                I.SARL) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRL) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLL) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SARW) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRW) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLW) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SARB) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHRB) => ``<binOp>\t%cl, <dst>''
+             | (I.Direct _,  (* tricky business here for shifts *)
+                I.SHLB) => ``<binOp>\t%cl, <dst>''
              | _ => ``<binOp>\t<src>, <dst>''
              )
 	(*rtl: ``<binOp>''*)
diff --git a/x86/x86MC.sml b/x86/x86MC.sml
index f8a67ab..4481629 100644
--- a/x86/x86MC.sml
+++ b/x86/x86MC.sml
@@ -8,11 +8,111 @@
  *)
 functor X86MCEmitter
   (structure Instr : X86INSTR
-   structure Shuffle : X86SHUFFLE where I = Instr
-   structure MLTreeEval : MLTREE_EVAL where T = Instr.T
-   structure MemRegs : MEMORY_REGISTERS where I = Instr
+   structure Shuffle : X86SHUFFLE (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         (* and type I.addressing_mode = Instr.addressing_mode *)
+                         and type I.binaryOp = Instr.binaryOp
+                         and type I.bitOp = Instr.bitOp
+                         and type I.cond = Instr.cond
+                         and type I.fbinOp = Instr.fbinOp
+                         and type I.fenvOp = Instr.fenvOp
+                         and type I.fibinOp = Instr.fibinOp
+                         and type I.fsize = Instr.fsize
+                         and type I.funOp = Instr.funOp
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.isize = Instr.isize
+                         and type I.move = Instr.move
+                         and type I.multDivOp = Instr.multDivOp
+                         and type I.operand = Instr.operand
+                         and type I.shiftOp = Instr.shiftOp
+                         and type I.unaryOp = Instr.unaryOp
+   structure MLTreeEval : MLTREE_EVAL (* where T = Instr.T *)
+                          where type T.Basis.cond = Instr.T.Basis.cond
+                            and type T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                            and type T.Basis.ext = Instr.T.Basis.ext
+                            and type T.Basis.fcond = Instr.T.Basis.fcond
+                            and type T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                            and type T.Constant.const = Instr.T.Constant.const
+                            and type ('s,'r,'f,'c) T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                            and type ('s,'r,'f,'c) T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                            and type ('s,'r,'f,'c) T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                            and type ('s,'r,'f,'c) T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                            and type T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                            and type T.Region.region = Instr.T.Region.region
+                            and type T.ccexp = Instr.T.ccexp
+                            and type T.fexp = Instr.T.fexp
+                            (* and type T.labexp = Instr.T.labexp *)
+                            and type T.mlrisc = Instr.T.mlrisc
+                            and type T.oper = Instr.T.oper
+                            and type T.rep = Instr.T.rep
+                            and type T.rexp = Instr.T.rexp
+                            and type T.stm = Instr.T.stm
+   structure MemRegs : MEMORY_REGISTERS (* where I = Instr *)
+                       where type I.Constant.const = Instr.Constant.const
+                         and type I.Region.region = Instr.Region.region
+                         and type I.T.Basis.cond = Instr.T.Basis.cond
+                         and type I.T.Basis.div_rounding_mode = Instr.T.Basis.div_rounding_mode
+                         and type I.T.Basis.ext = Instr.T.Basis.ext
+                         and type I.T.Basis.fcond = Instr.T.Basis.fcond
+                         and type I.T.Basis.rounding_mode = Instr.T.Basis.rounding_mode
+                         and type ('s,'r,'f,'c) I.T.Extension.ccx = ('s,'r,'f,'c) Instr.T.Extension.ccx
+                         and type ('s,'r,'f,'c) I.T.Extension.fx = ('s,'r,'f,'c) Instr.T.Extension.fx
+                         and type ('s,'r,'f,'c) I.T.Extension.rx = ('s,'r,'f,'c) Instr.T.Extension.rx
+                         and type ('s,'r,'f,'c) I.T.Extension.sx = ('s,'r,'f,'c) Instr.T.Extension.sx
+                         and type I.T.I.div_rounding_mode = Instr.T.I.div_rounding_mode
+                         and type I.T.ccexp = Instr.T.ccexp
+                         and type I.T.fexp = Instr.T.fexp
+                         (* and type I.T.labexp = Instr.T.labexp *)
+                         and type I.T.mlrisc = Instr.T.mlrisc
+                         and type I.T.oper = Instr.T.oper
+                         and type I.T.rep = Instr.T.rep
+                         and type I.T.rexp = Instr.T.rexp
+                         and type I.T.stm = Instr.T.stm
+                         (* and type I.addressing_mode = Instr.addressing_mode *)
+                         and type I.binaryOp = Instr.binaryOp
+                         and type I.bitOp = Instr.bitOp
+                         and type I.cond = Instr.cond
+                         and type I.fbinOp = Instr.fbinOp
+                         and type I.fenvOp = Instr.fenvOp
+                         and type I.fibinOp = Instr.fibinOp
+                         and type I.fsize = Instr.fsize
+                         and type I.funOp = Instr.funOp
+                         and type I.instr = Instr.instr
+                         and type I.instruction = Instr.instruction
+                         and type I.isize = Instr.isize
+                         and type I.move = Instr.move
+                         and type I.multDivOp = Instr.multDivOp
+                         and type I.operand = Instr.operand
+                         and type I.shiftOp = Instr.shiftOp
+                         and type I.unaryOp = Instr.unaryOp
    val memRegBase : CellsBasis.cell option
-   structure AsmEmitter : INSTRUCTION_EMITTER where I = Instr) : MC_EMIT = 
+   structure AsmEmitter : INSTRUCTION_EMITTER (* where I = Instr *)
+                          where type I.addressing_mode = Instr.addressing_mode
+                            and type I.ea = Instr.ea
+                            and type I.instr = Instr.instr
+                            and type I.instruction = Instr.instruction
+                            and type I.operand = Instr.operand
+  ) : MC_EMIT =
 struct
   structure I = Instr
   structure C = I.C
@@ -317,7 +417,8 @@ struct
        end
      | I.LEA{r32, addr} => encodeReg(0wx8d, r32, addr)
      | I.CMPL{lsrc, rsrc} => arith(0wx38, 7) (rsrc, lsrc)
-     | (I.CMPW _ | I.CMPB _) => error "CMP"
+     | I.CMPW _ => error "CMP"
+     | I.CMPB _ => error "CMP"
      | I.TESTL{lsrc, rsrc} => test(32, rsrc, lsrc)
      | I.TESTB{lsrc, rsrc} => test(8, rsrc, lsrc)
      | I.TESTW _ => error "TEST"
