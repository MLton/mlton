\sec{Deviations of {\smlnj} from Standard ML}{nj-deviations}

This section lists some deviations of {\smlnj} from The Definition of
Standard ML.  Some of these are documented in the 
\htmladdnormallink
  {SML '97 Conversion Guide}
  {http://cm.bell-labs.com/cm/cs/what/smlnj/doc/Conversion/index.html}.
Since {\mlton} does not implement these features, if your program
contains any of them it will not compile under {\mlton}.  If you discover
other deviations of {\smlnj} that affect compilation under {\mlton},
please send mail to {\mltonmail}.

\begin{itemize}
\item
{\smlnj} allows spaces in long identifiers, as in {\tt S . x}.
Section 2.5 of the Definition implies that {\tt S . x} should be
treated as three separate lexical items.

\item
{\smlnj} allows {\tt =} to be rebound by the declaration:
\begin{verbatim}
val op = = 13
\end{verbatim}
This is explicitly forbidden on page 5 of the Definition.

\item
{\smlnj} extends the syntax of the language to allow
vector expressions and patterns like the following:
\begin{verbatim}
val v = #[1,2,3]
val #[x,y,z] = v
\end{verbatim}

\item 
{\smlnj} extends the syntax of the language to allow ``or'' patterns
like the following:
\begin{verbatim}
datatype foo = Foo of int | Bar of int
val (Foo x | Bar x) = Foo 13
\end{verbatim}

\item
{\smlnj} allows higher-order functors, that is, functors can be
components of structures and can be passed as functor arguments and
returned as functor results. 

\item
{\smlnj} extends the syntax of the language to allow functor and
signature definitions to occur within the scope of {\tt local} and {\tt
structure} declarations.

\item
{\smlnj} allows sharing constraints between type abbreviations in
signatures, as in the following:
\begin{verbatim}
signature SIG =
   sig
      type t = int * int
      type u = int * int
      sharing type t = u
   end
\end{verbatim}
These are disallowed by rule 78 of the definition.

\item
{\smlnj} allows {\tt and} in {\tt sharing} specs in signatures, as in
\begin{verbatim}
signature S =
   sig
      type t
      type u
      type v
      sharing type t = u
      and type u = v
   end
\end{verbatim}

\item
{\smlnj} does not expand the {\tt withtype} derived form as described by
the Definition.  According to page 55 of the Definition, the type
bindings of a {\tt withtype} declaration are substituted simultaneously
in the connected datatype.  Consider the following program.
\begin{verbatim}
type u = real
datatype a =
    A of t
  | B of u
withtype u = int
and t = u
\end{verbatim}
According to the Definition, it should be expanded to the following.
\begin{verbatim}
type u = real
datatype a =
    A of u
  | B of int
\end{verbatim}
However, {\smlnj} expands {\tt withtype} bindings sequentially, meaning
that earlier bindings are expanded within later ones.  Hence, the
above program is expanded to the following.
\begin{verbatim}
type u = real
datatype a =
    A of int
  | B of int
\end{verbatim}

\item
{\smlnj} allows {\tt withtype} specifications in signatures.

\item
{\smlnj} allows a {\tt where} structure specification that is similar
to a {\tt where type} specification.  For example:
\begin{verbatim}
structure S = struct type t = int end
signature SIG =
  sig
     structure T : sig type t end
  end where T = S
\end{verbatim}
This is equivalent to:
\begin{verbatim}
structure S = struct type t = int end
signature SIG =
  sig
     structure T : sig type t end
  end where type T.t = S.t
\end{verbatim}

\end{itemize}
