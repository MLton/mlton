\sec{Bugs}{bugs}{Bugs.html}
%
\subsection{Reporting a bug}

To report a bug, please send mail to {\mltonmail}.  Please include the
complete SML program that caused the problem and a log of a compile of
the program with {\tt -verbose 2}.
%
\subsection{Unresolved bugs}

This section lists the known places where MLton deviates from the
Definition of SML.

\begin{itemize}

\item
{\mlton} rejects rebinding of constructors with {\tt val rec}
declarations, as in
\begin{verbatim}
val rec NONE = fn () => ()
\end{verbatim}
The Definition requires this program to type check, but to raise {\tt
Bind}.

\item
{\mlton} does not hide the equality aspect of types declared in
{\tt abstype} declarations.  So, {\mlton} accepts programs like the
following, while the Definition rejects them.
\begin{verbatim}
abstype t = T with end
val _ = fn (t1, t2 : t) => t1 = t2
\end{verbatim}

\begin{verbatim}
abstype t = T with val a = T end
val _ = a = a
\end{verbatim}

One consequence of this choice is that {\mlton} accepts the following
program, in accordance with the Definition.
\begin{verbatim}
abstype t = T with val eq = op = end
val _ = fn (t1, t2 : t) => eq (t1, t2)
\end{verbatim}
Other implementations will typically reject this program, because they
make an early choice for the type of {\tt eq} to be {\tt ''a * ''a ->
bool} instead of {\tt t * t -> bool}.  The choice is understandable,
since the Definition accepts the following program.
\begin{verbatim}
abstype t = T with val eq = op = end
val _ = eq (1, 2)
\end{verbatim}

\end{itemize}
