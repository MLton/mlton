\sec{Foreign function interface (FFI)}{ffi}{Foreign_function_interface.html}
%
{\mlton}'s FFI is {\em not} part of Standard ML and it is quite
possible that this interface will change.  That having been said, with
{\mlton} it is easy to access C global variables and to make calls
from SML to C and from C to SML, at least when dealing with simple
types like {\tt char}, {\tt int}, {\tt real}, and {\tt word}.
%
\subsection{Calling from SML to C}

Suppose you would like to import from C a function with the following
prototype:
\begin{verbatim}
int foo (double d, unsigned char c);
\end{verbatim}
{\mlton} extends the syntax of SML to allow expressions like the following:
\begin{verbatim}
_import "foo": real * char -> int;
\end{verbatim}
This expression denotes a function of type {\tt real * char -> int}
whose behavior is implemented by calling the C function whose name is
{\tt foo}.  Thinking in terms of C, imagine that there are C
variables {\tt d} of type {\tt double}, {\tt c} of type {\tt unsigned
char}, and {\tt i} of type {\tt int}.  Then, the C statement
\mbox{\tt i = foo (d, c)} is executed and {\tt i} is returned.

The general form of an \verb+_import+ expresion is:
\begin{center}
{\tt \_import "}C global variable or function name{\tt "} {\it
attribute} ...{\tt : }{\it ty}{\tt ;}
\end{center}
The semicolon is not optional.

The function name is followed by a (possibly empty) sequence of
attributes, analogous to C {\tt\_\_attribute\_\_} specifiers.  For
now, the only attributes supported are {\tt cdecl} and {\tt stdcall}.
These specify the calling convention of the C function on
Cygwin/Windows, and are ignored on all other platforms.  The default
is {\tt cdecl}.  You must use {\tt stdcall} in order to correctly call
Windows API functions.

An example in the {\tt examples/ffi} directory demonstrates the use of
{\import} expressions.  The {\tt Makefile} demonstrates how to call
{\mlton} to include and link with the appropriate files.  Running {\tt
make import} will produce an executable, {\tt import}, that should
output {\tt success} when run.

\begin{verbatim}
% make import
mlton -stop o ffi-import.c
mlton import.sml ffi-import.o
% import
13
success
\end{verbatim}

\subsec{Calling from C to SML}{export}
Suppose you would like export from SML a function of type {\tt real *
char -> int} as the C function {\tt foo}.  {\mlton} extends the syntax
of SML to allow expressions like the following:
\begin{verbatim}
_export "foo": real * char -> int;
\end{verbatim}
As with {\tt \_import}, a sequence of attributes may follow the
function name.  The above expression exports a C function named {\tt
foo}, with prototype
\begin{verbatim}
Int32 foo (Real64 x0, Char x1);
\end{verbatim}
The {\export} expression denotes a function of type {\tt (real * char
-> int) -> unit}, that when called with a function {\tt f} arranges
for the exported {\tt foo} function to call {\tt f} when {\tt foo} is
called.  So, for example, the following exports and defines {\tt
foo}.
\begin{verbatim}
val e = _export "foo": real * char -> int;
val _ = e (fn (x, c) => 13 + Real.floor x + Char.ord c)
\end{verbatim}

{\mlton}'s {\tt -export-header true} option generates a C header file
with prototypes for all of the functions exported from SML.  Include
this header file in your C files to type check calls to functions
exported from SML.  This header file includes {\tt typedef}s for the
types that can be passed between SML and C, as described in the next
section.  An example in the {\tt examples/ffi} directory demonstrates
the use of {\export} expressions and generating the header file.
Running {\tt make export} will produce an executable, {\tt export},
that should output {\tt success} when run.

\begin{verbatim}
% make export
mlton -export-header true export.sml >export.h
gcc -c ffi-export.c
mlton export.sml ffi-export.o
% ./export
g starting
...
g4 (0)
success
\end{verbatim}
%
Notice that {\tt ffi-export.c} includes {\tt export.h}, the header
file generated by {\mlton}.
%
\subsection{FFI types}

{\mlton} only allows a values of certain SML types to be passed
between SML and C.  The following types are allowed: {\tt bool}, {\tt
char}, {\tt int}, {\tt real}, {\tt string}, {\tt word}.  Strings are
not null terminated, unless you manually do so from the SML side.  All
of the different sizes of (fixed-sized) integers, reals, and words are
supported as well: {\tt Int8.int}, {\tt Int16.int}, {\tt Int32.int},
{\tt Int64.int}, {\tt Real32.real}, {\tt Real64.real}, {\tt
Word8.word}, {\tt Word16.word}, {\tt Word32.word}, {\tt Word64.word}.
There is a special type, {\tt MLton.Pointer.t}, for passing C pointers
-- see \secref{pointer} for details.

Arrays, refs, and vectors of the above types are also allowed.
Because in {\mlton} monomorphic arrays and vectors are exactly the
same as their polymorphic counterpart, these are also allowed.
Unfortunately, passing tuples or datatypes is not allowed because that
would interfere with representation optimizations.

The C header file that {\tt -export-header true} generates includes
{\tt typedef}s for the C types corresponding to the SML types.  Here
is the mapping between SML types and C types.


\begin{center}
\begin{tabular}{l|l|l}
SML type & C typedef & C type\\
\hline
{\tt array} & {\tt Pointer} & {\tt char *} \\
{\tt bool} & {\tt Int32} & {\tt long} \\
{\tt char} & {\tt Word8} & {\tt unsigned char} \\
{\tt Int8.int} & {\tt Int8} & {\tt char} \\
{\tt Int16.int} & {\tt Int16} & {\tt short} \\
{\tt Int32.int} & {\tt Int32} & {\tt long} \\
{\tt Int64.int} & {\tt Int64} & {\tt long long} \\
{\tt int} & {\tt Int32} & {\tt long} \\
{\tt MLton.Pointer.t} & {\tt Pointer} & {\tt char *} \\
{\tt Real32.real} & {\tt Real32} & {\tt float} \\
{\tt Real64.real} & {\tt Real64} & {\tt double} \\
{\tt real} & {\tt Real64} & {\tt double} \\
{\tt ref} & {\tt Pointer} & {\tt char *} \\
{\tt string} & {\tt Pointer} & {\tt char *} \\
{\tt vector} & {\tt Pointer} & {\tt char *} \\
{\tt Word8.word} & {\tt Word8} & {\tt unsigned char} \\
{\tt Word16.word} & {\tt Word16} & {\tt unsigned short} \\
{\tt Word32.word} & {\tt Word32} & {\tt unsigned long} \\
{\tt Word64.word} & {\tt Word64} & {\tt unsigned long long} \\
{\tt word} & {\tt Word32} & {\tt unsigned int} \\
\end{tabular}
\end{center}

Although the C type of an array, ref, or vector is always {\tt
Pointer}, in reality, the object is layed out in the natural C
representation.  Your C code should cast to the appropriate C type if
you want to keep the C compiler from complaining.
