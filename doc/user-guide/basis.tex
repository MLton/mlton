\sec{Basis library}{basis-library}

This section describes {\mlton}'s implementation of the 2002 Standard ML
Basis Library specification, available at
\link{http://www.standardml.org/Basis/}.
By default, {\mlton} makes this library available to user programs.
There is also an older version of the specification from 1997 that is
somewhat different.  You can compile with {\tt -basis 1997} to force
use of that library.  We encourage you to update your programs to the
current specification since someday we will disable {\tt -basis 1997}.

In summary, {\mlton} implements all of the required portions of the
Basis Library.  {\mlton} also implements some of the optional
structures, as described below.  You can always obtain a complete and
current list of what's available by calling {\tt mlton -show-basis
true}.

\subsection{Toplevel types and constructors}
{
\tt eqtype 'a array\\
\tt datatype bool = false | true\\
\tt eqtype char\\
\tt type exn\\
\tt eqtype int\\
\tt datatype 'a list = nil | :: of ('a * 'a list)\\
\tt datatype 'a option = NONE | SOME of 'a\\
\tt datatype order = LESS | EQUAL | GREATER\\
\tt type real\\
\tt eqtype 'a ref\\
\tt eqtype string\\
\tt type substring\\
\tt eqtype unit\\
\tt eqtype 'a vector\\
\tt eqtype word\\
}

\subsection{Top level exception constructors}
{\tt Bind},
{\tt Chr},
{\tt Div},
{\tt Domain},
{\tt Empty},
{\tt Fail},
{\tt Match},
{\tt Option},
{\tt Overflow},
{\tt Size},
{\tt Span},
{\tt Subscript}.

\subsection{Top level values}

{\mlton does not implement the optional top level value
\verb+use: string -> unit+, which conflicts with whole
program compilation because it allows new code to be loaded
dynamically.

{\tt !},
{\tt *},
{\tt +},
{\tt -},
{\tt /},
{\tt :=},
{\tt <},
{\tt <=},
{\tt <>},
{\tt =},
{\tt >},
{\tt >=},
{\tt @},
{\tt o},
{\tt \char94},
{\tt \char126}.
{\tt abs},
{\tt app},
{\tt before},
{\tt ceil},
{\tt chr},
{\tt concat},
{\tt div},
{\tt exnMessage},
{\tt exnName},
{\tt explode},
{\tt floor},
{\tt foldl},
{\tt foldr},
{\tt getOpt},
{\tt hd},
{\tt ignore},
{\tt implode},
{\tt isSome},
{\tt length},
{\tt map},
{\tt mod},
{\tt not},
{\tt null},
{\tt ord},
{\tt print},
{\tt real},
{\tt rev},
{\tt round},
{\tt size},
{\tt str},
{\tt substring},
{\tt tl},
{\tt trunc},
{\tt valOf},
{\tt vector}.

\newcommand{\signature}[1]{{\tt #1}\\}
\subsection{Top level signatures}
\signature{ARRAY}
\signature{ARRAY2}
\signature{ARRAY\_SLICE}
\signature{BIN\_IO}
\signature{BIT\_FLAGS}
\signature{BOOL}
\signature{BYTE}
\signature{CHAR}
\signature{COMMAND\_LINE}
\signature{DATE}
\signature{GENERAL}
\signature{GENERIC\_SOCK}
\signature{IEEE\_REAL}
\signature{IMPERATIVE\_IO}
\signature{INET\_SOCK}
\signature{INTEGER}
\signature{INT\_INF}
\signature{IO}
\signature{LIST}
\signature{LIST\_PAIR}
\signature{MATH}
\signature{MONO\_ARRAY}
\signature{MONO\_ARRAY2}
\signature{MONO\_ARRAY\_SLICE}
\signature{MONO\_VECTOR}
\signature{MONO\_VECTOR\_SLICE}
\signature{NET\_HOST\_DB}
\signature{NET\_PROT\_DB}
\signature{NET\_SERV\_DB}
\signature{OPTION}
\signature{OS}
\signature{OS\_FILE\_SYS}
\signature{OS\_IO}
\signature{OS\_PATH}
\signature{OS\_PROCESS}
\signature{PACK\_REAL}
\signature{PACK\_WORD}
\signature{POSIX}
\signature{POSIX\_ERROR}
\signature{POSIX\_FILE\_SYS}
\signature{POSIX\_IO}
\signature{POSIX\_PROCESS}
\signature{POSIX\_PROC\_ENV}
\signature{POSIX\_SIGNAL}
\signature{POSIX\_SYS\_DB}
\signature{POSIX\_TTY}
\signature{PRIM\_IO}
\signature{REAL}
\signature{SOCKET}
\signature{STREAM\_IO}
\signature{STRING}
\signature{STRING\_CVT}
\signature{SUBSTRING}
\signature{TEXT}
\signature{TEXT\_IO}
\signature{TEXT\_STREAM\_IO}
\signature{TIME}
\signature{TIMER}
\signature{UNIX}
\signature{UNIX\_SOCK}
\signature{VECTOR}
\signature{VECTOR\_SLICE}
{\tt WORD}.

\newcommand{\fullmodule}[2]{{\tt #1: #2}\\ }
\subsection{Top level structures}
\fullmodule{Array}{ARRAY}
\fullmodule{Array2}{ARRAY2}
\fullmodule{ArraySlice}{ARRAY\_SLICE}
\fullmodule{BinIO}{BIN\_IO}
\fullmodule{BinPrimIO}{PRIM\_IO}
\fullmodule{Bool}{BOOL}
\fullmodule{BoolArray}{MONO\_ARRAY}
\fullmodule{BoolArray2}{MONO\_ARRAY2}
\fullmodule{BoolArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{BoolVector}{MONO\_VECTOR}
\fullmodule{BoolVectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Byte}{BYTE}
\fullmodule{Char}{CHAR}
\fullmodule{CharArray}{MONO\_ARRAY}
\fullmodule{CharArray2}{MONO\_ARRAY2}
\fullmodule{CharArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{CharVector}{MONO\_VECTOR}
\fullmodule{CharVectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{CommandLine}{COMMAND\_LINE}
\fullmodule{Date}{DATE}
\fullmodule{FixedInt}{INTEGER}
\fullmodule{General}{GENERAL}
\fullmodule{GenericSock}{GENERIC\_SOCK}
\fullmodule{IEEEReal}{IEEE\_REAL}
\fullmodule{INetSock}{INET\_SOCK}
\fullmodule{IO}{IO}
\fullmodule{Int}{INTEGER}
\fullmodule{IntArray}{MONO\_ARRAY}
\fullmodule{IntArray2}{MONO\_ARRAY2}
\fullmodule{IntArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{IntVector}{MONO\_VECTOR}
\fullmodule{IntVectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Int8}{INTEGER}
\fullmodule{Int8Array}{MONO\_ARRAY}
\fullmodule{Int8Array2}{MONO\_ARRAY2}
\fullmodule{Int8ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Int8Vector}{MONO\_VECTOR}
\fullmodule{Int8VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Int16}{INTEGER}
\fullmodule{Int16Array}{MONO\_ARRAY}
\fullmodule{Int16Array2}{MONO\_ARRAY2}
\fullmodule{Int16ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Int16Vector}{MONO\_VECTOR}
\fullmodule{Int16VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Int32}{INTEGER}
\fullmodule{Int32Array}{MONO\_ARRAY}
\fullmodule{Int32Array2}{MONO\_ARRAY2}
\fullmodule{Int32ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Int32Vector}{MONO\_VECTOR}
\fullmodule{Int32VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Int64}{INTEGER}
\fullmodule{Int64Array}{MONO\_ARRAY}
\fullmodule{Int64Array2}{MONO\_ARRAY2}
\fullmodule{Int64ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Int64Vector}{MONO\_VECTOR}
\fullmodule{Int64VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{IntInf}{INT\_INF}
\fullmodule{LargeInt}{INTEGER}
\fullmodule{LargeIntArray}{MONO_ARRAY}
\fullmodule{LargeIntArray2}{MONO_ARRAY2}
\fullmodule{LargeIntArraySlice}{MONO_ARRAY_SLICE}
\fullmodule{LargeIntVector}{MONO_VECTOR}
\fullmodule{LargeIntVectorSlice}{MONO_VECTOR_SLICE}
\fullmodule{LargeReal}{REAL}
\fullmodule{LargeRealArray}{MONO_ARRAY}
\fullmodule{LargeRealArray2}{MONO_ARRAY2}
\fullmodule{LargeRealArraySlice}{MONO_ARRAY_SLICE}
\fullmodule{LargeRealVector}{MONO_VECTOR}
\fullmodule{LargeRealVectorSlice}{MONO_VECTOR_SLICE}
\fullmodule{LargeWordArray}{MONO_ARRAY}
\fullmodule{LargeWordArray2}{MONO_ARRAY2}
\fullmodule{LargeWordArraySlice}{MONO_ARRAY_SLICE}
\fullmodule{LargeWordVector}{MONO_VECTOR}
\fullmodule{LargeWordVectorSlice}{MONO_VECTOR_SLICE}
\fullmodule{LargeWord}{WORD}
\fullmodule{List}{LIST}
\fullmodule{ListPair}{LIST\_PAIR}
\fullmodule{Math}{MATH}
\fullmodule{NetHostDB}{NET\_HOST\_DB}
\fullmodule{NetProtDB}{NET\_PROT\_DB}
\fullmodule{NetServDB}{NET\_SERV\_DB}
\fullmodule{OS}{OS}
\hspace*{0.5in}
\parbox{6in}{Use of {\tt OS.FileSys.tmpName} causes a link-time
             warning due to a security risk.  You should use {\tt
             MLton.TextIO.mkstemp} instead.}\\
\fullmodule{Option}{OPTION}
\fullmodule{Pack32Big}{PACK\_WORD}
\fullmodule{Pack32Little}{PACK\_WORD}
\fullmodule{PackReal32Big}{PACK\_REAL}
\fullmodule{PackReal32Little}{PACK\_REAL}
\fullmodule{PackReal64Big}{PACK\_REAL}
\fullmodule{PackReal64Little}{PACK\_REAL}
\fullmodule{PackRealBig}{PACK\_REAL}
\fullmodule{PackRealLittle}{PACK\_REAL}
\fullmodule{Position}{INTEGER}
\fullmodule{Posix}{POSIX}
\fullmodule{Real}{REAL}
\fullmodule{RealArray}{MONO\_ARRAY}
\fullmodule{RealArray2}{MONO\_ARRAY2}
\fullmodule{RealArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{RealVector}{MONO\_VECTOR}
\fullmodule{RealVectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Real32}{REAL}
\fullmodule{Real32Array}{MONO\_ARRAY}
\fullmodule{Real32Array2}{MONO\_ARRAY2}
\fullmodule{Real32ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Real32Vector}{MONO\_VECTOR}
\fullmodule{Real32VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Real64}{REAL}
\fullmodule{Real64Array}{MONO\_ARRAY}
\fullmodule{Real64Array2}{MONO\_ARRAY2}
\fullmodule{Real64ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Real64Vector}{MONO\_VECTOR}
\fullmodule{Real64VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Socket}{SOCKET}
\fullmodule{String}{STRING}
\fullmodule{StringCvt}{STRING\_CVT}
\fullmodule{Substring}{SUBSTRING}
\fullmodule{SysWord}{WORD}
\fullmodule{Text}{TEXT}
\fullmodule{TextIO}{TEXT\_IO}
\fullmodule{TextPrimIO}{PRIM\_IO}
\fullmodule{Time}{TIME}
\fullmodule{Timer}{TIMER}
\fullmodule{Unix}{UNIX}
\fullmodule{UnixSock}{UNIX\_SOCK}
\fullmodule{Vector}{VECTOR}
\fullmodule{VectorSlice}{VECTOR\_SLICE}
\fullmodule{Word}{WORD}
\fullmodule{WordArray}{MONO_ARRAY}
\fullmodule{WordArray2}{MONO_ARRAY2}
\fullmodule{WordArraySlice}{MONO_ARRAY_SLICE}
\fullmodule{WordVectorSlice}{MONO_VECTOR_SLICE}
\fullmodule{WordVector}{MONO_VECTOR}
\fullmodule{Word8}{WORD}
\fullmodule{Word8Array}{MONO\_ARRAY}
\fullmodule{Word8Array2}{MONO\_ARRAY2}
\fullmodule{Word8ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Word8Vector}{MONO\_VECTOR}
\fullmodule{Word8VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Word16}{WORD}
\fullmodule{Word16Array}{MONO\_ARRAY}
\fullmodule{Word16Array2}{MONO\_ARRAY2}
\fullmodule{Word16ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Word16Vector}{MONO\_VECTOR}
\fullmodule{Word16VectorSlice}{MONO\_VECTOR\_SLICE}
\fullmodule{Word32}{WORD}
\fullmodule{Word32Array}{MONO\_ARRAY}
\fullmodule{Word32Array2}{MONO\_ARRAY2}
\fullmodule{Word32ArraySlice}{MONO\_ARRAY\_SLICE}
\fullmodule{Word32Vector}{MONO\_VECTOR}
\fullmodule{Word32VectorSlice}{MONO\_VECTOR\_SLICE}

The following structures equivalences hold.\\
\begin{tabular}{l}
\tt Int = Int32 = FixedInt = Position\\
\tt IntInf = LargeInt\\
\tt Real = Real64 = LargeReal\\
\tt Word = Word32 = LargeWord = SysWord
\end{tabular}

The {\tt Real}, {\tt Real32}, and {\tt Real64} modules are implemented
using the {\tt C} math library and so the SML functions will often
reflect the behavior of the underlying library function.  We have made
some effort to unify the differences between the math libraries on
different platforms, and in particular to handle exceptional cases
according to the basis library specification.  However, there will be
differences due to different numerical algorithms and cases we may
have missed.  Please submit a bug report if you encounter an error in
the handling of an exceptional case.

On x86, real arithmetic is implemented internally using 80 bits of
precision.  Using higher precision for intermediate results in
computations can lead to different results than if all the computation
is done at 32 or 64 bits.  If you require strict IEEE compliance, you
can compile with {\tt -ieee-fp true}, which will cause intermediate
results to be stored after each operation.  This may cause a
substantial performance penalty.

\subsection{Top level functors}
{\tt ImperativeIO}\\
{\tt PrimIO}\\
{\tt StreamIO}

