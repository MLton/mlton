\sec{{\mlton} extensions}{mlton}

\subsection{{\nline} directives}
To aid in the debugging of code produced by program genenerators such as
\htmladdnormallink{Noweb}{http://www.eecs.harvard.edu/~nr/noweb/},
{\mlton} supports comments with {\nline} directives of the form {\tt (*\#line
}{\it line}{\tt.}{\it col} {\tt "}{\it file}{\tt"*)}.  Here, {\it line} and {\it
col} are sequences of decimal digits and {\it file} is the source file.  A
{\nline} directive causes the front end to believe that the character following
the right parenthesis is at the line and column of the specified file.  A
{\nline} directive only affects the reporting of error messages and does not
affect program semantics (except for functions like {\tt MLton.Exn.history}
which report source file positions).  Syntactically invalid {\nline} directives
are ignored.

\subsection{The {\tt MLton} structure}

The remainder of this section describes the modules {\mlton} makes available
that are not part of the standard basis library.  As a warning, please keep in
mind that the {\tt MLton} structure and its substructures do change from release
to release of {\mlton}.  

\begin{verbatim}
structure MLton:
   sig
      val eq: 'a * 'a -> bool
      datatype hostType = Cygwin | FreeBSD | Linux
      val hostType: hostType
      val isMLton: bool
      val safe: bool
      val size: 'a -> int

      structure Array: MLTON_ARRAY
      structure BinIO: MLTON_BIN_IO
      structure Cont: MLTON_CONT
      structure Exn: MLTON_EXN
      structure GC: MLTON_GC
      structure IntInf: MLTON_INT_INF
      structure Itimer: MLTON_ITIMER
      structure ProcEnv: MLTON_PROC_ENV
      structure Process: MLTON_PROCESS
      structure ProfileAlloc: MLTON_PROFILE
      structure ProfileTime: MLTON_PROFILE
      structure Random: MLTON_RANDOM
      structure Rlimit: MLTON_RLIMIT
      structure Rusage: MLTON_RUSAGE
      structure Signal: MLTON_SIGNAL
      structure Socket: MLTON_SOCKET
      structure Syslog: MLTON_SYSLOG
      structure TextIO: MLTON_TEXT_IO
      structure Thread: MLTON_THREAD
      structure Vector: MLTON_VECTOR
      structure Word: MLTON_WORD where type word = Word.word
      structure Word8: MLTON_WORD where type word = Word8.word
      structure World: MLTON_WORLD
   end
\end{verbatim}

\subsubsection{{\tt MLton}}

\newcommand{\entry}[1]{\item[\tt #1]\hspace{1in}\\}
\begin{description}

\entry{eq (x, y)}
returns true if {\tt x} and {\tt y} are equal as pointers.  For simple types
like {\tt char}, {\tt int}, and {\tt word}, this is the same as equals.  For
arrays, datatypes, strings, tuples, and vectors, this is a simple pointer
equality.  The semantics is a bit murky.

\entry{datatype hostType}
the possible host types that {\mlton} can generate executables for.

\entry{hostType}
the host type that the executable was generated for.

\entry{isMLton}
is always true in a {\mlton} basis library, and is always false in a stub
library.

\entry{safe}
a compile time constant that reflects the value of the {\tt -safe} switch.  It
make it easy to include assertions and checks in code that you would like
removed when running at full speed. The simplification passes of the compiler
will remove any uses of {\tt safe} at compile time.  For example, array
subscripting might be implemented as:
\begin{verbatim}
fun sub (a, i) =
   if MLton.safe andalso (i < 0 orelse i >= length a)
      then raise Subscript
   else unsafeSub (a, i)
\end{verbatim}
When compiled {\tt -safe false}, {\tt sub} will reduce to
{\tt unsafeSub}.

\entry{size x}
return the amount of heap space (in bytes) taken by the value of {\tt x}.  Size
takes time proportional to the size of its argument.  For an example, see {\tt
examples/size.sml}.

\end{description}

\subsubsec{{\tt MLton.Array}}{array}
\begin{verbatim}
signature MLTON_ARRAY =
   sig
      val unfoldi: int * 'b * (int * 'b -> 'a * 'b) -> 'a array
   end
\end{verbatim}

\begin{description}

\entry{unfoldi (n, b, f)}
construct an array $a$ of a length {\tt n}, whose elements $a_i$ are determined
by the equations $b_0 = b$ and $(a_i, b_{i+1}) = f (i, b_i)$.

\end{description}

\subsubsection{{\tt MLton.BinIO}}
\begin{verbatim}
signature MLTON_BIN_IO =
   MLTON_IO
   where type instream = BinIO.instream
   where type outstream = BinIO.outstream
\end{verbatim}

See \secref{mlton-io}.

\subsubsec{{\tt MLton.Cont}}{cont}

\begin{verbatim}
signature MLTON_CONT =
   sig
      type 'a t

      val callcc: ('a t -> 'a) -> 'a
      val prepend: 'a t * ('b -> 'a) -> 'b t
      val throw: 'a t * 'a -> 'b
      val throw': 'a t * (unit -> 'a) -> 'b
   end
\end{verbatim}

\begin{description}

\entry{type 'a t}
the type of continuations that expect a value of type {\tt 'a}.

\entry{callcc f}
apply {\tt f} to the current continuation.  At present, {\tt
callcc} takes time proportional to the current stack size.

\entry{prepend (k, f)}
compose a function {\tt f} with a continuation {\tt k} to create a
continuation that first does {\tt f} and then does {\tt k}.  This
is a constant time operation.

\entry{throw (k, v)}
throw value {\tt v} to continuation {\tt k}.  At present, {\tt throw}
takes time proportional to the size of {\tt k}.

\entry{throw' (k, th)}
a generalization of throw that evaluates {\tt th ()} in the context
of {\tt k}.  Thus, for example, if {\tt th ()} raises an exception or
grabs another continuation, it will see {\tt k}, not the current
continuation.

\end{description}

\subsubsec{{\tt MLton.Exn}}{exn}
\begin{verbatim}
signature MLTON_EXN =
   sig
      val history: exn -> string list
   end
\end{verbatim}

\begin{description}

\entry{history e}
the file positions that have raised the exception {\tt e}, in reverse
chronological order.   A {\tt handle} expression that implicitly reraises counts
as a raise.  {\tt history} will return {\tt []} unless the program is compiled
with {\tt -exn-history true}.

\end{description}

\subsubsection{{\tt MLton.GC}}
\begin{verbatim}
signature MLTON_GC =
   sig
      val collect: unit -> unit
      val pack: unit -> unit
      val setMessages: bool -> unit
      val setSummary: bool -> unit
      val unpack: unit -> unit
   end
\end{verbatim}

\begin{description}
\entry{GC.collect ()}
causes a garbage collection to occur.

\entry{GC.pack ()}
shrinks the heap as much as possible so that other processes can use available
RAM.

\entry{GC.setMessages b}
controls whether diagnostic messages are
printed at the beginning and end of each garbage collection.  It is
the same as the {\tt gc-messages} runtime system option.

\entry{GC.setSummary b}
controls whether a summary of garbage
collection statistics is printed upon termination of the program.  It
is the same as the {\tt gc-summary} runtime system option.

\entry{GC.unpack ()}
resizes the heap to the desired size.

\end{description}

\subsubsection{{\tt MLton.IntInf}}

{\mlton} represents an arbitrary precision integer either as an
unboxed 32 bit word with one tag bit and 31 bits representing a small
integer in $[-2^{30}, 2^{30})$, or as a vector of words where the
first word indicates the sign and the rest are the limbs of gmp big
integer.
\begin{verbatim}
signature MLTON_INT_INF =
   sig
      include INT_INF

       val areSmall: int * int -> bool
       val gcd: int * int -> int 
       val isSmall: int -> bool
       datatype rep =
          Small of word
        | Big of word vector
       val rep: int -> rep
       val size: int -> Int.int
   end
\end{verbatim}

\begin{description}
\entry{areSmall (a, b)}
returns true iff both {\tt a} and {\tt b} are small.

\entry{gcd (a, b)}
using the gmp's fast gcd implementation.

\entry{isSmall a}
returns true iff {\tt a} is small.

\entry{datatype rep}
the underlying representation of an IntInf.  {\tt Small} has already stripped
off the tag, so that the top bit of the word is zero.

\entry{rep i}
return the underlying representation of i.

\entry{size i}
return the number of words taken by {\tt i}.

\end{description}

\subsubsec{{\tt MLTON\_IO}}{mlton-io}

\begin{verbatim}
signature MLTON_IO =
   sig
      type instream
      type outstream

      val inFd: instream -> Posix.IO.file_desc
      val mkstemp: string -> string * outstream
      val mkstemps: {prefix: string, suffix: string} -> string * outstream
      val newIn: Posix.IO.file_desc -> instream
      val newOut: Posix.IO.file_desc -> outstream
      val outFd: outstream -> Posix.IO.file_desc
   end
\end{verbatim}

\begin{description}

\entry{inFd ins} return the file descriptor corresponding to {\tt ins}.

\entry{mkstemp s}
like the C {\tt mkstemp} function, generate and open a tempory file with prefix
{\tt s}.  This should be used instead of {\tt OS.FileSys.tmpName}, which has
security risks.

\entry{mkstemps \{prefix, suffix\}}
{\tt mkstemps} is like {\tt mkstemp}, except it has both a prefix and suffix.

\entry{newIn fd} create a new instream from file descriptor {\tt 
fd}.

\entry{newOut} create a new outstream from file descriptor {\tt 
fd}.

\entry{outFd out} return the file descriptor corresponding to
{\tt out}.
\end{description}

\subsubsec{{\tt MLton.Itimer}}{itimer}

\begin{verbatim}
signature MLTON_ITIMER =
   sig
      datatype t =
         Prof
       | Real
       | Virtual

      val set: t * {interval: Time.time,
                    value: Time.time} -> unit
      val signal: t -> Posix.Signal.signal
   end
\end{verbatim}

\begin{description}
\entry{set (t, \{interval, value\})}
set the interval timer (using {\tt setitimer}) specified by {\tt t} to the given
{\tt interval} and {\tt value}.

\entry{signal t}
return the signal corresponding to {\tt t}.
\end{description}

\subsubsection{\tt MLton.ProcEnv}
\begin{verbatim}
signature MLTON_PROC_ENV =
   sig
      val setenv: {name: string, value: string} -> unit
   end
\end{verbatim}

\begin{description}
\entry{setenv \{name, value\}}
Like the C {\tt setenv} function.
\end{description}

\subsubsection{\tt MLton.Process}

\begin{verbatim}
signature MLTON_PROCESS =
   sig
      type pid = Posix.Process.pid

      val spawn: {path: string, args: string list} -> pid
      val spawne: {path: string, args: string list, env: string list} -> pid
      val spawnp: {file: string, args: string list} -> pid
   end
\end{verbatim}

The {\tt spawn} functions provide an alternative to the {\tt fork}/{\tt exec}
idiom that is typically used on Linux to create a new process.  On Linux, the
{\tt spawn} functions are simple wrappers around {\tt fork}/{\tt exec}.
However, on Cygwin, the {\tt spawn} functions are primitive and are both faster
and more reliable than {\tt fork}/{\tt exec}.  All {\tt spawn} functions return
the process id of the spawned process.  They differ in how the executable is
found and the environment that it uses.

\begin{description}
\entry{spawn \{path, args\}}
Start a new process running the executable specified by {\tt path} with the
arguments {\tt args}.  Like {\tt Posix.Process.exec}.
\entry{spawne \{path, args, env\}}
Start a new process running the executable specified by {\tt path} with the
arguments {\tt args} and environment {\tt env}.  Like {\tt Posix.Process.exece}.
\entry{spawnp \{file, args\}}
Search the {\tt PATH} environment variable for an executable named {\tt file},
and start a new process running that executable with the arguments {\tt args}.
Like {\tt Posix.Process.execp}.
\end{description}

\subsubsec{{\tt MLton.ProfileAlloc}, {\tt MLton.ProfileTime}}{profile-structures}
This structure provides profiling control from within the program.
For more on profiling, see \secref{profiling} and {\tt
examples/profiling}. In order to most efficiently execute
non-profiled programs, all of the operations in {\tt
MLton.ProfileAlloc} are no-ops except when compiling {\tt -profile
alloc} and all the operations in {\tt MLton.ProfileTime} are no-ops
except when compiling {\tt -profile time}.

\begin{verbatim}
signature MLTON_PROFILE =
   sig
      val profile: bool
      structure Data:
         sig
            type t
            val equals: t * t -> bool
            val free: t -> unit
            val malloc: unit -> t
            val reset: t -> unit
            val write: t * string -> unit
         end
      val current: unit -> Data.t
      val setCurrent: Data.t -> unit
   end
\end{verbatim}

\begin{description}

\entry{profile}
a compile-time constant that is true when compiling {\tt -profile time}.

\entry{type Data.t} the type of a unit of profiling data.

\entry{Data.equals (x, y)}
returns true if the {\tt x} and {\tt y} are the same unit of profiling
data.

\entry{Data.free x}
frees the memory associated with the unit of profiling data {\tt x}.
It is an error to free the current unit of profiling data or to free a
previously freed unit of profiling data.

\entry{Data.malloc ()}
returns new unit of profiling data.  Each unit of profiling data is
allocated from the process heap (\emph{not} the {\mlton} heap) and
consumes memory equal in size to text segment of the executable.

\entry{Data.reset x} 
clears the accumulated ticks in the unit of profiling data {\tt x}.
It is an error to reset a previously freed unit of profiling data.

\entry{\tt write (x, f)}
writes the accumulated ticks in the unit of profiling data {\tt x} to
file {\tt f}.  It is an error to write a previously freed unit of
profiling data.  Note: a program compiled with {\tt -profile true}
will always write the current unit of profiling data at program exit
to a file named {\tt mlmon.out}.

\entry{current}
returns the current unit of profiling data.

\entry{setCurrent x}
sets the current unit of profiling data.  It is an error to set a
previously freed unit of profiling data.  

\end{description}

\subsubsection{\tt MLton.Random}
\begin{verbatim}
signature MLTON_RANDOM =
   sig
      val alphaNumString: int -> string
      val rand: unit -> word
      val seed: unit -> word
      val srand: word -> unit
      val useed: unit -> word
   end
\end{verbatim}

\begin{description}
\entry{alphaNumString n}
return a string of length {\tt n} of random alphanumeric characters.

\entry{rand ()}
return the next pseudrandom number.

\entry{seed ()}
return a random word from {\tt /dev/random}.  Useful as an arg to {\tt srand}.

\entry{srand w}
set the seed used by {\tt rand} to {\tt w}.

\entry{useed ()}
return a random word from {\tt /dev/urandom}.  Useful as an arg to {\tt srand}.
\end{description}

\subsubsection{\tt MLton.Rlimit}
This structure provides a wrapper around the C {\tt getrlimit} and {\tt
setrlimit}.
\begin{verbatim}
signature MLTON_RLIMIT =
   sig
      type rlim = word
               
      val infinity: rlim

      type resource
               
      val cpuTime: resource             (* CPU     CPU time in seconds *)
      val coreFileSize: resource        (* CORE    max core file size *)
      val dataSize: resource            (* DATA    max data size *)
      val fileSize: resource            (* FSIZE   Maximum filesize *)
      val lockedInMemorySize: resource  (* MEMLOCK max locked address space *)
      val numFiles: resource            (* NOFILE  max number of open files *)  
      val numProcesses: resource        (* NPROC   max number of processes *)
      val residentSetSize: resource     (* RSS     max resident set size *)
      val stackSize: resource           (* STACK   max stack size *)
      val virtualMemorySize: resource   (* AS      virtual memory limit *)
      
      val get: resource -> {hard: rlim, soft: rlim}
      val set: resource * {hard: rlim, soft: rlim} -> unit
   end
\end{verbatim}

\begin{description}
\entry{type rlim}
the type of resource limits.

\entry{infinity}
indicates that a resource is unlimited.

\entry{type resource}
the types of resources that can be inspected and modified.

\entry{get r}
returns the current hard and soft limits for resource {\tt r}. May
raise {\tt OS.SysErr}.

\entry{set (r, \{hard, soft\})}
sets the hard and soft limits for resource {\tt r}.  May raise {\tt OS.SysErr}.
\end{description}

\subsubsection{\tt MLton.Rusage}
\begin{verbatim}
signature MLTON_RUSAGE =
   sig
      type t = {utime: Time.time, (* user time *)
                stime: Time.time} (* system time *)
         
      val rusage: unit -> {children: t,
                           gc: t,
                           self: t}
   end
\end{verbatim}

\begin{description}
\entry{type t}
corresponds to a subset of the C {\tt struct rusage}.

\entry{rusage ()}
corresponds to the C {\tt getrusage} function.  It returns the resource usage of
the exited children, the garbage collector, and the process itself.  The process
time includes the gc time.
\end{description}

\subsubsec{{\tt MLton.Signal}}{signal}
Signals handlers are functions from threads to threads.  When a signal 
handler is invoked, it receives as an argument the thread that was
interrupted by the signal.  The signal handler returns the thread that 
it would like to resume execution.  It is an error for a signal
handler to raise an exception.  All signals are automatically blocked
for the duration of a handler.

\begin{verbatim}
signature MLTON_SIGNAL =
   sig
      include POSIX_SIGNAL

      type t
      sharing type t = signal

      val prof: t
      val vtalrm: t

      structure Mask:
         sig
            type t
               
            val all: t
            val allBut: signal list -> t
            val block: t -> unit
            val none: t
            val set: t -> unit
            val some: signal list -> t
            val unblock: t -> unit
         end

      structure Handler:
         sig
            type t

            val default: t
            val handler: (unit Thread.t -> unit Thread.t) -> t
            val ignore: t
            val isDefault: t -> bool
            val isIgnore: t -> bool
         end

      val getHandler: t -> Handler.t
      val handleDefault: t -> unit
      val handleWith': t * (unit Thread.t -> unit Thread.t) -> unit
      val handleWith: t * (unit -> unit) -> unit
      val ignore: t -> unit
      val setHandler: t * Handler.t -> unit
      val suspend: Mask.t -> unit
   end
\end{verbatim}

\begin{description}

\entry{type t} the type of signals.

\entry{prof}
{\tt SIGPROF}, the profiling signal.

\entry{vtalrm}
{\tt SIGVTALRM}, the signal for virtual timers.

\entry{type Mask.t} the type of signal masks.

\entry{Mask.all} a mask of all signals.

\entry{Mask.allBut l} a mask of all signals except for those in l.

\entry{Mask.block m} block all signals in {\tt m}.

\entry{Mask.none} a mask of no signals.

\entry{Mask.set m} set the signal mask to {\tt m}.

\entry{Mask.some l} a mask of the signals in {\tt l}.

\entry{Mask.unblock m} unblock all signals in {\tt m}.

\entry{type Handler.t} the type of signal handlers.

\entry{Handler.default} handles the signal with the default action.

\entry{Handler.handler f} handles the signal with {\tt f}.

\entry{Handler.ignore} ignores the signal.

\entry{Handler.isDefault} returns true if the handler is the default handler.

\entry{Handler.isIgnore} returns true if the handler is the ignore handler.

\entry{getHandler s} return the current handler for signal {\tt s}.

\entry{handleDefault s} set the handler for signal {\tt s} to default.

\entry{handleWith' (s, f)}
set the handler for signal {\tt s} to be the function {\tt f}.  When run, {\tt
f} will be passed the thread that was interrupted by signal {\tt s}, and should
return the thread that will resume execution.  It is an error for {\tt f} to
raise an exception.  It is an error to {\tt Thread.switch'} to an interrupted
thread with a thunk that raises an exception (either directly, or via {\tt
Thread.prepend}).  This is to avoid the possibility of aynchronous exceptions.

\entry{handleWith (s, f)} like {\tt handleWith'}, but always resumes with the
interrupted thread.

\entry{ignore s} set the handler for signal {\tt s} to ignore the signal.

\entry{setHandler (s, h)} set the handler for signal {\tt s} to {\tt h}.

\entry{suspend m}
temporarily sets the signal mask to {\tt m} and suspends until an
unmasked signal is received and handled, and then resets the mask.
\end{description}

\subsubsection{{\tt MLton.Socket}}
This module contains a bare minimum of functionality to do TCP/IP programming.
This module may disappear after the {\tt Socket} module of the standard basis
library becomes available.  Or, it may remain and be implemented on top of that
module. 
\begin{verbatim}
signature MLTON_SOCKET =
   sig
      structure Address:
         sig
            type t = word
         end
      structure Host:
         sig
            type t = {name: string}

            val getByAddress: Address.t -> t option
            val getByName: string -> t option
         end
      structure Port:
         sig
            type t = int
         end

      type t

      val accept: t -> Address.t * Port.t * TextIO.instream * TextIO.outstream
      val connect: string * Port.t -> TextIO.instream * TextIO.outstream
      val listen: unit -> Port.t * t
      val listenAt: Port.t -> t
      val shutdownRead: TextIO.instream -> unit
      val shutdownWrite: TextIO.outstream -> unit
   end
\end{verbatim}

\begin{description}

\entry{type Address.t}
the type of IP addresses.

\entry{Host.getByAddress a}
lookup the hostname (using {\tt gethostbyaddr}) corresponding to {\tt a}.

\entry{Host.getByName s}
lookup the hostname (using {\tt gethostbyname}) corresponding to {\tt s}.

\entry{type Port.t}
the type of TCP ports.

\entry{type t}
the type of sockets.

\entry{accept s}
accept a connection on socket {\tt s} and return the address and
port of the connecting socket, as well as streams corresponding to the
connection.

\entry{connect (h, p)}
connect to host {\tt h} on port {\tt p}, returning the streams
corresponding to the connection.

\entry{listen ()}
listen to a port chosen by the system.  Returns the port and the socket.

\entry{listenAt p}
listen to port {\tt p}.  Returns the socket.

\entry{shutdownRead ins}
cause the read part of the socket associated with {\tt ins} to be shutdown.

\entry{shutdownWrite out}
cause the write part of the socket associated with {\tt out} to be shutdown.
\end{description}

\subsubsection{\tt MLton.Syslog}
A complete interface to the system logging facilities.  See {\tt man 3 syslog}
for more details.
\begin{verbatim}
signature MLTON_SYSLOG =
   sig
      type openflag
         
      val CONS     : openflag
      val NDELAY   : openflag
      val PERROR   : openflag
      val PID      : openflag

      type facility

      val AUTHPRIV : facility
      val CRON     : facility
      val DAEMON   : facility
      val KERN     : facility
      val LOCAL0   : facility
      val LOCAL1   : facility
      val LOCAL2   : facility
      val LOCAL3   : facility
      val LOCAL4   : facility
      val LOCAL5   : facility
      val LOCAL6   : facility
      val LOCAL7   : facility
      val LPR      : facility
      val MAIL     : facility
      val NEWS     : facility
      val SYSLOG   : facility
      val USER     : facility
      val UUCP     : facility

      type loglevel

      val EMERG    : loglevel
      val ALERT    : loglevel
      val CRIT     : loglevel
      val ERR      : loglevel
      val WARNING  : loglevel
      val NOTICE   : loglevel
      val INFO     : loglevel
      val DEBUG    : loglevel

      val closelog: unit -> unit
      val log: loglevel * string -> unit
      val openlog: string * openflag list * facility -> unit
   end
\end{verbatim}

\begin{description}
\entry{closelog ()}
close the connection to the system logger.

\entry{log (l, s)}
log message {\tt s} at a loglevel {\tt l}.

\entry{openlog (name, flags, facility)}
open a connection to the system logger. {\tt name} will be prefixed to each
message, and is typically set to the program name.

\end{description}

\subsubsection{{\tt MLton.TextIO}}
\begin{verbatim}
signature MLTON_TEXT_IO =
   MLTON_IO
   where type instream = TextIO.instream
   where type outstream = TextIO.outstream
\end{verbatim}

See \secref{mlton-io}.

\subsubsec{{\tt MLton.Thread}}{thread}
Threads are data structures that will begin computing when {\tt
switch}ed to with a value.  {\tt MLton.Thread} does not include a
default scheduling mechanism, but it can be used to implement both
preemptive and non-preemptive threads.  For examples, see {\tt
thread1.sml} and {\tt thread2.sml} in the {\tt examples} directory.
\begin{verbatim}
signature MLTON_THREAD =
   sig
      type 'a t

      val atomicBegin: unit -> unit
      val atomicEnd: unit -> unit
      val new: ('a -> unit) -> 'a t
      val prepend: 'a t * ('b -> 'a) -> 'b t
      val switch: ('a t -> 'b t * 'b) -> 'a
      val switch': ('a t -> 'b t * (unit -> 'b)) -> 'a
   end
\end{verbatim}

\begin{description}

\entry{type 'a t}
the type of threads that expect a value of type {\tt 'a}.

\entry{atomicBegin ()}
begin a critical section.

\entry{atomicEnd ()}
end a critical section.

\entry{new f}
create a new thread that, when run, applies {\tt f} to the
value given to the thread. 

\entry{prepend (t, f)}
create a new thread (destroying {\tt t} in the process) that first applies
{\tt f} to the value given to the thread and then continues with {\tt
t}.  This is a constant time operation.

\entry{switch f}
apply {\tt f} to the current thread to get {\tt (t, v)}, and then
start running thread {\tt t} on value {\tt v}.  It is an error for
{\tt f} to perform another {\tt switch}.  {\tt f} is guaranteed
to run atomically.

\entry{switch' f}
apply {\tt f} to the current thread to get {\tt (t, g)}, and then
start running thread {\tt t} computing the value {\tt g ()}.

\end{description}

\subsubsection{\tt MLton.Vector}
\begin{verbatim}
signature MLTON_VECTOR =
   sig
      val unfoldi: int * 'b * (int * 'b -> 'a * 'b) -> 'a vector
   end
\end{verbatim}

\begin{description}

\entry{unfoldi (n, b, f)}
construct a vector $v$ of a length {\tt n}, whose elements $v_i$ are determined
by the equations $b_0 = b$ and $(v_i, b_{i+1}) = f (i, b_i)$.

\end{description}

\subsubsection{\tt MLton.Word, MLton.Word8}
\begin{verbatim}
signature MLTON_WORD =
   sig
      type word
         
      val ~ : word -> word
      val rol: word * Word.word -> word
      val ror: word * Word.word -> word
   end
\end{verbatim}

\begin{description}
\entry{\~{} w}
unary negation of {\tt w}.
\entry{rol (w, w')}
rotate left.
\entry{ror (w, w')}
rotate right.
\end{description}

\subsubsec{{\tt MLton.World}}{world}
\begin{verbatim}
signature MLTON_WORLD =
   sig
      datatype status = Clone | Original

      val load: string -> 'a
      val save: string -> status
      val saveThread: string * unit Thread.t -> unit
   end
\end{verbatim}

\begin{description}
\entry{datatype status}
used to specify whether a world is original or a restarted (a clone).

\entry{load f}
load the saved computation from file {\tt f}.

\entry{save f}
save the entire state of the computation to
the file {\tt f}.  The computation can then be restarted at a later
time using {\tt World.load} or the {\tt load-world} runtime system
option.  The call to {\tt save} in the original computation returns
{\tt Original} and the call in the restarted world returns {\tt
Clone}.  The following example is a transcript run in the {\tt
examples/save-world} directory.
\begin{verbatim}
% mlton save-world.sml
% save-world
I am the original
% save-world @MLton load-world world --
I am the clone
\end{verbatim}

\entry{saveThread (f, t)}
save the entire state of the computation to
the file {\tt f} that will resume with thread {\tt t} upon restart.

\end{description}

\subsection{{\tt SMLofNJ: SML\_OF\_NJ}}

{\tt SMLofNJ} implements a subset of the structure of the same name
provided in Standard ML of New Jersey.  It is included to make it
easier to port programs between the two systems.  The semantics of
these functions may be different than in {\smlnj}.

\begin{verbatim}
signature SML_OF_NJ =
   sig
      structure Cont:
         sig
            type 'a cont
            val callcc: ('a cont -> 'a) -> 'a
            val throw: 'a cont -> 'a -> 'b
         end
      structure SysInfo:
         sig
            exception UNKNOWN
            datatype os_kind = BEOS | MACOS | OS2 | UNIX | WIN32

            val getHostArch: unit -> string
            val getOSKind: unit -> os_kind
            val getOSName: unit -> string
         end
      structure Internals:
         sig
            structure GC:
               sig
                  val messages: bool -> unit
               end             
         end

      val exnHistory: exn -> string list
      val exportFn: string * (string * string list -> OS.Process.status) -> unit
      val exportML: string -> bool
      val getCmdName: unit -> string
      val getArgs: unit -> string list
      val getAllArgs: unit -> string list
   end
\end{verbatim}

\begin{description}

\entry{structure Cont} implements continuations.

\entry{SysInfo.getHostArch ()}
returns {\tt "X86"}.

\entry{SysInfo.getOSKind}
returns {\tt UNIX}.

\entry{SysInfo.getOSName ()}
returns {\tt "Cygwin"} or {\tt "Linux"}.

\entry{Internals.GC.messages b}
the same as {\tt MLton.GC.messages b}.

\entry{exnHistory}
the same as {\tt MLton.Exn.history}.

\entry{getCmdName ()}
the same as {\tt CommandLine.name ()}.

\entry{getArgs ()}
the same as {\tt CommandLine.arguments ()}.

\entry{getAllArgs ()}
the same as {\tt getCmdName() :: getArgs()}.

\entry{exportFn f}
save the state of the computation to a file that will apply {\tt f} to
the command-line arguments upon restart.

\entry{exportML f}
save the state of the computation to file {\tt f} and continue.
Return {\tt true} in the restarted computation and {\tt false} in the
continuing computation.

\end{description}

\subsection{{\tt Unsafe: UNSAFE}}

This module is a subset of the {\tt Unsafe} module provided by
{\smlnj}.  It is included in {\mlton} because the code generated by
ML-Yacc includes references to unsafe subscript operations.

\begin{verbatim}
signature UNSAFE =
  sig
    structure Vector: UNSAFE_VECTOR
    structure Array: UNSAFE_ARRAY

    structure CharVector: UNSAFE_MONO_VECTOR
      where type vector = CharVector.vector
      where type elem = CharVector.elem
    structure CharArray: UNSAFE_MONO_ARRAY
      where type array = CharArray.array
      where type elem = CharArray.elem

    structure Word8Vector: UNSAFE_MONO_VECTOR
      where type vector = Word8Vector.vector
      where type elem = Word8Vector.elem
    structure Word8Array: UNSAFE_MONO_ARRAY
      where type array = Word8Array.array
      where type elem = Word8Array.elem
    structure Real64Array: UNSAFE_MONO_ARRAY
      where type array = Real64Array.array
      where type elem = Real64Array.elem
  end
\end{verbatim}

\subsec{{\tt Basis1997: BASIS\_1997}}{basis1997}

Opening this module at the top-level will, for the most part, simulate
the Basis Library as implemented in previous versions of {\mlton}.
However, there are two major caveats.  First, {\tt Basis1997} inherits
much of the current Basis Library implementation.  Hence, some
functions violate the stated semantics of the previous Basis Library
specification.  For the most part, such violations are benign; the
major exception is the {\tt Time} module which now supports negative
time-values.  Second, since Standard ML does not support declaring
signatures within structures, opening this module will not introduce
signatures.  To recover such signatures, compile with {\tt -basis
1997} instead.

\subsection{{\tt SML90: SML90}}

This module has been removed from the latest Basis Library
specification.  It is included for backwards compatiblility.
