\sec{Features of {\mlton}}{features}{Features_MLton.html}
%
\newcommand{\feature}[1]{\item[\bf #1]\hspace{1in}\\}
%
\begin{description}
\feature{whole-program optimization}
Because {\mlton} compiles the whole program at once, it can perform optimization
across module boundaries.  As a consequence, {\mlton} can reduce or eliminate
the run-time penalty that arises with separate compilation of SML features such
as functors, modules, polymorphism, and higher-order functions.  {\mlton} takes
advantage of having the entire program to perform transformations such as:
defunctorization, monomorphisation, higher-order control-flow analysis,
inlining, unboxing, argument flattening, redundant-argument removal, constant
folding, and representation selection.  Whole-program compilation is an integral
part of the design of {\mlton} and is not likely to change.

\feature{supports the full SML 97 language}
{\mlton} compiles the Standard ML language as given in The Definition
of Standard ML (Revised)\cite{MTHM97}.  If there is a program that is
valid according to The Definition that is rejected by {\mlton}, it is
a bug.

\feature{complete basis library}
{\mlton} contains a complete implementation of the required parts of
the Standard ML basis library specification.  See
\secref{basis-library} for details.

\feature{excellent running times}
{\mlton} generates executables with excellent running times.
For a comparison with other SML compilers, see
\link{\makeurl{performance.html}}.
For a comparison of many compilers, including {\mlton}, see
\link{http://www.bagley.org/\~{}doug/shootout/}.

\feature{native integers and words}
In {\mlton}, integers and words are 32 bits and arithmetic does not have
any overhead due to tagging.

\feature{unboxed native arrays}
In {\mlton}, an array of integers, words, or reals uses the natural C-like
representation.  This is fast and supports easy exchange of data with C.

\feature{runtime system supports large arrays}
In {\mlton}, array lengths can be up to $2^{31} - 1$, the largest possible
twos-complement 32 bit integer.

\feature{several garbage collection strategies}
The {\mlton} runtime system uses copying, mark-compact, and generational
collection, automatically deciding which to use based on the amount of live
data relative to the amount of RAM.  The runtime system tries to keep the heap
within RAM if at all possible.

\feature{standalone executables}
{\mlton} generates standalone executables.  No additional code or
libraries are necessary in order to run an executable.  MLton can also generate
statically linked executables.

\feature{small executables}
Because of whole-program compilation, {\mlton} can use very aggressive 
dead-code elimination, which often leads to smaller executables than
with other SML compilers.

\feature{compiles large programs}
{\mlton} is sufficiently robust that it can compile large programs,
including itself (over 100K lines) and the
\htmladdnormallink
  {ML Kit Version 3}
  {http://www.itu.dk/research/mlkit/kit3/readme.html}
(75K lines).
The distributed version of {\mlton} was compiled by {\mlton}.

\feature{fast {\tt IntInf} based on GNU multiprecision library}
The {\mlton} implementation of arbitrary precision arithmetic (the
{\tt IntInf} structure) uses the
\htmladdnormallink{GNU multiprecision library ({\gmp})}
		  {http://www.gnu.org/software/gmp/gmp.html}.
Hence, for {\tt IntInf} intensive programs, {\mlton} can be an order
of magnitude or more faster than {\poly} or {\smlnj}.

\feature{simple and fast C FFI}
{\mlton} has a straightforward and fast FFI for calling from SML to C
and from C to SML.  See \secref{ffi} for details.

\feature{source-level profiling of allocation and time}
{\mlton} and {\mlprof} provide source-level profiling information.
See \secref{profiling} for details.

\feature{useful libraries}
{\mlton} has a collection of libraries that provide useful functionality that
cannot be implemented with the standard basis library.  See below for an
overview and \secref{mlton} for details.

\begin{description}

\feature{continuations}
{\mlton} supports continuations via {\tt callcc} and {\tt throw}.

\feature{finalization}
{\mlton} supports finalizable values of arbitrary type.

\feature{interval timers}
{\mlton} supports the functionality of the C {\tt setitimer} function.

\feature{random numbers}
{\mlton} has functions similar to the C {\tt rand} and {\tt srand} functions, as
well as support for access to {\tt /dev/random} and {\tt /dev/urandom}.

\feature{resource limits}
{\mlton} has functions similar to the C {\tt getrlimit} and {\tt
setrlimit} functions.

\feature{resource usage}
{\mlton} supports a subset of the functionality of the C {\tt getrusage}
function.

\feature{signal handlers}
{\mlton} supports signal handlers written in SML.  Signal handlers run
in a separate thread, and have access to the thread that was
interrupted by the signal.  Signal handlers can be used in conjunction
with threads to implement preemptive multitasking.

\feature{size primitive}
{\mlton} includes a primitive that returns the size (in bytes) of any
object.  This can be quite useful in understanding the space behavior
of a program.

\feature{system logging}
{\mlton} has a complete interface to the C {\tt syslog} function.

\feature{threads}
{\mlton} has preliminary support for threads, upon which either
preemptive or non-preemptive multitasking can be implemented.  At some
point in the future, {\mlton} may support CML, but there is still a
ways to go.

\feature{weak pointers}
{\mlton} suports weak pointers, which allow the garbage collector to
reclaim objects that it would otherwise be forced to keep.  Weak
pointers are also used to provide finalization.

\feature{world save and restore}
{\mlton} has a facility for saving the entire state of a computation
to a file and restarting it later.  This facility can be used for
staging and for checkpointing computations.  It can even be used from
within signal handlers, allowing interrupt driven checkpointing.

\end{description}
\end{description}

